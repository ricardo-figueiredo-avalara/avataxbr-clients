=begin
#BR16 - API

#This documentation is about service accessories that will compose the product BR16, this services are essencial to maintenance and configuration of accounts

OpenAPI spec version: 1.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

=end

require 'date'

module SwaggerClient

  class HeaderForGoods
    attr_accessor :message_type

    # This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    attr_accessor :account_id

    # string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    attr_accessor :company_code

    # This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    attr_accessor :document_code

    attr_accessor :participants

    # This is the public NF id. With this number is possible get invoice information directly from government.
    attr_accessor :nf_access_key

    # qr code printed on DANFE;
    attr_accessor :nfce_qr_code

    # This string indicates the type of transaction for which tax should be calculated.
    attr_accessor :transaction_type

    # This string indicates the type of transaction for which tax should be calculated. - '01' # Nota Fiscal 1/1A - '1B' # Nota Fiscal Avulsa - '02' # Nota Fiscal de Venda a-Consumidor - '2D' # Cupom Fiscal - '2E' # Cupom Fiscal-Bilhete de Passagem - '04' # Nota Fiscal de Produtor - '06' # Nota Fiscal/Conta de Energia Elétrica - '07' # Nota Fiscal de Serviço de Transporte - '08' # Conhecimento de Transporte Rodoviário de-Cargas - '8B' # Conhecimento de Transporte de-Cargas Avulso - '09' # Conhecimento de Transporte Aquaviário de-Cargas - '10' # Conhecimento Aéreo - '11' # Conhecimento de Transporte Ferroviário de-Cargas - '13' # Bilhete de Passagem Rodoviário - '14' # Bilhete de Passagem Aquaviário - '15' # Bilhete de Passagem e-Nota de-Bagagem - '16' # Bilhete de Passagem Ferroviário - '18' # Resumo de Movimento Diário - '21' # Nota Fiscal de Serviço de-Comunicação - '22' # Nota Fiscal de Serviço de Telecomunicação - '26' # Conhecimento de Transporte Multimodal de-Cargas - '27' # Nota Fiscal De Transporte Ferroviário De-Carga - '28' # Nota Fiscal/Conta de Fornecimento de Gás-Canalizado - '29' # Nota Fiscal/Conta de Fornecimento de Água-Canalizada - '55' # Nota Fiscal Eletrônica (NF-e) - '57' # Conhecimento de Transporte Eletrônico (CT-e) - '59' # Cupom Fiscal Eletrônico (CF-e-SAT) - '60' # Cupom Fiscal Eletrônico (CF-e-ECF) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
    attr_accessor :transaction_model

    # Natureza da Opreração - 'Describe kind of this transaction, summary
    attr_accessor :transaction_class

    attr_accessor :e_doc_creator_type

    # This Flag is used only when eDocCreatorType is other and the return show Taxes using eDocCreator perspective or self perspective.
    attr_accessor :e_doc_creator_perspective

    # This string is a code maintained by the client application and recorded in CUP to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
    attr_accessor :entity_code

    # currency code
    attr_accessor :currency

    # This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    attr_accessor :company_location

    # This string is the transaction date in ISO 8601 format, create transaction date
    attr_accessor :transaction_date

    # This string is the transaction date in ISO 8601 format, when products were shipped, can be empty or absent
    attr_accessor :shipping_date

    attr_accessor :additional_info

    # how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; - '3' # DANFe Simplified; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
    attr_accessor :tp_imp

    # This indicator inform transaction target place, when is AUTOMATIC the company address and entity address are analyzed to identify type of transaction target place 1- same state; 2 - interstate; 3-with exterior. Exist some cases where is necessary force this situation like when buyer from another state buy something in loco, the address are from different states, but transaction no.  Identificador de Local de destino da operação, na opção AUTOMATIC endereços da Companhia e da entidade destino são analisados para saber se é uma operação dentro do mesmo estado, interestadual ou com o exterior. Há situações onde é necessário forçar este indicador como por exemplo  Quando uma pessoa com endereço em outro estado, compra uma mercadoria de forma presencial, é uma operação interna apesar dos endereços dos envolvidos estarem em estados distintos. - 0 # AUTOMATIC - DEFAULT - 1 # Interna; - 2 # Interestadual; - 3 # Exterior) 
    attr_accessor :id_dest

    # Presence indicator - '0' # Not applicable - '1' # Presential; - '2' # Remote, internet; - '3' # Remote, phone; - '4' # NFC-e home delivery; - '9' # Remote, others 
    attr_accessor :ind_pres

    # Invoice number, sequential unique by invoice serial (Número da nota fiscal)
    attr_accessor :invoice_number

    # Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
    attr_accessor :invoice_serial

    attr_accessor :default_locations

    # Shipment
    attr_accessor :transport

    # Transactions or other invoices referenced
    attr_accessor :nf_ref

    attr_accessor :payment

    attr_accessor :purchase_info

    attr_accessor :export

    class EnumAttributeValidator
      attr_reader :datatype
      attr_reader :allowable_values

      def initialize(datatype, allowable_values)
        @allowable_values = allowable_values.map do |value|
          case datatype.to_s
          when /Integer/i
            value.to_i
          when /Float/i
            value.to_f
          else
            value
          end
        end
      end

      def valid?(value)
        !value || allowable_values.include?(value)
      end
    end

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        :'message_type' => :'messageType',
        :'account_id' => :'accountId',
        :'company_code' => :'companyCode',
        :'document_code' => :'documentCode',
        :'participants' => :'participants',
        :'nf_access_key' => :'nfAccessKey',
        :'nfce_qr_code' => :'nfceQrCode',
        :'transaction_type' => :'transactionType',
        :'transaction_model' => :'transactionModel',
        :'transaction_class' => :'transactionClass',
        :'e_doc_creator_type' => :'eDocCreatorType',
        :'e_doc_creator_perspective' => :'eDocCreatorPerspective',
        :'entity_code' => :'entityCode',
        :'currency' => :'currency',
        :'company_location' => :'companyLocation',
        :'transaction_date' => :'transactionDate',
        :'shipping_date' => :'shippingDate',
        :'additional_info' => :'additionalInfo',
        :'tp_imp' => :'tpImp',
        :'id_dest' => :'idDest',
        :'ind_pres' => :'indPres',
        :'invoice_number' => :'invoiceNumber',
        :'invoice_serial' => :'invoiceSerial',
        :'default_locations' => :'defaultLocations',
        :'transport' => :'transport',
        :'nf_ref' => :'nfRef',
        :'payment' => :'payment',
        :'purchase_info' => :'purchaseInfo',
        :'export' => :'export'
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        :'message_type' => :'String',
        :'account_id' => :'String',
        :'company_code' => :'String',
        :'document_code' => :'String',
        :'participants' => :'HeaderForGoodsParticipants',
        :'nf_access_key' => :'String',
        :'nfce_qr_code' => :'String',
        :'transaction_type' => :'String',
        :'transaction_model' => :'String',
        :'transaction_class' => :'String',
        :'e_doc_creator_type' => :'String',
        :'e_doc_creator_perspective' => :'BOOLEAN',
        :'entity_code' => :'String',
        :'currency' => :'String',
        :'company_location' => :'String',
        :'transaction_date' => :'String',
        :'shipping_date' => :'String',
        :'additional_info' => :'AdditionalInformation',
        :'tp_imp' => :'String',
        :'id_dest' => :'Integer',
        :'ind_pres' => :'String',
        :'invoice_number' => :'Integer',
        :'invoice_serial' => :'Integer',
        :'default_locations' => :'DefaultLocations',
        :'transport' => :'Transport',
        :'nf_ref' => :'Array<NRef>',
        :'payment' => :'Payment',
        :'purchase_info' => :'PurchaseInfo',
        :'export' => :'ExportInfo'
      }
    end

    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}){|(k,v), h| h[k.to_sym] = v}

      if attributes.has_key?(:'messageType')
        self.message_type = attributes[:'messageType']
      else
        self.message_type = "goods"
      end

      if attributes.has_key?(:'accountId')
        self.account_id = attributes[:'accountId']
      end

      if attributes.has_key?(:'companyCode')
        self.company_code = attributes[:'companyCode']
      end

      if attributes.has_key?(:'documentCode')
        self.document_code = attributes[:'documentCode']
      end

      if attributes.has_key?(:'participants')
        self.participants = attributes[:'participants']
      end

      if attributes.has_key?(:'nfAccessKey')
        self.nf_access_key = attributes[:'nfAccessKey']
      end

      if attributes.has_key?(:'nfceQrCode')
        self.nfce_qr_code = attributes[:'nfceQrCode']
      end

      if attributes.has_key?(:'transactionType')
        self.transaction_type = attributes[:'transactionType']
      end

      if attributes.has_key?(:'transactionModel')
        self.transaction_model = attributes[:'transactionModel']
      end

      if attributes.has_key?(:'transactionClass')
        self.transaction_class = attributes[:'transactionClass']
      end

      if attributes.has_key?(:'eDocCreatorType')
        self.e_doc_creator_type = attributes[:'eDocCreatorType']
      end

      if attributes.has_key?(:'eDocCreatorPerspective')
        self.e_doc_creator_perspective = attributes[:'eDocCreatorPerspective']
      else
        self.e_doc_creator_perspective = true
      end

      if attributes.has_key?(:'entityCode')
        self.entity_code = attributes[:'entityCode']
      end

      if attributes.has_key?(:'currency')
        self.currency = attributes[:'currency']
      end

      if attributes.has_key?(:'companyLocation')
        self.company_location = attributes[:'companyLocation']
      end

      if attributes.has_key?(:'transactionDate')
        self.transaction_date = attributes[:'transactionDate']
      end

      if attributes.has_key?(:'shippingDate')
        self.shipping_date = attributes[:'shippingDate']
      end

      if attributes.has_key?(:'additionalInfo')
        self.additional_info = attributes[:'additionalInfo']
      end

      if attributes.has_key?(:'tpImp')
        self.tp_imp = attributes[:'tpImp']
      end

      if attributes.has_key?(:'idDest')
        self.id_dest = attributes[:'idDest']
      end

      if attributes.has_key?(:'indPres')
        self.ind_pres = attributes[:'indPres']
      end

      if attributes.has_key?(:'invoiceNumber')
        self.invoice_number = attributes[:'invoiceNumber']
      end

      if attributes.has_key?(:'invoiceSerial')
        self.invoice_serial = attributes[:'invoiceSerial']
      end

      if attributes.has_key?(:'defaultLocations')
        self.default_locations = attributes[:'defaultLocations']
      end

      if attributes.has_key?(:'transport')
        self.transport = attributes[:'transport']
      end

      if attributes.has_key?(:'nfRef')
        if (value = attributes[:'nfRef']).is_a?(Array)
          self.nf_ref = value
        end
      end

      if attributes.has_key?(:'payment')
        self.payment = attributes[:'payment']
      end

      if attributes.has_key?(:'purchaseInfo')
        self.purchase_info = attributes[:'purchaseInfo']
      end

      if attributes.has_key?(:'export')
        self.export = attributes[:'export']
      end

    end

    # Show invalid properties with the reasons. Usually used together with valid?
    # @return Array for valid properies with the reasons
    def list_invalid_properties
      invalid_properties = Array.new
      if @account_id.nil?
        invalid_properties.push("invalid value for 'account_id', account_id cannot be nil.")
      end

      if @company_code.nil?
        invalid_properties.push("invalid value for 'company_code', company_code cannot be nil.")
      end

      if @company_code.to_s.length > 60
        invalid_properties.push("invalid value for 'company_code', the character length must be smaller than or equal to 60.")
      end

      if !@nfce_qr_code.nil? && @nfce_qr_code.to_s.length > 600
        invalid_properties.push("invalid value for 'nfce_qr_code', the character length must be smaller than or equal to 600.")
      end

      if !@nfce_qr_code.nil? && @nfce_qr_code.to_s.length < 100
        invalid_properties.push("invalid value for 'nfce_qr_code', the character length must be great than or equal to 100.")
      end

      if @transaction_type.nil?
        invalid_properties.push("invalid value for 'transaction_type', transaction_type cannot be nil.")
      end

      if @transaction_model.nil?
        invalid_properties.push("invalid value for 'transaction_model', transaction_model cannot be nil.")
      end

      if @e_doc_creator_type.nil?
        invalid_properties.push("invalid value for 'e_doc_creator_type', e_doc_creator_type cannot be nil.")
      end

      if @entity_code.nil?
        invalid_properties.push("invalid value for 'entity_code', entity_code cannot be nil.")
      end

      if @currency.nil?
        invalid_properties.push("invalid value for 'currency', currency cannot be nil.")
      end

      if @company_location.nil?
        invalid_properties.push("invalid value for 'company_location', company_location cannot be nil.")
      end

      if @transaction_date.nil?
        invalid_properties.push("invalid value for 'transaction_date', transaction_date cannot be nil.")
      end

      if @invoice_number.nil?
        invalid_properties.push("invalid value for 'invoice_number', invoice_number cannot be nil.")
      end

      if @invoice_serial.nil?
        invalid_properties.push("invalid value for 'invoice_serial', invoice_serial cannot be nil.")
      end

      if @payment.nil?
        invalid_properties.push("invalid value for 'payment', payment cannot be nil.")
      end

      return invalid_properties
    end

    # Check to see if the all the properties in the model are valid
    # @return true if the model is valid
    def valid?
      message_type_validator = EnumAttributeValidator.new('String', ["goods"])
      return false unless message_type_validator.valid?(@message_type)
      return false if @account_id.nil?
      return false if @company_code.nil?
      return false if @company_code.to_s.length > 60
      return false if !@nfce_qr_code.nil? && @nfce_qr_code.to_s.length > 600
      return false if !@nfce_qr_code.nil? && @nfce_qr_code.to_s.length < 100
      return false if @transaction_type.nil?
      transaction_type_validator = EnumAttributeValidator.new('String', ["Sales", "Purchase", "SalesReturn", "PurchaseReturn", "TransferReturn", "Shipping", "ShippingReturn", "Transfer", "ReceiptAdjustment", "TransferAdjustment"])
      return false unless transaction_type_validator.valid?(@transaction_type)
      return false if @transaction_model.nil?
      transaction_model_validator = EnumAttributeValidator.new('String', ["01", "1B", "02", "2D", "2E", "04", "06", "07", "08", "8B", "09", "10", "11", "13", "14", "15", "16", "18", "21", "22", "26", "27", "28", "29", "55", "57", "59", "60", "65"])
      return false unless transaction_model_validator.valid?(@transaction_model)
      return false if @e_doc_creator_type.nil?
      e_doc_creator_type_validator = EnumAttributeValidator.new('String', ["self", "other"])
      return false unless e_doc_creator_type_validator.valid?(@e_doc_creator_type)
      return false if @entity_code.nil?
      return false if @currency.nil?
      currency_validator = EnumAttributeValidator.new('String', ["BRL"])
      return false unless currency_validator.valid?(@currency)
      return false if @company_location.nil?
      return false if @transaction_date.nil?
      tp_imp_validator = EnumAttributeValidator.new('String', ["0", "1", "2", "3", "4", "5"])
      return false unless tp_imp_validator.valid?(@tp_imp)
      ind_pres_validator = EnumAttributeValidator.new('String', ["0", "1", "2", "3", "4", "9"])
      return false unless ind_pres_validator.valid?(@ind_pres)
      return false if @invoice_number.nil?
      return false if @invoice_serial.nil?
      return false if @payment.nil?
      return true
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] message_type Object to be assigned
    def message_type=(message_type)
      validator = EnumAttributeValidator.new('String', ["goods"])
      unless validator.valid?(message_type)
        fail ArgumentError, "invalid value for 'message_type', must be one of #{validator.allowable_values}."
      end
      @message_type = message_type
    end

    # Custom attribute writer method with validation
    # @param [Object] company_code Value to be assigned
    def company_code=(company_code)
      if company_code.nil?
        fail ArgumentError, "company_code cannot be nil"
      end

      if company_code.to_s.length > 60
        fail ArgumentError, "invalid value for 'company_code', the character length must be smaller than or equal to 60."
      end

      @company_code = company_code
    end

    # Custom attribute writer method with validation
    # @param [Object] nfce_qr_code Value to be assigned
    def nfce_qr_code=(nfce_qr_code)

      if !nfce_qr_code.nil? && nfce_qr_code.to_s.length > 600
        fail ArgumentError, "invalid value for 'nfce_qr_code', the character length must be smaller than or equal to 600."
      end

      if !nfce_qr_code.nil? && nfce_qr_code.to_s.length < 100
        fail ArgumentError, "invalid value for 'nfce_qr_code', the character length must be great than or equal to 100."
      end

      @nfce_qr_code = nfce_qr_code
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] transaction_type Object to be assigned
    def transaction_type=(transaction_type)
      validator = EnumAttributeValidator.new('String', ["Sales", "Purchase", "SalesReturn", "PurchaseReturn", "TransferReturn", "Shipping", "ShippingReturn", "Transfer", "ReceiptAdjustment", "TransferAdjustment"])
      unless validator.valid?(transaction_type)
        fail ArgumentError, "invalid value for 'transaction_type', must be one of #{validator.allowable_values}."
      end
      @transaction_type = transaction_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] transaction_model Object to be assigned
    def transaction_model=(transaction_model)
      validator = EnumAttributeValidator.new('String', ["01", "1B", "02", "2D", "2E", "04", "06", "07", "08", "8B", "09", "10", "11", "13", "14", "15", "16", "18", "21", "22", "26", "27", "28", "29", "55", "57", "59", "60", "65"])
      unless validator.valid?(transaction_model)
        fail ArgumentError, "invalid value for 'transaction_model', must be one of #{validator.allowable_values}."
      end
      @transaction_model = transaction_model
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] e_doc_creator_type Object to be assigned
    def e_doc_creator_type=(e_doc_creator_type)
      validator = EnumAttributeValidator.new('String', ["self", "other"])
      unless validator.valid?(e_doc_creator_type)
        fail ArgumentError, "invalid value for 'e_doc_creator_type', must be one of #{validator.allowable_values}."
      end
      @e_doc_creator_type = e_doc_creator_type
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] currency Object to be assigned
    def currency=(currency)
      validator = EnumAttributeValidator.new('String', ["BRL"])
      unless validator.valid?(currency)
        fail ArgumentError, "invalid value for 'currency', must be one of #{validator.allowable_values}."
      end
      @currency = currency
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] tp_imp Object to be assigned
    def tp_imp=(tp_imp)
      validator = EnumAttributeValidator.new('String', ["0", "1", "2", "3", "4", "5"])
      unless validator.valid?(tp_imp)
        fail ArgumentError, "invalid value for 'tp_imp', must be one of #{validator.allowable_values}."
      end
      @tp_imp = tp_imp
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] ind_pres Object to be assigned
    def ind_pres=(ind_pres)
      validator = EnumAttributeValidator.new('String', ["0", "1", "2", "3", "4", "9"])
      unless validator.valid?(ind_pres)
        fail ArgumentError, "invalid value for 'ind_pres', must be one of #{validator.allowable_values}."
      end
      @ind_pres = ind_pres
    end

    # Checks equality by comparing each attribute.
    # @param [Object] Object to be compared
    def ==(o)
      return true if self.equal?(o)
      self.class == o.class &&
          message_type == o.message_type &&
          account_id == o.account_id &&
          company_code == o.company_code &&
          document_code == o.document_code &&
          participants == o.participants &&
          nf_access_key == o.nf_access_key &&
          nfce_qr_code == o.nfce_qr_code &&
          transaction_type == o.transaction_type &&
          transaction_model == o.transaction_model &&
          transaction_class == o.transaction_class &&
          e_doc_creator_type == o.e_doc_creator_type &&
          e_doc_creator_perspective == o.e_doc_creator_perspective &&
          entity_code == o.entity_code &&
          currency == o.currency &&
          company_location == o.company_location &&
          transaction_date == o.transaction_date &&
          shipping_date == o.shipping_date &&
          additional_info == o.additional_info &&
          tp_imp == o.tp_imp &&
          id_dest == o.id_dest &&
          ind_pres == o.ind_pres &&
          invoice_number == o.invoice_number &&
          invoice_serial == o.invoice_serial &&
          default_locations == o.default_locations &&
          transport == o.transport &&
          nf_ref == o.nf_ref &&
          payment == o.payment &&
          purchase_info == o.purchase_info &&
          export == o.export
    end

    # @see the `==` method
    # @param [Object] Object to be compared
    def eql?(o)
      self == o
    end

    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [message_type, account_id, company_code, document_code, participants, nf_access_key, nfce_qr_code, transaction_type, transaction_model, transaction_class, e_doc_creator_type, e_doc_creator_perspective, entity_code, currency, company_location, transaction_date, shipping_date, additional_info, tp_imp, id_dest, ind_pres, invoice_number, invoice_serial, default_locations, transport, nf_ref, payment, purchase_info, export].hash
    end

    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)
      self.class.swagger_types.each_pair do |key, type|
        if type =~ /\AArray<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            self.send("#{key}=", attributes[self.class.attribute_map[key]].map{ |v| _deserialize($1, v) } )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          self.send("#{key}=", _deserialize(type, attributes[self.class.attribute_map[key]]))
        end # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end

    # Deserializes the data based on type
    # @param string type Data type
    # @param string value Value to be deserialized
    # @return [Object] Deserialized data
    def _deserialize(type, value)
      case type.to_sym
      when :DateTime
        DateTime.parse(value)
      when :Date
        Date.parse(value)
      when :String
        value.to_s
      when :Integer
        value.to_i
      when :Float
        value.to_f
      when :BOOLEAN
        if value.to_s =~ /\A(true|t|yes|y|1)\z/i
          true
        else
          false
        end
      when :Object
        # generic object (usually a Hash), return directly
        value
      when /\AArray<(?<inner_type>.+)>\z/
        inner_type = Regexp.last_match[:inner_type]
        value.map { |v| _deserialize(inner_type, v) }
      when /\AHash<(?<k_type>.+?), (?<v_type>.+)>\z/
        k_type = Regexp.last_match[:k_type]
        v_type = Regexp.last_match[:v_type]
        {}.tap do |hash|
          value.each do |k, v|
            hash[_deserialize(k_type, k)] = _deserialize(v_type, v)
          end
        end
      else # model
        temp_model = SwaggerClient.const_get(type).new
        temp_model.build_from_hash(value)
      end
    end

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # to_body is an alias to to_hash (backward compatibility)
    # @return [Hash] Returns the object in the form of hash
    def to_body
      to_hash
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = self.send(attr)
        next if value.nil?
        hash[param] = _to_hash(value)
      end
      hash
    end

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map{ |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end

  end

end
