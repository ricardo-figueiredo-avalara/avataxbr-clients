/**
 * AvaTax Brazil
 * The Avatax-Brazil API exposes the most commonly services available for interacting with the AvaTax-Brazil services, allowing calculation of taxes, issuing electronic invoice documents and modifying existing transactions when allowed by tax authorities.  This API is exclusively for use by business with a physical presence in Brazil.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://avataxbr-sandbox.avalarabrasil.com.br/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AccountCompany {
    'companyId': string;
    'companyCode': string;
    'companyName': string;
}

export class AdditionalInformation {
    /**
    * Additional information of fiscal interest
    */
    'fiscalInfo': string;
    /**
    * Additional information of user interest
    */
    'complementaryInfo': string;
    /**
    * Referenced Process
    */
    'procRef': Array<AdditionalInformationProcRef>;
}

export class AdditionalInformationProcRef {
    /**
    * Process Identifier
    */
    'nProc': string;
    /**
    * Process Origin - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
    */
    'indProc': AdditionalInformationProcRef.IndProcEnum;
}

export namespace AdditionalInformationProcRef {
    export enum IndProcEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _9 = <any> '9'
    }
}
export class Address {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

export class Agast {
    /**
    * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
    */
    'code': string;
    /**
    * Agast Description
    */
    'description': string;
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    'codeType': AgastCodeType;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'N'  # NO TAXABLE     - 'I'  # IMMUNE 
    */
    'cstIPI': Agast.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * when the company is Real Profit inform if this item is cumulative or no cumulative by default
    */
    'pisCofinsTaxReporting': Agast.PisCofinsTaxReportingEnum;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruablePISTaxation': Agast.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruableCOFINSTaxation': Agast.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
    */
    'accruableCSLLTaxation': Agast.AccruableCSLLTaxationEnum;
    'csllExemptLegalReason': string;
    'csllExemptLegalReasonCode': string;
    'withholding': AgastWithholding;
    /**
    * for service items with City Jurisdiction, inform where the ISS tax is due
    */
    'issDueatDestination': boolean;
    /**
    * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
    */
    'pisCofinsCreditNotAllowed': boolean;
    /**
    * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
    */
    'issTaxation': Agast.IssTaxationEnum;
    /**
    * This is an array of tax object related to an agast.
    */
    'federalTaxRate': Array<TaxTypeRate>;
    'specialProductClass': Agast.SpecialProductClassEnum;
    /**
    * One per State
    */
    'icmsConf': Array<AgastIcmsConf>;
}

export namespace Agast {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        N = <any> 'N',
        I = <any> 'I'
    }
    export enum PisCofinsTaxReportingEnum {
        Cumulative = <any> 'cumulative',
        NoCumulative = <any> 'noCumulative'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum IssTaxationEnum {
        T = <any> 'T',
        E = <any> 'E',
        F = <any> 'F',
        A = <any> 'A',
        L = <any> 'L',
        I = <any> 'I'
    }
    export enum SpecialProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRIFICANT = <any> 'FUEL AND LUBRIFICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUME = <any> 'PERFUME',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class AgastCodeType {
    /**
    * - 'NCM' - 'NBS' - 'LC116' - 'SERVICE UNREGULATED' 
    */
    'code': number;
    'name': AgastCodeType.NameEnum;
}

export namespace AgastCodeType {
    export enum NameEnum {
        NCM = <any> 'NCM',
        NBS = <any> 'NBS',
        LC116 = <any> 'LC116',
        SERVICEUNREGULATED = <any> 'SERVICE UNREGULATED'
    }
}
export class AgastExtendForSefaz {
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    /**
    * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
    */
    'nve': string;
    /**
    * Sales Unit
    */
    'unit': string;
    /**
    * Sales Taxable Unit
    */
    'unitTaxable': string;
    /**
    * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
    */
    'nFCI': string;
}

/**
* See definitions IcmsConfByState
*/
export class AgastIcmsConf {
    'code': string;
    'state': StateEnum;
}

/**
* inform if this item is subject to withholding tax on service Transactions, default true
*/
export class AgastWithholding {
    'iRRF': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iRRFLegalReason': string;
    /**
    * Item subjecto to payroll discharge Item sujeto à desoneraçãode folha de pagamento 
    */
    'iNSSSubjectToDischarge': boolean;
    'iNSS': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iNSSLegalReason': string;
    'iNSsForSimples': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iNSSForSimplesLegalReason': string;
    'pIS': AgastWithholdingPIS;
    'cOFINS': AgastWithholdingCOFINS;
    'cSLL': AgastWithholdingCSLL;
}

/**
* inform if this item is subject to withholding COFINS on service Transactions, by entity type, default true
*/
export class AgastWithholdingCOFINS {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

/**
* inform if this item is subject to withholding CSLL on service Transactions, by entity type, default true
*/
export class AgastWithholdingCSLL {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

/**
* inform if this item is subject to withholding PIS on service Transactions, by entity type, default true
*/
export class AgastWithholdingPIS {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

export class Body {
    'companyCode': string;
}

export class Body1 {
    /**
    * Destination code.
    */
    'newCode': string;
}

export class Body2 {
    'content': string;
}

export class Body3 {
    'content': string;
}

export class Body4 {
    'startDate': Date;
    'finishDate': Date;
}

/**
* Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '01' # Operação Tributável com Alíquota Básica - '02' # Operação Tributável com Alíquota Diferenciada - '03' # Operação Tributável com Alíquota por Unidade de Medida de Produto - '04' # Operação Tributável Monofásica - 'Revenda a Alíquota Zero - '05' # Operação Tributável por Substituição Tributária - '06' # Operação Tributável a Alíquota Zero - '07' # Operação Isenta da Contribuição - '08' # Operação sem Incidência da Contribuição - '09' # Operação com Suspensão da Contribuição - '49' # Outras Operações de Saída - '50' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '51' # Operação com Direito a Crédito – Vinculada Exclusivamente a Receita Não Tributada no Mercado Interno - '52' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita de Exportação - '53' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '54' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '55' # Operação com Direito a Crédito - 'Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '56' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '60' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '61' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Não-Tributada no Mercado Interno - '62' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita de Exportação - '63' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '64' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '65' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '66' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '67' # Crédito Presumido - 'Outras Operações - '70' # Operação de Aquisição sem Direito a Crédito - '71' # Operação de Aquisição com Isenção - '72' # Operação de Aquisição com Suspensão - '73' # Operação de Aquisição a Alíquota Zero - '74' # Operação de Aquisição sem Incidência da Contribuição - '75' # Operação de Aquisição por Substituição Tributária - '98' # Outras Operações de Entrada - '99' # Outras Operações 
*/
export class CSTPistCofinsEnum {
}

/**
* Source of product or merchandise, - '0' # National goods - 'except those treated in codes 3,4, 5 and 8 - '1' # Imported directly by seller, except those in code 6 - '2' # Foreign goods - 'Acquired in the internal market (inside Brazil), except those in code 7 - '3' # Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - 'Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - 'Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - 'Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # Merchandise or goods with imported content above 70% 
*/
export class CSTTableAEnum {
}

/**
* Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '00' # Taxed in its totality - '10' # Taxed and subject to tax substitution (ICMS ST) - '20' # Taxed with Tax Base Reduction - '30' # Exempt /Not Taxed and subject to tax Substitution (ICMS#ST) - '40' # Tax Exempt - '41' # Not Taxed - '50' # Taxes Suspended - '51' # Taxes Diferred - '60' # ICMS Tax already collected through Substituition (ICMS ST) - '70' # Taxed with Tax Base Reduction and subject to Tax Subsititution (ICMS ST) - '90' # Others 
*/
export class CSTTableBEnum {
}

export class CalcModelEnum {
}

export class CalculatedTaxSummaryForGoods {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line taxed discounts
    */
    'taxedDiscount': number;
    /**
    * sum of all line untaxed discounts
    */
    'untaxedDiscount': number;
    /**
    * sum of all line lineAmount attribute
    */
    'subtotal': number;
    /**
    * sum of all line tax attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute + sum of all line tax attribute not VAT - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': CalculatedTaxSummaryForGoodsTaxByType;
}

export class CalculatedTaxSummaryForGoodsTaxByType {
    'icms': TaxByTypeSummaryForGoods;
    'icmsSt': TaxByTypeSummaryForGoods;
    'icmsStSd': TaxByTypeSummaryForGoods;
    'icmsPartOwn': TaxByTypeSummaryForGoods;
    'icmsPartDest': TaxByTypeSummaryForGoods;
    'icmsDifaFCP': TaxByTypeSummaryForGoods;
    'icmsDifaDest': TaxByTypeSummaryForGoods;
    'icmsDifaRemet': TaxByTypeSummaryForGoods;
    'icmsRf': TaxByTypeSummaryForGoods;
    'icmsDeson': TaxByTypeSummaryForGoods;
    'icmsCredsn': TaxByTypeSummaryForGoods;
    'pis': TaxByTypeSummaryForGoods;
    'pisSt': TaxByTypeSummaryForGoods;
    'cofins': TaxByTypeSummaryForGoods;
    'cofinsSt': TaxByTypeSummaryForGoods;
    'ipi': TaxByTypeSummaryForGoods;
    'ipiReturned': TaxByTypeSummaryForGoods;
    'ii': TaxByTypeSummaryForGoods;
    'iof': TaxByTypeSummaryForGoods;
    'aproxtribState': TaxByTypeSummaryForGoods;
    'aproxtribFed': TaxByTypeSummaryForGoods;
}

export class CfopConf {
    /**
    * main unique identificator
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': CfopConf.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': CfopConf.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': CfopConf.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    'name': string;
    'description': string;
    /**
    * inform if the transaction is an operation to internalizing item or value
    */
    'wayType': CfopConf.WayTypeEnum;
    /**
    * CFOP code (tax code operation) when the transactions are within the same state.
    */
    'codInState': number;
    /**
    * CFOP code (tax code operation) when the transactions are to another state.
    */
    'codOtherState': number;
    /**
    * CFOP code (tax code operation) when the transactions are to another country.
    */
    'codOtherCountry': number;
    'cstICMSSameState': CstIcmsEnum;
    'cstICMSOtherState': CstIcmsEnum;
    'cstICMSOtherCountry': CstIcmsEnum;
    /**
    * this field is used to define right CFOP, one operation type can be specialized to item product, item merchandise or generic
    */
    'productType': CfopConf.ProductTypeEnum;
    /**
    * field used to indicate an operation to ICMS tax payer
    */
    'operationToTaxPayerOtherState': boolean;
    /**
    * field used to indicate an operation to items sibject to ICMS-ST
    */
    'operationWithST': boolean;
    /**
    * field used to indicate an operation to free zone
    */
    'operationToFreeZone': boolean;
    /**
    * field used to indicate an operation to some product class specifically
    */
    'specificForProductClass': CfopConf.SpecificForProductClassEnum;
}

export namespace CfopConf {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum ProductTypeEnum {
        FORPRODUCT = <any> 'FOR PRODUCT',
        FORMERCHANDISE = <any> 'FOR MERCHANDISE',
        NORESTRICTION = <any> 'NO RESTRICTION'
    }
    export enum SpecificForProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRIFICANT = <any> 'FUEL AND LUBRIFICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUM = <any> 'PERFUM',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class Company {
    /**
    * string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'code': string;
    /**
    * Official Company name (Razão Social)
    */
    'officialName': string;
    /**
    * Company name (DBA - Nome de Fantasia),  Used to identify branches/subsidiaries with same name
    */
    'name': string;
    'entityType': EntityType;
    /**
    * Company has participation of state-owned capital (it will be considerated like a government entity)
    */
    'subjectToSRF1234': boolean;
    'federalTaxRegime': FederalTaxRegime;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'pisSubjectTo': Company.PisSubjectToEnum;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'cofinsSubjectTo': Company.CofinsSubjectToEnum;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'csllSubjectTo': Company.CsllSubjectToEnum;
    /**
    * When th company is REAL PROFIT usually it operates under a Non-Cumulative PIS/COFINS regime But exist some services that are always Cumulative regime. If the company has all receipts from Non-Cumulative services this flag will be set to True. This flag informs special conditions to credit of PIS/COFINS when this company is out of Free zone and  purchases from Free Zone Company Quando uma empresa fora da Zona Franca adquire uma produto ou serviço de uma empresa situada na Zona Franca de Manaus, o crédito de PIS E COFINS segue estas aliquotas diferenciadas. Fundamentação, art. 5º da Instrução Normativa SRF nº 546/2005; art. 3º, § 12 da Lei nº 10.637/2002; art. 3º, § 17 da Lei nº 10.833/2003; art. 4º da Lei nº 11.307/2006. DESTINATÁRIO ALÍQUOTAS PIS COFINS a) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure a Contribuição para o PIS/PASEP no regime de não-cumulatividade débito 0,65% 3% crédito 1% 4,6% c) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure o imposto de renda com base no lucro real e que tenha sua receita, total ou parcialmente, excluída do regime de incidência não-cumulativa da Contribuição para o PIS/PASEP débito 1,3% 6% crédito 1,65% 7,6% 
    */
    'receiptsAreFullNoCumulativePisCofins': boolean;
    /**
    * On purchase transaction, to force withholding INSS this Flag can be set to True
    */
    'inssWithholdSubjectTo': boolean;
    /**
    * On purchase transaction, to force withhold ISS this Flag can be set to True
    */
    'issWithholdSubjectTo': boolean;
    /**
    * On purchase transaction, if this flag is FALSE, the system will not withhold IRRF. if this flag is TRUE the system will analise other rules to define if will have witholding 
    */
    'irrfWithholdSubjectTo': boolean;
    /**
    * Actual ICMS Rate for this company (if the company is Tax Regime Simplified). Aliquota de ICMS da companhia caso Optante do Simples 
    */
    'icmsRateForSimplestaxregime': number;
    /**
    * ICMS Exempt when Tax Regime is Simplified because total gross revenue is bellow amount defined by state (see PARANÁ State) Isenção do ICMS no Simples Nacional para faixa de receita bruta 
    */
    'isExemptByGrossRevenueForSimplestaxregime': boolean;
    'configuration': CompanyConfiguration;
    'mailServer': CompanyMailServer;
    /**
    * Person or company authorized to downloadNFe
    */
    'authorizedToDownloadNFe': Array<CompanyAuthorizedToDownloadNFe>;
}

export namespace Company {
    export enum PisSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
    export enum CofinsSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
    export enum CsllSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
}
export class CompanyAuthorizedToDownloadNFe {
    /**
    * Federal tax id, CNPJ or CPF
    */
    'federalTaxId': string;
}

export class CompanyConfiguration {
    /**
    * digital certificate A1 model, p12, encoded by base64
    */
    'certificate': string;
    /**
    * certificate password
    */
    'certificatepwd': string;
    /**
    * expiration date of this certificate
    */
    'certificateexpiration': Date;
    /**
    * company logo image encoded by base64
    */
    'logo': string;
    /**
    * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; 
    */
    'tpImpNFe': CompanyConfiguration.TpImpNFeEnum;
    /**
    * how the document will be printed - '0' # without DANFE; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
    */
    'tpImpNFCe': CompanyConfiguration.TpImpNFCeEnum;
}

export namespace CompanyConfiguration {
    export enum TpImpNFeEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2'
    }
    export enum TpImpNFCeEnum {
        _0 = <any> '0',
        _4 = <any> '4',
        _5 = <any> '5'
    }
}
export class CompanyMailServer {
    /**
    * User for login on email server
    */
    'user': string;
    /**
    * Password to login on email server
    */
    'password': string;
    /**
    * smtp address to email server
    */
    'smtpAddress': string;
    /**
    * port
    */
    'port': number;
    /**
    * email address to identify the sender e-mail, to send a XML and DANFE
    */
    'emailFrom': string;
    /**
    * protocol SSL or TLS
    */
    'protocol': CompanyMailServer.ProtocolEnum;
    /**
    * Message to add to email body
    */
    'templatemessageToEmail': string;
}

export namespace CompanyMailServer {
    export enum ProtocolEnum {
        Ssl = <any> 'ssl',
        Tls = <any> 'tls'
    }
}
/**
* On sales process inform the CST that the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
*/
export class CstIcmsEnum {
}

export class CustomAgast {
    /**
    * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
    */
    'code': string;
    /**
    * Agast Description
    */
    'description': string;
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    'codeType': AgastCodeType;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'N'  # NO TAXABLE     - 'I'  # IMMUNE 
    */
    'cstIPI': CustomAgast.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * when the company is Real Profit inform if this item is cumulative or no cumulative by default
    */
    'pisCofinsTaxReporting': CustomAgast.PisCofinsTaxReportingEnum;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruablePISTaxation': CustomAgast.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruableCOFINSTaxation': CustomAgast.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
    */
    'accruableCSLLTaxation': CustomAgast.AccruableCSLLTaxationEnum;
    'csllExemptLegalReason': string;
    'csllExemptLegalReasonCode': string;
    'withholding': AgastWithholding;
    /**
    * for service items with City Jurisdiction, inform where the ISS tax is due
    */
    'issDueatDestination': boolean;
    /**
    * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
    */
    'pisCofinsCreditNotAllowed': boolean;
    /**
    * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
    */
    'issTaxation': CustomAgast.IssTaxationEnum;
    /**
    * This is an array of tax object related to an agast.
    */
    'federalTaxRate': Array<TaxTypeRate>;
    'specialProductClass': CustomAgast.SpecialProductClassEnum;
    /**
    * One per State
    */
    'icmsConf': Array<AgastIcmsConf>;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomAgast {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        N = <any> 'N',
        I = <any> 'I'
    }
    export enum PisCofinsTaxReportingEnum {
        Cumulative = <any> 'cumulative',
        NoCumulative = <any> 'noCumulative'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum IssTaxationEnum {
        T = <any> 'T',
        E = <any> 'E',
        F = <any> 'F',
        A = <any> 'A',
        L = <any> 'L',
        I = <any> 'I'
    }
    export enum SpecialProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRIFICANT = <any> 'FUEL AND LUBRIFICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUME = <any> 'PERFUME',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class CustomIcmsConfByState {
    /**
    * Identify the IcmsConfState in namespace
    */
    'code': string;
    'state': StateEnum;
    /**
    * name for this configuration
    */
    'name': string;
    /**
    * date when this configuration values starts
    */
    'startDate': Date;
    /**
    * date when this configuration values expire
    */
    'expirationDate': Date;
    /**
    * set this configuration to Inactive
    */
    'inactive': boolean;
    /**
    * inform that the item linked to this configuration is subject to ICMS ST on this state
    */
    'subjectToST': boolean;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': CustomIcmsConfByState.IcmsCSTEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': CustomIcmsConfByState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS for transactions inside state
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    /**
    * Fundo de Combate à pobreza / Fund Against Poverty
    */
    'fcpRate': number;
    'icmsSTConf': IcmsConfByStateIcmsSTConf;
    /**
    * the map key is state code
    */
    'icmsInterStateConf': Array<IcmsConfInterState>;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomIcmsConfByState {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class CustomProcessScenario {
    /**
    * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': CustomProcessScenario.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': CustomProcessScenario.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': CustomProcessScenario.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    /**
    * Process name to Identify this configuration
    */
    'name': string;
    'type': CustomProcessScenario.TypeEnum;
    /**
    * inform if the transaction is an operation to internalizing (receive) item or value
    */
    'wayType': CustomProcessScenario.WayTypeEnum;
    'goal': CustomProcessScenario.GoalEnum;
    /**
    * inform that the configuration process overwrites the cfop configuration.
    */
    'overWriteCFOP': boolean;
    'cfops': Array<CfopConf>;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomProcessScenario {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum TypeEnum {
        SALES = <any> 'SALES',
        PURCHASE = <any> 'PURCHASE',
        SALESRETURN = <any> 'SALES_RETURN',
        PURCHASERETURN = <any> 'PURCHASE_RETURN',
        TRANSFERRETURN = <any> 'TRANSFER_RETURN',
        SHIPPING = <any> 'SHIPPING',
        SHIPPINGRETURN = <any> 'SHIPPING_RETURN',
        TRANSFER = <any> 'TRANSFER',
        RECEIPTAJUSTE = <any> 'RECEIPT_AJUSTE',
        TRANSFERAJUSTE = <any> 'TRANSFER_AJUSTE'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum GoalEnum {
        Normal = <any> 'Normal',
        Complementary = <any> 'Complementary',
        Voided = <any> 'Voided',
        Replacement = <any> 'Replacement',
        Return = <any> 'Return',
        Adjustment = <any> 'Adjustment'
    }
}
export class CustomTaxTypeRate {
    'taxType': TaxType;
    /**
    * Tax can be calculated by rate or by quantity
    */
    'taxModel': CustomTaxTypeRate.TaxModelEnum;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'rate': number;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'srvAmount': number;
    'quantityUnidBase': string;
    'specializationType': CustomTaxTypeRate.SpecializationTypeEnum;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomTaxTypeRate {
    export enum TaxModelEnum {
        Rate = <any> 'rate',
        Srf = <any> 'srf'
    }
    export enum SpecializationTypeEnum {
        Basic = <any> 'basic',
        Monophase = <any> 'monophase',
        TaxSubstitution = <any> 'taxSubstitution'
    }
}
/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. These locations may be overridden within each line item. The key for each location in the dictionary is the location 'purpose'. Valid locations purposes are 'ShipFrom', 'ShipTo', 'POS', 'POM', 'POO', 'BillingLocation', 'CallPlaced', 'CallReceived', 'ServiceRendered', 'POA' and 'FirstUse'. There can only be one location of a given purpose in the dictionary.
*/
export class DefaultLocations {
    'entity': EntityLocation;
    'company': EntityLocation;
    'transporter': EntityLocation;
    'deliveryLocation': EntityLocation;
    'pickupLocation': EntityLocation;
}

export class DetailsCalculatedTax {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': DetailsCalculatedTax.JurisdictionTypeEnum;
    /**
    * Tax identificator
    */
    'taxType': DetailsCalculatedTax.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule
    */
    'taxRuleType': DetailsCalculatedTax.TaxRuleTypeEnum;
}

export namespace DetailsCalculatedTax {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof',
        AproxtribState = <any> 'aproxtribState',
        AproxtribFed = <any> 'aproxtribFed',
        Aproxtrib = <any> 'aproxtrib'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class DetailsCalculatedTaxItem {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': DetailsCalculatedTaxItem.JurisdictionTypeEnum;
    /**
    * Tax identificator
    */
    'taxType': DetailsCalculatedTaxItem.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule
    */
    'taxRuleType': DetailsCalculatedTaxItem.TaxRuleTypeEnum;
    'source': number;
    'cstB': string;
    'modBC': string;
    'cst': string;
}

export namespace DetailsCalculatedTaxItem {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof',
        AproxtribState = <any> 'aproxtribState',
        AproxtribFed = <any> 'aproxtribFed',
        Aproxtrib = <any> 'aproxtrib'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class Entity {
    /**
    * Entity name, official name (Razão Social)
    */
    'name': string;
    /**
    * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
    */
    'role': Entity.RoleEnum;
    'type': EntityType;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'federalTaxId': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': Entity.TaxRegimeEnum;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * Companies subject to follow same rules of Government entities (Instrução Normativa: SRF1234)
    */
    'subjectToSRF1234': boolean;
}

export namespace Entity {
    export enum RoleEnum {
        Transporter = <any> 'transporter',
        Sender = <any> 'sender',
        Dispatcher = <any> 'dispatcher',
        Receiver = <any> 'receiver',
        Addressee = <any> 'addressee',
        Other = <any> 'other'
    }
    export enum TaxRegimeEnum {
        RealProfit = <any> 'realProfit',
        EstimatedProfit = <any> 'estimatedProfit',
        Simplified = <any> 'simplified',
        SimplifiedOverGrossthreshold = <any> 'simplifiedOverGrossthreshold',
        SimplifiedEntrepreneur = <any> 'simplifiedEntrepreneur',
        NotApplicable = <any> 'notApplicable',
        Individual = <any> 'individual'
    }
}
export class EntityForGoods {
    /**
    * Entity name, official name (Razão Social)
    */
    'name': string;
    /**
    * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
    */
    'role': EntityForGoods.RoleEnum;
    'type': EntityType;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'federalTaxId': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': EntityForGoods.TaxRegimeEnum;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * Companies subject to follow same rules of Government entities (Instrução Normativa: SRF1234)
    */
    'subjectToSRF1234': boolean;
    /**
    * Inform if the entity is ICMS tax payer.
    */
    'icmsTaxPayer': boolean;
}

export namespace EntityForGoods {
    export enum RoleEnum {
        Transporter = <any> 'transporter',
        Sender = <any> 'sender',
        Dispatcher = <any> 'dispatcher',
        Receiver = <any> 'receiver',
        Addressee = <any> 'addressee',
        Other = <any> 'other'
    }
    export enum TaxRegimeEnum {
        RealProfit = <any> 'realProfit',
        EstimatedProfit = <any> 'estimatedProfit',
        Simplified = <any> 'simplified',
        SimplifiedOverGrossthreshold = <any> 'simplifiedOverGrossthreshold',
        SimplifiedEntrepreneur = <any> 'simplifiedEntrepreneur',
        NotApplicable = <any> 'notApplicable',
        Individual = <any> 'individual'
    }
}
export class EntityInformerForGoods {
    'type': EntityType;
    'taxRegime': FederalTaxRegime;
    'federalTaxRegime': EntityInformerForGoodsFederalTaxRegime;
    'cityCode': string;
    'address': Address;
    'details': any;
    'icmsTaxPayer': boolean;
}

export class EntityInformerForGoodsFederalTaxRegime {
    'code': string;
    'name': string;
    'abbr': string;
}

export class EntityLocation {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

/**
* Entity Type (business, individual, federal government, state government, city government foreign)
*/
export class EntityType {
}

/**
* Export information
*/
export class ExportInfo {
    /**
    * shipping state
    */
    'shippingState': StateEnum;
    /**
    * shipping place
    */
    'place': string;
    /**
    * description of shipping place
    */
    'placeDescription': string;
}

/**
* - Federal tax regime - realProfit - REAL PROFIT LUCRO REAL - estimatedProfit - ESTIMATED PROFIT / LUCRO PRESUMIDO - simplified - SIMPLIFIED - OPTANTE TO SIMPLES - simplifiedOverGrossthreshold - OPTANTE DO SIMPLES COM LIMITE DE GROSS REVENUE - simplifiedEntrepreneur - SIMPLIFIED ENTREPRENEUR / MEI MICRO EMPREENDEDOR INDIVIDUAL  - notApplicable - Not Applicable 1  - individual - INDIVIDUAL / INDIVIDUO 
*/
export class FederalTaxRegime {
}

export class Fuel {
    'prodANPCode': string;
    /**
    * percentage of natural gas (GLP)
    */
    'perMixGN': number;
    'authorizationCodeCODIF': string;
    /**
    * This decimal 12 integers and 0 to 4 decimals Quantidade de combustível faturada à temperatura ambiente. Informar quando a quantidade faturada informada no campo qCom (I10) tiver sido ajustada para uma temperatura diferente da ambiente. 
    */
    'quantityOnRoomTemperature': number;
    /**
    * state where fuel was used
    */
    'stateCodeOfUndUser': StateEnum;
    'cide': FuelCide;
    'pumpNumber': FuelPumpNumber;
}

export class FuelCide {
    /**
    * percentage of natural gas (GLP), this decimal 12 integers and 0 to 4 decimals
    */
    'baseCalcCIDE': number;
    /**
    * percentage of natural gas (GLP), this decimal 11 integers and 0 to 4 decimals - R$
    */
    'rateCIDE': number;
    /**
    * percentage of natural gas (GLP), this decimal 13 integers and 2 decimals - R$
    */
    'valueCIDE': number;
}

export class FuelPumpNumber {
    /**
    * Identification number of nozzle used in the dispensing process.   Numero de identificação do Bico utilizado no abastecimento 
    */
    'nozzleNumberFuelSupply': string;
    /**
    * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
    */
    'fuelPumpNumber': string;
    /**
    * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
    */
    'fuelTankNumber': string;
    /**
    * Valor do Encerrante no ínicio do abastecimento.  Reading of auto-counter (encerrante) at the start of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
    */
    'startValueOfPumpNumber': number;
    /**
    * Valor do Encerrante no final do abastecimento.  Reading of auto-counter (encerrante) at the end of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
    */
    'endValueOfPumpNumber': number;
}

export class HeaderBaseInfo {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': HeaderBaseInfo.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': HeaderBaseInfo.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
}

export namespace HeaderBaseInfo {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
}
export class HeaderForGoods {
    'messageType': HeaderForGoods.MessageTypeEnum;
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    'participants': HeaderForGoodsParticipants;
    /**
    * This is the public NF id. With this number is possible get invoice information directly from government.
    */
    'nfAccessKey': string;
    /**
    * qr code printed on DANFE;
    */
    'nfceQrCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated.
    */
    'transactionType': HeaderForGoods.TransactionTypeEnum;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - '01' # Nota Fiscal 1/1A - '1B' # Nota Fiscal Avulsa - '02' # Nota Fiscal de Venda a-Consumidor - '2D' # Cupom Fiscal - '2E' # Cupom Fiscal-Bilhete de Passagem - '04' # Nota Fiscal de Produtor - '06' # Nota Fiscal/Conta de Energia Elétrica - '07' # Nota Fiscal de Serviço de Transporte - '08' # Conhecimento de Transporte Rodoviário de-Cargas - '8B' # Conhecimento de Transporte de-Cargas Avulso - '09' # Conhecimento de Transporte Aquaviário de-Cargas - '10' # Conhecimento Aéreo - '11' # Conhecimento de Transporte Ferroviário de-Cargas - '13' # Bilhete de Passagem Rodoviário - '14' # Bilhete de Passagem Aquaviário - '15' # Bilhete de Passagem e-Nota de-Bagagem - '16' # Bilhete de Passagem Ferroviário - '18' # Resumo de Movimento Diário - '21' # Nota Fiscal de Serviço de-Comunicação - '22' # Nota Fiscal de Serviço de Telecomunicação - '26' # Conhecimento de Transporte Multimodal de-Cargas - '27' # Nota Fiscal De Transporte Ferroviário De-Carga - '28' # Nota Fiscal/Conta de Fornecimento de Gás-Canalizado - '29' # Nota Fiscal/Conta de Fornecimento de Água-Canalizada - '55' # Nota Fiscal Eletrônica (NF-e) - '57' # Conhecimento de Transporte Eletrônico (CT-e) - '59' # Cupom Fiscal Eletrônico (CF-e-SAT) - '60' # Cupom Fiscal Eletrônico (CF-e-ECF) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
    */
    'transactionModel': HeaderForGoods.TransactionModelEnum;
    /**
    * Natureza da Opreração - 'Describe kind of this transaction, summary
    */
    'transactionClass': string;
    'eDocCreatorType': HeaderForGoods.EDocCreatorTypeEnum;
    /**
    * This Flag is used only when eDocCreatorType is other and the return show Taxes using eDocCreator perspective or self perspective.
    */
    'eDocCreatorPerspective': boolean;
    /**
    * This string is a code maintained by the client application and recorded in CUP to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
    */
    'entityCode': string;
    /**
    * currency code
    */
    'currency': HeaderForGoods.CurrencyEnum;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is the transaction date in ISO 8601 format, create transaction date
    */
    'transactionDate': string;
    /**
    * This string is the transaction date in ISO 8601 format, when products were shipped, can be empty or absent
    */
    'shippingDate': string;
    'additionalInfo': AdditionalInformation;
    /**
    * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; - '3' # DANFe Simplified; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
    */
    'tpImp': HeaderForGoods.TpImpEnum;
    /**
    * This indicator inform transaction target place, when is AUTOMATIC the company address and entity address are analyzed to identify type of transaction target place 1- same state; 2 - interstate; 3-with exterior. Exist some cases where is necessary force this situation like when buyer from another state buy something in loco, the address are from different states, but transaction no.  Identificador de Local de destino da operação, na opção AUTOMATIC endereços da Companhia e da entidade destino são analisados para saber se é uma operação dentro do mesmo estado, interestadual ou com o exterior. Há situações onde é necessário forçar este indicador como por exemplo  Quando uma pessoa com endereço em outro estado, compra uma mercadoria de forma presencial, é uma operação interna apesar dos endereços dos envolvidos estarem em estados distintos. - 0 # AUTOMATIC - DEFAULT - 1 # Interna; - 2 # Interestadual; - 3 # Exterior) 
    */
    'idDest': number;
    /**
    * Presence indicator - '0' # Not applicable - '1' # Presential; - '2' # Remote, internet; - '3' # Remote, phone; - '4' # NFC-e home delivery; - '9' # Remote, others 
    */
    'indPres': HeaderForGoods.IndPresEnum;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal)
    */
    'invoiceNumber': number;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
    */
    'invoiceSerial': number;
    'defaultLocations': DefaultLocations;
    /**
    * Shipment
    */
    'transport': Transport;
    /**
    * Transactions or other invoices referenced
    */
    'nfRef': Array<NRef>;
    'payment': Payment;
    'purchaseInfo': PurchaseInfo;
    'export': ExportInfo;
}

export namespace HeaderForGoods {
    export enum MessageTypeEnum {
        Goods = <any> 'goods'
    }
    export enum TransactionTypeEnum {
        Sales = <any> 'Sales',
        Purchase = <any> 'Purchase',
        SalesReturn = <any> 'SalesReturn',
        PurchaseReturn = <any> 'PurchaseReturn',
        TransferReturn = <any> 'TransferReturn',
        Shipping = <any> 'Shipping',
        ShippingReturn = <any> 'ShippingReturn',
        Transfer = <any> 'Transfer',
        ReceiptAdjustment = <any> 'ReceiptAdjustment',
        TransferAdjustment = <any> 'TransferAdjustment'
    }
    export enum TransactionModelEnum {
        _01 = <any> '01',
        _1B = <any> '1B',
        _02 = <any> '02',
        _2D = <any> '2D',
        _2E = <any> '2E',
        _04 = <any> '04',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _8B = <any> '8B',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _18 = <any> '18',
        _21 = <any> '21',
        _22 = <any> '22',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _55 = <any> '55',
        _57 = <any> '57',
        _59 = <any> '59',
        _60 = <any> '60',
        _65 = <any> '65'
    }
    export enum EDocCreatorTypeEnum {
        Self = <any> 'self',
        Other = <any> 'other'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
    export enum TpImpEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5'
    }
    export enum IndPresEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _9 = <any> '9'
    }
}
/**
* List of transaction participants, Seller, Buyer, Carrier
*/
export class HeaderForGoodsParticipants {
    'entity': EntityForGoods;
    'transporter': EntityForGoods;
}

export class IbptConf {
    /**
    * IBPT Code
    */
    'code': string;
    'description': string;
    'list': Array<IpbtConfItem>;
}

export class IcmsConfByState {
    /**
    * Identify the IcmsConfState in namespace
    */
    'code': string;
    'state': StateEnum;
    /**
    * name for this configuration
    */
    'name': string;
    /**
    * date when this configuration values starts
    */
    'startDate': Date;
    /**
    * date when this configuration values expire
    */
    'expirationDate': Date;
    /**
    * set this configuration to Inactive
    */
    'inactive': boolean;
    /**
    * inform that the item linked to this configuration is subject to ICMS ST on this state
    */
    'subjectToST': boolean;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsConfByState.IcmsCSTEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfByState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS for transactions inside state
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    /**
    * Fundo de Combate à pobreza / Fund Against Poverty
    */
    'fcpRate': number;
    'icmsSTConf': IcmsConfByStateIcmsSTConf;
    /**
    * the map key is state code
    */
    'icmsInterStateConf': Array<IcmsConfInterState>;
}

export namespace IcmsConfByState {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class IcmsConfByStateIcmsSTConf {
    /**
    * inform that substituted is tax regime Simplified the operation MVA will be reduced
    */
    'hasReductionOfMVAForSimples': boolean;
    /**
    * mva reduction when substituted is tax regime Simplified.
    */
    'reductionOfMVAForSimples': number;
    /**
    * how this ICMS-ST will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfByStateIcmsSTConf.CalcModeEnum;
    /**
    * ICMS-ST mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * ICMS rate - Redução da BC ICMS ST (%)
    */
    'icmsStBaseDiscount': number;
    /**
    * SRP or MSRP amount base for this ICMS-ST configuration
    */
    'srp': number;
    /**
    * unit used to srv amount value
    */
    'srpUnit': string;
}

export namespace IcmsConfByStateIcmsSTConf {
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MSRP = <any> 'MSRP'
    }
}
export class IcmsConfInterState {
    'state': StateEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfInterState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS when operation interstate
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * FCP rate (Fundo de Combate à Probreza / Fund Against Poverty
    */
    'fcpRate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS MVA rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    'icmsSTConf': IcmsConfInterStateIcmsSTConf;
}

export namespace IcmsConfInterState {
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class IcmsConfInterStateIcmsSTConf {
    'protocolType': IcmsConfInterStateIcmsSTConf.ProtocolTypeEnum;
    /**
    * inform that substituted is tax regime Simplified the operation MVA will be reduced
    */
    'hasReductionOfMVAForSimples': boolean;
    /**
    * MVA reduction when substituted is tax regime Simplified.
    */
    'reductionOfMVAForSimples': number;
    /**
    * how this ICMS-ST will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfInterStateIcmsSTConf.CalcModeEnum;
    /**
    * ICMS rate - Redução da BC ICMS ST (%)
    */
    'icmsStBaseDiscount': number;
    /**
    * ICMS-ST MVA rate to define calc base
    */
    'mvaRate': number;
    /**
    * SRP or MSRP amount base for this ICMS-ST configuration
    */
    'srp': number;
    /**
    * unit used to SRP amount value
    */
    'srpUnit': string;
}

export namespace IcmsConfInterStateIcmsSTConf {
    export enum ProtocolTypeEnum {
        COVENANT = <any> 'COVENANT',
        PROTOCOL = <any> 'PROTOCOL',
        NOTHING = <any> 'NOTHING'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MSRP = <any> 'MSRP'
    }
}
export class IcmsTaxConf {
    'state': StateEnum;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsTaxConf.IcmsCSTEnum;
    /**
    * Message to add to NF when this configuration is used
    */
    'messageCode': string;
    /**
    * the mapping key is state code / A chave do mapeamento é o código do Estado.
    */
    'relationShip': Array<IcmsTaxConfBase>;
}

export namespace IcmsTaxConf {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
}
export class IcmsTaxConfBase {
    'state': StateEnum;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsTaxConfBase.IcmsCSTEnum;
    /**
    * Message to add to NF when this configuration is used
    */
    'messageCode': string;
}

export namespace IcmsTaxConfBase {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
}
/**
* Internal Type used to references all taxes.
*/
export class InformerForGoods {
    'header': HeaderForGoods;
    'line': LineForGoods;
    'company': EntityInformerForGoods;
    'entity': EntityInformerForGoods;
    'emitter': EntityInformerForGoods;
    'receiver': EntityInformerForGoods;
    'transporter': EntityInformerForGoods;
    'csts': InformerForGoodsCsts;
    'amount': number;
    'discount': number;
    'quantity': number;
    'unitPrice': number;
    'freightAmount': number;
    'insuranceAmount': number;
    'otherCostAmount': number;
    'exemptValue': number;
}

export class InformerForGoodsCsts {
    /**
    * CST-B
    */
    'icms': string;
    /**
    * CST-IPI
    */
    'ipi': string;
    /**
    * CST PIS/COFINS
    */
    'pisCofins': string;
}

export class InlineResponse200 {
    'token': string;
    'expired': Date;
}

export class InlineResponse2001 {
    /**
    * Item description
    */
    'description': string;
    /**
    * uuid
    */
    'id': string;
    /**
    * Custom item code
    */
    'code': string;
}

export class InlineResponse2002 {
    'companyId': string;
}

export class InlineResponse2003 {
    'contingency': boolean;
    'startDate': Date;
    'finishDate': Date;
}

export class InlineResponse2004 {
    /**
    * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação                 
    */
    'environment': InlineResponse2004.EnvironmentEnum;
}

export namespace InlineResponse2004 {
    export enum EnvironmentEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
}
export class InlineResponse201 {
    'id': number;
}

export class InstallmentComplete {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment Due Date
    */
    'date': Date;
    /**
    * Intallment amount, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
    /**
    * net amount due for this installment, grossValue - ∑ (withhold amounts)
    */
    'netValue': number;
    /**
    * Inform if this payment is subject to Pis, Cofins or CSLL
    */
    'withholdingMode': WithholdingMode;
    /**
    * calculated PIS-RF tax for this payment
    */
    'withholdingPIS': number;
    /**
    * calculated COFINS-RF tax for this payment
    */
    'withholdingCOFINS': number;
    /**
    * calculated CSLL-RF tax for this payment
    */
    'withholdingCSLL': number;
}

export class IpbtConfItem {
    'state': StateEnum;
    'federalTax': number;
    'importTax': number;
    'stateTax': number;
    'cityTax': number;
    'source': string;
}

export class IssConfByCity {
    /**
    * City Code (IBGE)
    */
    'cityCode': number;
    'name': string;
    'state': StateEnum;
    'issWhDestOtherCities': boolean;
    'issWhDestSameCity': boolean;
    'issWhOriginUnregSeller': boolean;
    'serviceList': Array<IssConfServiceList>;
}

export class IssConfServiceList {
    'agast': string;
    'cityServiceCode': string;
    'taxRate': IssConfServiceListTaxRate;
}

export class IssConfServiceListTaxRate {
    'iSS': ServiceItemTaxRate;
    'iSSRF': ServiceItemTaxRate;
    'iSSE': ServiceItemTaxRate;
    'iSSI': ServiceItemTaxRate;
    'ibpt': IssConfServiceListTaxRateIbpt;
}

export class IssConfServiceListTaxRateIbpt {
    'nationalFedTax': number;
    'cityTax': number;
}

export class ItemCpom {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * IBGE city code
    */
    'cityCode': string;
    /**
    * ERP Code
    */
    'itemCode': string;
    /**
    * Code in City
    */
    'code': string;
}

export class ItemGoods {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * ERP Code
    */
    'code': string;
    /**
    * Agast Code
    */
    'agast': string;
    /**
    * Item Description
    */
    'description': string;
    /**
    * Seal Code for ipi tax control (código do selo para controle de IPI)
    */
    'sealCode': string;
    /**
    * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
    */
    'nFCI': string;
    /**
    * this field inform that this merchandise or product is ICMS Substitute Must be used when the item is for resale and the company will assume the role of ICMS Substitute (wholesaler, retailer, distributor). Example: when Importing some product the company does not pay IcmsSt at the time of customs clearance but when selling sale the item. Deverá ser utilizado quando a empresa que irá vender a mercadoria sujeita ao ICMS ST for o SUBSTITUTO TRIBUTÁRIO (Distribuidor, atacadista e varejista), como por exemplo das mercadorias IMPORTADAS, neste sentido, a empresa não irá pagar o ICMS ST no desembaraço aduaneiro e irá recolher quando for vender as mesmas. 
    */
    'isIcmsStSubstitute': boolean;
    /**
    * - '0' # National goods - except those treated in codes 3,4, 5 and 8 - '1' # Foreign goods - Imported directly by seller, except those in code 6 - '2' # Foreign goods - Acquired in the internal market (inside Brazil), except those in code 7 - '3' # National goods - Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # National goods - Merchandise or goods with imported content above 70% 
    */
    'source': ItemGoods.SourceEnum;
    'productType': ItemGoods.ProductTypeEnum;
    /**
    * Item is merchandise but will be considered product
    */
    'manufacturerEquivalent': boolean;
    /**
    * Inform that this item will have rights to aprropriate IPI credit
    */
    'appropriateIPIcreditWhenInGoing': boolean;
    /**
    * Subject to appropriate PIS/COFINS credit, when NO CUMULATIVE
    */
    'usuallyAppropriatePISCOFINSCredit': boolean;
    /**
    * The credit PIS/COFINS is subject to purchase form companies, but exist some exceptions, when the credit will be a estimated amount
    */
    'isPisCofinsEstimatedCredit': boolean;
    /**
    * - '01' # Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '02' # Exclusivamente a Receita Não Tributada no Mercado Interno - '03' # Exclusivamente a Receita de Exportação - '04' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '05' # Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '06' # Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '07' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação 
    */
    'piscofinsRevenueType': ItemGoods.PiscofinsRevenueTypeEnum;
    /**
    * Discount allowed on icms base when PIS/COFINS are Monophase
    */
    'icmsBaseDiscountForMonoPhaseSocialContr': number;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    /**
    * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
    */
    'nve': string;
    'salesUnit': string;
    /**
    * factor to convert sales quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIPIfactor': number;
    /**
    * factor to convert sales quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIcmsfactor': number;
    /**
    * factor to convert sales quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIcmsStfactor': number;
    /**
    * factor to convert sales quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitPisCofinsfactor': number;
    'purchaseUnit': string;
    /**
    * factor to convert purchase quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIPIfactor': number;
    /**
    * factor to convert purchase quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIcmsfactor': number;
    /**
    * factor to convert purchase quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIcmsStfactor': number;
    /**
    * factor to convert purchase quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitPisCofinsfactor': number;
    /**
    * When the product is new, and will be retail, firt time that it exit it is subject to IPI
    */
    'firstUse': boolean;
}

export namespace ItemGoods {
    export enum SourceEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8'
    }
    export enum ProductTypeEnum {
        FORPRODUCT = <any> 'FOR PRODUCT',
        FORMERCHANDISE = <any> 'FOR MERCHANDISE',
        NORESTRICTION = <any> 'NO RESTRICTION',
        SERVICE = <any> 'SERVICE',
        FEEDSTOCK = <any> 'FEEDSTOCK',
        FIXEDASSETS = <any> 'FIXED ASSETS'
    }
    export enum PiscofinsRevenueTypeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07'
    }
}
export class ItemSimple {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * ERP Code
    */
    'code': string;
    /**
    * Agast Code
    */
    'agast': string;
    /**
    * Item Description
    */
    'description': string;
}

/**
* Legal Reason (Fundamentação Legal): - 'name' - 'description' - 'scope' 
*/
export class LegalReason {
    /**
    * Internal ID
    */
    'id': string;
    /**
    * Message scope. May be one of these. general - This message is not linked to any entity (agast/process/cfop) and will be applied to any item in a transacition. (Esta mensagem tem escopo geral, nao está relacionadas diretamente qualquer objeto.); linkedTo - This message is linked to an entity, and its processing will only occur when the context involves it. (Esta mensagens estão relacionadas diretamente a algum objeto como um AGAST por exemplo, um Processo ou uma CFOP.); 
    */
    'scope': LegalReason.ScopeEnum;
    /**
    * Set this message as no longer valid
    */
    'disable': boolean;
    /**
    * Legal reason textual description;
    */
    'description': string;
    /**
    * Short name to this message
    */
    'name': string;
    /**
    * this field inform the official code number
    */
    'legalCode': string;
    /**
    * Optional. Show this message when used in Invoice (NFe, NFCe, others...). Where to show this.
    */
    'showInInvoice': LegalReason.ShowInInvoiceEnum;
    /**
    * Referenced Process
    */
    'referencedProcesses': Array<LegalReasonReferencedProcesses>;
    'taxScope': LegalReasonTaxScope;
}

export namespace LegalReason {
    export enum ScopeEnum {
        General = <any> 'general',
        LinkedTo = <any> 'linkedTo'
    }
    export enum ShowInInvoiceEnum {
        ComplementaryInfoMessage = <any> 'complementaryInfoMessage',
        FiscalInfoMessage = <any> 'fiscalInfoMessage',
        ItemInfoMessage = <any> 'itemInfoMessage'
    }
}
export class LegalReasonReferencedProcesses {
    /**
    * Process Identifier (NFe <nProc> tag)
    */
    'nProc': string;
    /**
    * Process Origin (NFe <indProc> tag) - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
    */
    'indProc': LegalReasonReferencedProcesses.IndProcEnum;
}

export namespace LegalReasonReferencedProcesses {
    export enum IndProcEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _9 = <any> '9'
    }
}
/**
* Filter this message application to specified tax cases. - taxtype - jurisdictionType 
*/
export class LegalReasonTaxScope {
    /**
    * This is the Tax Type to apply legal messages. - 'NONE' - 'INSS' - 'IRRF' - 'IRPJ' - 'PIS' - 'COFINS' - 'CSLL' - 'IPI' - 'ICMS' - 'II' - 'IOF' - 'ISS' - 'APROXTOTALTAX' 
    */
    'taxType': LegalReasonTaxScope.TaxTypeEnum;
    /**
    * These are the specific tax types to which a message may be applied - 'icms' - 'icmsSt' - 'icmsStSd' - 'icmsPartOwn' - 'icmsPartDest' - 'icmsDifaFCP' - 'icmsDifaDest' - 'icmsDifaRemet' - 'icmsRf' - 'icmsDeson' - 'icmsCredsn' - 'pis' - 'pisSt' - 'cofins' - 'cofinsSt' - 'ipi' - 'ipiReturned' - 'ii' - 'iof' 
    */
    'specializedTaxType': LegalReasonTaxScope.SpecializedTaxTypeEnum;
    /**
    * Types of jurisdiction - 'NONE' - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': LegalReasonTaxScope.JurisdictionTypeEnum;
    /**
    * Code to identify the Jurisdiction
    */
    'jurisdictionIbgeCode': string;
}

export namespace LegalReasonTaxScope {
    export enum TaxTypeEnum {
        NONE = <any> 'NONE',
        INSS = <any> 'INSS',
        IRRF = <any> 'IRRF',
        IRPJ = <any> 'IRPJ',
        PIS = <any> 'PIS',
        COFINS = <any> 'COFINS',
        CSLL = <any> 'CSLL',
        IPI = <any> 'IPI',
        ICMS = <any> 'ICMS',
        II = <any> 'II',
        IOF = <any> 'IOF',
        ISS = <any> 'ISS',
        APROXTOTALTAX = <any> 'APROXTOTALTAX'
    }
    export enum SpecializedTaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof'
    }
    export enum JurisdictionTypeEnum {
        NONE = <any> 'NONE',
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class LineForGoods {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
    */
    'returnedPercentageAmount': number;
    /**
    * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
    */
    'lineUnitPrice': number;
    /**
    * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Discount conditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineTaxedDiscount': number;
    /**
    * discount unconditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineUntaxedDiscount': number;
    /**
    * This is a enumeration folowing table
    */
    'useType': LineForGoods.UseTypeEnum;
    /**
    * Reference to process configurantion of this transaction, See ProcessScenario definition
    */
    'processScenario': string;
    /**
    * Fiscal Operation Code of transport service
    */
    'cfop': number;
    /**
    * return if this transaction has stock impact for this process or CFOP
    */
    'hasStockImpact': boolean;
    /**
    * return if this transaction has finantial impact for this process or CFOP
    */
    'hasFinantialImpact': boolean;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'freightAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'insuranceAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'otherCostAmount': number;
    /**
    * The item value will compose the invoice total value.
    */
    'indTotType': boolean;
    /**
    * order number, information used for B2B control process
    */
    'orderNumber': string;
    /**
    * number of the item from order number, information used for B2B control process
    */
    'orderItemNumber': string;
    /**
    * Gloal Unique identifier (Importation form)
    */
    'fciNumber': string;
    /**
    * RECOPI number
    */
    'recopiNumber': string;
    /**
    * additional information about product (referenced standard, complementary info, etc)
    */
    'infAdProd': string;
    'vehicle': Vehicle;
    'medicine': Medicine;
    'weapon': Weapon;
    'fuel': Fuel;
    /**
    * Inform that for this item the Entity referenced is ICMS Substitute
    */
    'entityIsIcmsSubstitute': boolean;
    /**
    * Inform that this item has ICMS withheld for transport value service.
    */
    'isTransportIcmsWithheld': boolean;
    'icmsTaxRelief': LineForGoodsIcmsTaxRelief;
    /**
    * Exportation detail
    */
    'export': Array<LineForGoodsExport>;
    /**
    * Import declaration
    */
    'di': Array<LineForGoodsDi>;
    'calculatedTax': LineForGoodsCalculatedTax;
}

export namespace LineForGoods {
    export enum UseTypeEnum {
        UseOrConsumption = <any> 'use or consumption',
        Resale = <any> 'resale',
        AgriculturalProduction = <any> 'agricultural production',
        Production = <any> 'production',
        UseOrConsumptionOnBusinessEstablishment = <any> 'use or consumption on business establishment',
        UseOrConsumptionOnTransporterServiceEstablishment = <any> 'use or consumption on transporter service establishment',
        UseOrConsumptionOnCommunicationServiceEstablishment = <any> 'use or consumption on communication service establishment',
        UseOrConsumptionOnDemandByContract = <any> 'use or consumption on demand by contract',
        UseOrConsumptionOnEnergySupplierEstablishment = <any> 'use or consumption on energy supplier establishment',
        UseOrConsumptionOfFuelTransactionTypeExportation = <any> 'use or consumption of fuel transaction type exportation',
        FixedAssets = <any> 'fixed assets',
        ResaleExport = <any> 'resale export',
        ResaleIcmsExempt = <any> 'resale icms exempt',
        ResaleBuyerUnderTheSameIcmsStTaxRule = <any> 'resale buyer under the same icmsSt tax rule',
        TransportOfGoodsThatDontNeedInvoiceNf = <any> 'transport of goods that don't need invoice (nf)'
    }
}
export class LineForGoodsAdi {
    /**
    * aditional sequence number (1 to 100)
    */
    'addNumber': number;
    /**
    * sequential item number for this adi, sequence number (1 to 999)
    */
    'sequentialNumber': number;
    /**
    * Manufatorer erp internal code
    */
    'manufacturerCode': string;
    /**
    * This decimal 13 integers and 2 decimals, aditional adi discount
    */
    'adiDiscount': number;
    /**
    * Drawback number
    */
    'drawbackNumber': string;
}

export class LineForGoodsCalculatedTax {
    'taxByType': LineForGoodsCalculatedTaxTaxByType;
    'tax': number;
    'details': Array<DetailsCalculatedTaxItem>;
}

export class LineForGoodsCalculatedTaxTaxByType {
    'icms': TaxByTypeTax;
    'icmsSt': TaxByTypeTax;
    'icmsStSd': TaxByTypeTax;
    'icmsPartOwn': TaxByTypeTax;
    'icmsPartDest': TaxByTypeTax;
    'icmsDifaFCP': TaxByTypeTax;
    'icmsDifaDest': TaxByTypeTax;
    'icmsDifaRemet': TaxByTypeTax;
    'icmsRf': TaxByTypeTax;
    'icmsDeson': TaxByTypeTax;
    'icmsCredsn': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'pisSt': TaxByTypeTax;
    'cofins': TaxByTypeTax;
    'cofinsSt': TaxByTypeTax;
    'ipi': TaxByTypeTax;
    'ipiReturned': TaxByTypeTax;
    'ii': TaxByTypeTax;
    'iof': TaxByTypeTax;
    'aproxtribState': TaxByTypeTax;
    'aproxtribFed': TaxByTypeTax;
}

export class LineForGoodsDi {
    /**
    * customs value, valor aduaneiro (II Block of NFe)
    */
    'customsValue': number;
    /**
    * Import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
    */
    'diNumber': string;
    /**
    * Register date of import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
    */
    'registerDateDI': Date;
    /**
    * Clerance Site Local do desembaraço aduaneiro 
    */
    'clearanceSite': string;
    /**
    * Clerance Site State Estado onde ocorrreu o desembaraço aduaneiro 
    */
    'clearanceState': StateEnum;
    /**
    * Clerance date
    */
    'clearanceDate': Date;
    /**
    * - '1' # Maritima - '2' # Fluvial - '3' # Lacustre - '4' # Aerea - '5' # Postal - '6' # Ferroviaria - '7' # Rodoviaria - '8' # Conduto - '9' # Meios Proprios - '10' # Entrada/Saida Ficta 
    */
    'transportDIType': LineForGoodsDi.TransportDITypeEnum;
    /**
    * Aditional amount to freight to renew merchant marine, This decimal 13 integers and 2 decimals [Valor Adicional ao frete para renovação de marinha mercante] 
    */
    'afrmmValue': number;
    /**
    * - '1' # On One's Own [1-por conta propria] - '2' # On Behalf And Order [2-por conta e ordem] - '3' # Order [3-encomenda] 
    */
    'intermediateType': LineForGoodsDi.IntermediateTypeEnum;
    /**
    * Buyer federal tax id CNPJ do comprador ou encomendante 
    */
    'buyerFederalTaxID': string;
    /**
    * Buyer sate Estado do comprador ou encomendante 
    */
    'buyerState': StateEnum;
    /**
    * Exporter code
    */
    'exporterCode': string;
    /**
    * aditional import declaration
    */
    'adi': Array<LineForGoodsAdi>;
}

export namespace LineForGoodsDi {
    export enum TransportDITypeEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8',
        _9 = <any> '9',
        _10 = <any> '10'
    }
    export enum IntermediateTypeEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3'
    }
}
export class LineForGoodsExport {
    'drawbackNumber': string;
    'indExport': LineForGoodsIndExport;
}

export class LineForGoodsIcmsTaxRelief {
    /**
    * When item transaction subject to desoneration, this is the reason code - '1' # Táxi; - '3' # Produtor Agropecuário; - '4' # Frotista/Locadora; - '5' # Diplomático/Consular; - '6' # Utilitários e Motocicletas da Amazônia Ocidental e Áreas de Livre Comércio (Resolução 714/88 e 790/94 – CONTRAN e suas alterações); - '7' # SUFRAMA; - '8' # Venda a órgão Público; - '9' # Outros - '10' # Deficiente Condutor - '11' # Deficiente não condutor - '12' # Fomento agropecuário - '16' # Olimpíadas Rio 2016 
    */
    'reasonCode': LineForGoodsIcmsTaxRelief.ReasonCodeEnum;
    /**
    * ICMS Tax base rate discount  (desconto na base do ICMS referetne a desoneração)
    */
    'taxBaseDiscount': number;
    /**
    * Amount for Icms Relief (desoneração)
    */
    'taxAmount': number;
}

export namespace LineForGoodsIcmsTaxRelief {
    export enum ReasonCodeEnum {
        _1 = <any> '1',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8',
        _9 = <any> '9',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _16 = <any> '16'
    }
}
/**
* indirect exportation
*/
export class LineForGoodsIndExport {
    /**
    * Exportation register number
    */
    'registerNumber': string;
    /**
    * invoice access key received to export
    */
    'accessKey': string;
    /**
    * This decimal 11 integers and 0 to 4 decimals, quantity exported in real
    */
    'quantity': number;
}

export class LineForSefazGoods {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
    */
    'returnedPercentageAmount': number;
    /**
    * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
    */
    'lineUnitPrice': number;
    /**
    * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Discount conditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineTaxedDiscount': number;
    /**
    * discount unconditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineUntaxedDiscount': number;
    /**
    * This is a enumeration folowing table
    */
    'useType': LineForSefazGoods.UseTypeEnum;
    /**
    * Reference to process configurantion of this transaction, See ProcessScenario definition
    */
    'processScenario': string;
    /**
    * Fiscal Operation Code of transport service
    */
    'cfop': number;
    /**
    * return if this transaction has stock impact for this process or CFOP
    */
    'hasStockImpact': boolean;
    /**
    * return if this transaction has finantial impact for this process or CFOP
    */
    'hasFinantialImpact': boolean;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'freightAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'insuranceAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'otherCostAmount': number;
    /**
    * The item value will compose the invoice total value.
    */
    'indTotType': boolean;
    /**
    * order number, information used for B2B control process
    */
    'orderNumber': string;
    /**
    * number of the item from order number, information used for B2B control process
    */
    'orderItemNumber': string;
    /**
    * Gloal Unique identifier (Importation form)
    */
    'fciNumber': string;
    /**
    * RECOPI number
    */
    'recopiNumber': string;
    /**
    * additional information about product (referenced standard, complementary info, etc)
    */
    'infAdProd': string;
    'vehicle': Vehicle;
    'medicine': Medicine;
    'weapon': Weapon;
    'fuel': Fuel;
    /**
    * Inform that for this item the Entity referenced is ICMS Substitute
    */
    'entityIsIcmsSubstitute': boolean;
    /**
    * Inform that this item has ICMS withheld for transport value service.
    */
    'isTransportIcmsWithheld': boolean;
    'icmsTaxRelief': LineForGoodsIcmsTaxRelief;
    /**
    * Exportation detail
    */
    'export': Array<LineForGoodsExport>;
    /**
    * Import declaration
    */
    'di': Array<LineForGoodsDi>;
    'calculatedTax': LineForGoodsCalculatedTax;
    'extend': AgastExtendForSefaz;
}

export namespace LineForSefazGoods {
    export enum UseTypeEnum {
        UseOrConsumption = <any> 'use or consumption',
        Resale = <any> 'resale',
        AgriculturalProduction = <any> 'agricultural production',
        Production = <any> 'production',
        UseOrConsumptionOnBusinessEstablishment = <any> 'use or consumption on business establishment',
        UseOrConsumptionOnTransporterServiceEstablishment = <any> 'use or consumption on transporter service establishment',
        UseOrConsumptionOnCommunicationServiceEstablishment = <any> 'use or consumption on communication service establishment',
        UseOrConsumptionOnDemandByContract = <any> 'use or consumption on demand by contract',
        UseOrConsumptionOnEnergySupplierEstablishment = <any> 'use or consumption on energy supplier establishment',
        UseOrConsumptionOfFuelTransactionTypeExportation = <any> 'use or consumption of fuel transaction type exportation',
        FixedAssets = <any> 'fixed assets',
        ResaleExport = <any> 'resale export',
        ResaleIcmsExempt = <any> 'resale icms exempt',
        ResaleBuyerUnderTheSameIcmsStTaxRule = <any> 'resale buyer under the same icmsSt tax rule',
        TransportOfGoodsThatDontNeedInvoiceNf = <any> 'transport of goods that don't need invoice (nf)'
    }
}
export class Location {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
    /**
    * House number
    */
    'number': string;
    /**
    * Any other information about the address (Room, Suite, Floor, etc)).
    */
    'complement': string;
    /**
    * Phone number
    */
    'phone': string;
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * this property identify the location, it is unique for this company
    */
    'code': string;
    /**
    * this property identify the location, it is unique for this company
    */
    'type': Location.TypeEnum;
    /**
    * Email
    */
    'email': string;
    /**
    * Federal tax id, CNPJ or CPF
    */
    'federalTaxId': string;
    /**
    * state tax id for this location
    */
    'stateTaxId': string;
    'secondaryStateTaxId': Array<LocationSecondaryStateTaxId>;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    'suframa': string;
    /**
    * Main location activity
    */
    'mainActivity': Location.MainActivityEnum;
    /**
    * - 'edi' # City hall has web service and the integration is automatic - 'xml' # Create RPS specific to City, bat does not have webservice integration - 'rps' # Create a generic RPS, NF is by hands 
    */
    'nfseProcessModel': Location.NfseProcessModelEnum;
}

export namespace Location {
    export enum TypeEnum {
        ShipFrom = <any> 'ShipFrom',
        ShipTo = <any> 'ShipTo',
        ServiceRendered = <any> 'ServiceRendered'
    }
    export enum MainActivityEnum {
        Commerce = <any> 'commerce',
        Industry = <any> 'industry',
        Service = <any> 'service'
    }
    export enum NfseProcessModelEnum {
        Edi = <any> 'edi',
        Xml = <any> 'xml',
        Rps = <any> 'rps'
    }
}
export class LocationSecondaryStateTaxId {
    'stateTaxId': string;
    'state': StateEnum;
}

export class Medicine {
    'loteNumber': string;
    /**
    * This is a decimal type with 11 digits including 3 decimal positions.
    */
    'loteQuantity': number;
    'manufactotyDate': Date;
    'expirationDate': Date;
    /**
    * This is a decimal type with 15 digits including 2 decimal positions.  Max value to end user.
    */
    'maxValueToEndUser': number;
}

export class Message {
    'message': string;
}

export class ModelError {
    'code': number;
    'message': string;
    'field': string;
    'value': string;
    'in': ModelError.ModelInEnum;
}

export namespace ModelError {
    export enum ModelInEnum {
        Params = <any> 'params',
        Body = <any> 'body',
        Query = <any> 'query'
    }
}
/**
* Referenced Invoices The invoice can be one of this types, - 'refNFe - Eletronic Invoice' - 'refCTE - Transport Invoice' - 'refECF - Reatail Cupom' - 'refNF  - Invoice model 1 or 1A' - 'refFarmerNF - farmer invoice' 
*/
export class NRef {
    'type': NRef.TypeEnum;
    'refNFe': string;
    'refCTe': string;
    'refECF': NRefRefECF;
    'refNF': NRefRefNF;
    'refFarmerNF': NRefRefFarmerNF;
}

export namespace NRef {
    export enum TypeEnum {
        RefNFe = <any> 'refNFe',
        RefCTE = <any> 'refCTE',
        RefECF = <any> 'refECF',
        RefNF = <any> 'refNF',
        RefFarmerNF = <any> 'refFarmerNF'
    }
}
export class NRefRefECF {
    /**
    * ECF Sequential number that generated Cupom attached to NFe informar o número de ordem seqüencial do ECF que emitiu o Cupom Fiscal vinculado à NF-e 
    */
    'nECF': string;
    /**
    * Operational counter number attached to NFe Informar o Número do Contador de Ordem de Operação - COO vinculado à NF-e 
    */
    'nCOO': string;
    /**
    * Fiscal document model - '2B' # coupon tax not ECF - '2C' # PDV coupon tax - '2D' # ECF coupon tax 
    */
    'modECF': NRefRefECF.ModECFEnum;
}

export namespace NRefRefECF {
    export enum ModECFEnum {
        _2B = <any> '2B',
        _2C = <any> '2C',
        _2D = <any> '2D'
    }
}
export class NRefRefFarmerNF {
    /**
    * State code of fiscal Document creator, farmer
    */
    'stateCd': StateEnum;
    /**
    * year and month of fiscal document creation
    */
    'yymm': string;
    /**
    * fiscal document creator farmer federalTaxId
    */
    'federalTaxId': string;
    /**
    * fiscal document creator, farmer stateTaxId
    */
    'stateTaxId': string;
    /**
    * Document Fiscal model - '04' # FARMER DOCUMENT - '01' # DETACHED DOCUMENT - AVULSO 
    */
    'model': NRefRefFarmerNF.ModelEnum;
    /**
    * fiscal document serie
    */
    'serie': string;
    /**
    * fiscal document number
    */
    'number': string;
}

export namespace NRefRefFarmerNF {
    export enum ModelEnum {
        _04 = <any> '04',
        _01 = <any> '01'
    }
}
export class NRefRefNF {
    /**
    * State code of fiscal Document creator
    */
    'stateCd': StateEnum;
    /**
    * year and month of fiscal document creation
    */
    'yymm': string;
    /**
    * fiscal document creator federalTaxId
    */
    'federalTaxId': string;
    /**
    * fiscal document serie
    */
    'serie': string;
    /**
    * fiscal document number
    */
    'number': string;
}

export class PayRecCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * Sum of grossvalues
    */
    'subtotal': number;
    /**
    * Sum of all withholding values
    */
    'totalTax': number;
    /**
    * Sum all NetValues
    */
    'grandTotal': number;
    'pccWithholdingModes': Array<PccWithholdingMode>;
    'taxByType': PayRecCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class PayRecCalculatedTaxSummaryForServiceTaxByType {
    'issRf': TaxByTypeSummaryForService;
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
}

export class PayRecHeader {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PayRecHeader.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code. 'BRL' for Brazilian Reais.
    */
    'currency': PayRecHeader.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
    */
    'vendorCode': string;
    /**
    * - 'CALCULATE' - 'ASIS' When ASIS, the transaction is stored without executing tax determination (no Calculation). 
    */
    'paymentMode': PayRecHeader.PaymentModeEnum;
}

export namespace PayRecHeader {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
    export enum PaymentModeEnum {
        CALCULATE = <any> 'CALCULATE',
        ASIS = <any> 'ASIS'
    }
}
export class PayRecLinesIn {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PayRecLinesIn.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
}

export namespace PayRecLinesIn {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class PayRecLinesOut {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PayRecLinesOut.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
    /**
    * GrossAmount of this installment line
    */
    'lineAmount': number;
    /**
    * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
    */
    'lineNetValue': number;
    /**
    * x is because not subject of this tax independent of Threshold
    */
    'withholdingMode': WithholdingMode;
    'calculatedTax': PaymentCalculatedTax;
}

export namespace PayRecLinesOut {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class Payment {
    /**
    * Installment terms - 0 # cash - 1 # on terms - 2 # other 
    */
    'installmentsTerms': number;
    'bill': PaymentBill;
    'installment': Array<PaymentInstallment>;
    'paymentMode': Array<PaymentPaymentMode>;
}

/**
* Bill information
*/
export class PaymentBill {
    /**
    * Bill identifier
    */
    'nFat': string;
    /**
    * Orignal value
    */
    'vOrig': number;
    /**
    * Discount
    */
    'vDiscount': number;
    /**
    * Net value
    */
    'vNet': number;
}

/**
* Structure with value for each tax withhold value of this line
*/
export class PaymentCalculatedTax {
    'taxByType': PaymentTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
}

export class PaymentInstallment {
    /**
    * Instalment number identifier
    */
    'documentNumber': string;
    /**
    * Installment expiration date
    */
    'date': Date;
    /**
    * Installment value
    */
    'grossValue': number;
}

export class PaymentLinesIn {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PaymentLinesIn.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
    /**
    * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
    */
    'lineNetValue': number;
}

export namespace PaymentLinesIn {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class PaymentPaymentMode {
    /**
    * Payment mode - '01' # Dinheiro - '02' # Cheque - '03' # Cartão de Crédito - '04' # Cartão de Débito - '05' # Crédito Loja - '10' # Vale Alimentação - '11' # Vale Refeição - '12' # Vale Presente - '13' # Vale Combustível - '99' # Outros 
    */
    'mode': PaymentPaymentMode.ModeEnum;
    /**
    * payment value
    */
    'value': number;
    /**
    * - '1' # Payment integrated with system, - '2' # Payment not integrated with system 
    */
    'cardTpIntegration': PaymentPaymentMode.CardTpIntegrationEnum;
    /**
    * Federal tax id of accrediting card (credenciadora do cartão)
    */
    'cardCNPJ': string;
    /**
    * card brand - '01' # Visa - '02' # Mastercard - '03' # American Express - '04' # Sorocred - '99' # Other 
    */
    'cardBrand': PaymentPaymentMode.CardBrandEnum;
    /**
    * transaction authorization number
    */
    'cardAuthorization': string;
}

export namespace PaymentPaymentMode {
    export enum ModeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _99 = <any> '99'
    }
    export enum CardTpIntegrationEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
    export enum CardBrandEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _99 = <any> '99'
    }
}
/**
* Object with summary of all taxes returned by engine
*/
export class PaymentTaxByType {
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'issRf': TaxByTypeTax;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
}

/**
* 0 – cash pagamento à vista 1 – on terms, pagamento à prazo; 
*/
export class PaymentTerms {
}

export class PaymentTransactionIn {
    'header': PayRecHeader;
    'lines': Array<PaymentLinesIn>;
}

export class PaymentTransactionOut {
    'header': PayRecHeader;
    'lines': Array<PayRecLinesOut>;
    'calculatedTaxSummary': PayRecCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class PccWithholdingMode {
    /**
    * Inform if this group of tax are calculated considering the threashold by PCC or Individualy (each tax separately)
    */
    'type': PccWithholdingMode.TypeEnum;
    /**
    * this attribute occurs only for CSRF type, When CRSF mode, this is sum of pisRf, CofinsRf and CsllRf
    */
    'totalTax': number;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
}

export namespace PccWithholdingMode {
    export enum TypeEnum {
        CSRF = <any> 'CSRF',
        Individual = <any> 'individual'
    }
}
/**
* Address where the service is rendered.
*/
export class PointOfOrderOrigin {
    'address': SimpleAddress;
}

export class ProcessScenario {
    /**
    * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': ProcessScenario.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': ProcessScenario.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': ProcessScenario.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    /**
    * Process name to Identify this configuration
    */
    'name': string;
    'type': ProcessScenario.TypeEnum;
    /**
    * inform if the transaction is an operation to internalizing (receive) item or value
    */
    'wayType': ProcessScenario.WayTypeEnum;
    'goal': ProcessScenario.GoalEnum;
    /**
    * inform that the configuration process overwrites the cfop configuration.
    */
    'overWriteCFOP': boolean;
    'cfops': Array<CfopConf>;
}

export namespace ProcessScenario {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum TypeEnum {
        SALES = <any> 'SALES',
        PURCHASE = <any> 'PURCHASE',
        SALESRETURN = <any> 'SALES_RETURN',
        PURCHASERETURN = <any> 'PURCHASE_RETURN',
        TRANSFERRETURN = <any> 'TRANSFER_RETURN',
        SHIPPING = <any> 'SHIPPING',
        SHIPPINGRETURN = <any> 'SHIPPING_RETURN',
        TRANSFER = <any> 'TRANSFER',
        RECEIPTAJUSTE = <any> 'RECEIPT_AJUSTE',
        TRANSFERAJUSTE = <any> 'TRANSFER_AJUSTE'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum GoalEnum {
        Normal = <any> 'Normal',
        Complementary = <any> 'Complementary',
        Voided = <any> 'Voided',
        Replacement = <any> 'Replacement',
        Return = <any> 'Return',
        Adjustment = <any> 'Adjustment'
    }
}
export class ProcessingInfo {
    'versionId': string;
    'duration': number;
}

export class PurchaseCalculatedTax {
    'taxByType': PurchaseTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
    'details': Array<PurchaseTaxByTypeDetail>;
}

export class PurchaseCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line tax attribute
    */
    'subtotal': number;
    /**
    * sum of all line lineAmount attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': PurchaseCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class PurchaseCalculatedTaxSummaryForServiceTaxByType {
    'issRf': TaxByTypeSummaryForService;
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
    'inssAr': TaxByTypeSummaryForService;
    'pis': TaxByTypeSummaryForService;
    'cofins': TaxByTypeSummaryForService;
}

/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
*/
export class PurchaseDefaultLocations {
    'pointOfOrderOrigin': PointOfOrderOrigin;
}

export class PurchaseEntity {
    /**
    * Legal Name of Service buyer.
    */
    'name': string;
    'type': EntityType;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * CNPJ/CPF of Sales Buyer. If CPF, pattern is '[0-9]{11}' if CNPJ, pattern is '[0-9]{14}'
    */
    'cnpjcpf': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': FederalTaxRegime;
    /**
    * Some cities require PURCHASE.Buyers to withhold ISS (City Tax) from PURCHASE.Sellers stablished in different cities. In case the PURCHASE.Seller has acquired a Tax Registration in this destination city, by providing this information in the service invoice, this withholding obligation is lifted.
    */
    'hasCpom': boolean;
    /**
    * These are the federal taxes attributes that determine whether withholding of taxes should take place. In special cases where the PURCHASE.Seller is exempt of one or more of these taxes the withholding follows the same rules. The Business type may also dictate these rules as well.
    */
    'subjectWithholdingIrrf': boolean;
    /**
    * The INSS contribution is capped at a maximum limit (amount of actual retired payment available in the country).  Individuals sellers subject to INSS withholding can provide the amount already tax by other transactions (with the same buyer or different ones) to deduct to the tax basis. This amount is to be provided to the Seller in a form of a signed document.
    */
    'inssPreviousContrib': number;
    /**
    * The INSS contribution is applicable only to the labor amount in a service contract.  There are several items that may be deducted from the service invoice total to arrive at the INSS taxable amount. This amount is to be provided to the Seller in the body of the Invoice or calculated during the transaction input.
    */
    'inssBasisDiscount': number;
    /**
    * When Seller is Simples regime, the seller needs send RF rate.
    */
    'issRfRate': number;
}

export class PurchaseHeaderIn {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PurchaseHeaderIn.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': PurchaseHeaderIn.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
    */
    'vendorCode': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    'entity': PurchaseEntity;
    'payment': PurchaseHeaderInPayment;
    'taxesConfig': PurchaseTaxesConfig;
    'defaultLocations': PurchaseDefaultLocations;
}

export namespace PurchaseHeaderIn {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
}
export class PurchaseHeaderInPayment {
    'terms': PaymentTerms;
    /**
    * installments
    */
    'installments': Array<PurchaseInstallmentIn>;
}

export class PurchaseHeaderOut {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PurchaseHeaderOut.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': PurchaseHeaderOut.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
    */
    'vendorCode': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    'entity': PurchaseEntity;
    'payment': PurchaseHeaderOutPayment;
    'taxesConfig': PurchaseTaxesConfig;
    'defaultLocations': PurchaseDefaultLocations;
}

export namespace PurchaseHeaderOut {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
}
export class PurchaseHeaderOutPayment {
    'terms': PaymentTerms;
    'withholdingMode': WithholdingMode;
    /**
    * installments
    */
    'installments': Array<InstallmentComplete>;
}

export class PurchaseInfo {
    /**
    * Invoice info for government purchase orders Informação da Nota de Empenho de compras públicas 
    */
    'governmentOrder': string;
    /**
    * Order info Informação do pedido 
    */
    'orderNumber': string;
    /**
    * Agreement info Informação do contrato 
    */
    'contractNumber': string;
}

export class PurchaseInstallmentIn {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment, Due Date
    */
    'date': Date;
    /**
    * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
}

export class PurchaseLinesIn {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    /**
    * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
    */
    'useType': PurchaseLinesIn.UseTypeEnum;
    'taxDeductions': SalesLinesOutTaxDeductions;
}

export namespace PurchaseLinesIn {
    export enum UseTypeEnum {
        Resale = <any> 'resale',
        Production = <any> 'production',
        UseOrConsumption = <any> 'use or consumption',
        FixedAssets = <any> 'fixed assets'
    }
}
export class PurchaseLinesOut {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    /**
    * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
    */
    'useType': PurchaseLinesOut.UseTypeEnum;
    'taxDeductions': SalesLinesOutTaxDeductions;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal captures the value of lineAmount - lineTaxedDiscount - sum of withholding.
    */
    'lineNetValue': number;
    'calculatedTax': PurchaseCalculatedTax;
}

export namespace PurchaseLinesOut {
    export enum UseTypeEnum {
        Resale = <any> 'resale',
        Production = <any> 'production',
        UseOrConsumption = <any> 'use or consumption',
        FixedAssets = <any> 'fixed assets'
    }
}
/**
* Object with summary of all taxes returned by engine
*/
export class PurchaseTaxByType {
    'issRf': TaxByTypeTax;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'inssAr': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'cofins': TaxByTypeTax;
}

export class PurchaseTaxByTypeDetail {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': PurchaseTaxByTypeDetail.JurisdictionTypeEnum;
    /**
    * Tax identificator - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inssAr' - 'inssRf' - 'issRf' 
    */
    'taxType': PurchaseTaxByTypeDetail.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures how much of the lineAmount was non-taxed. This is simply the line amount minus the taxable.
    */
    'subtotalExempt': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
    */
    'taxRuleType': PurchaseTaxByTypeDetail.TaxRuleTypeEnum;
}

export namespace PurchaseTaxByTypeDetail {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Pis = <any> 'pis',
        PisRf = <any> 'pisRf',
        Cofins = <any> 'cofins',
        CofinsRf = <any> 'cofinsRf',
        Csll = <any> 'csll',
        CsllRf = <any> 'csllRf',
        Irrf = <any> 'irrf',
        InssAr = <any> 'inssAr',
        InssRf = <any> 'inssRf',
        IssRf = <any> 'issRf'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class PurchaseTaxesConfig {
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'entityAccruableCOFINSTaxation': PurchaseTaxesConfig.EntityAccruableCOFINSTaxationEnum;
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.   This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
    */
    'entityAccruableCSLLTaxation': PurchaseTaxesConfig.EntityAccruableCSLLTaxationEnum;
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'entityAccruablePISTaxation': PurchaseTaxesConfig.EntityAccruablePISTaxationEnum;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
    */
    'accruableCOFINSExempCodeTaxation': string;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
    */
    'accruablePISExempCodeTaxation': string;
    /**
    * When Code is 999 the user system need send the custom reason to Exemption
    */
    'accruablePISExemptReasonTaxation': string;
    /**
    * When Code is 999 the user system need send the custom reason to Exemption
    */
    'accruableCOFINSExemptReasonTaxation': string;
    /**
    * CSLL no withholding Custom Reason
    */
    'accruableCSLLExemptReasonTaxation': string;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingPIS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCOFINS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCSLL': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingIRRF': boolean;
    /**
    * COFINS no withholding Custom Reason
    */
    'withholdCOFINSExemptReasonTaxation': string;
    /**
    * CSLL no withholding Custom Reason
    */
    'withholdCSLLExemptReasonTaxation': string;
    /**
    * PIS no withholding Custom Reason
    */
    'withholdPISExemptReasonTaxation': string;
}

export namespace PurchaseTaxesConfig {
    export enum EntityAccruableCOFINSTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
    export enum EntityAccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum EntityAccruablePISTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
}
export class PurchaseTransactionIn {
    'header': PurchaseHeaderIn;
    'lines': Array<PurchaseLinesIn>;
}

export class PurchaseTransactionOut {
    'header': PurchaseHeaderOut;
    'lines': Array<PurchaseLinesOut>;
    'calculatedTaxSummary': PurchaseCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class ReceiptTransactionIn {
    'header': PayRecHeader;
    'lines': Array<PaymentLinesIn>;
}

export class ReceiptTransactionOut {
    'header': PayRecHeader;
    'lines': Array<PayRecLinesOut>;
    'calculatedTaxSummary': PayRecCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class SalesCalculatedTax {
    'taxByType': SalesTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
    'details': Array<SalesTaxByTypeDetail>;
}

export class SalesCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line tax attribute
    */
    'subtotal': number;
    /**
    * sum of all line lineAmount attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': SalesCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class SalesCalculatedTaxSummaryForServiceTaxByType {
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
    'pis': TaxByTypeSummaryForService;
    'cofins': TaxByTypeSummaryForService;
    'csll': TaxByTypeSummaryForService;
    'issRf': TaxByTypeSummaryForService;
    'iss': TaxByTypeSummaryForService;
    'aproxtribCity': TaxByTypeSummaryForService;
    'aproxtribFed': TaxByTypeSummaryForService;
    'irpj': TaxByTypeSummaryForService;
    'inss': TaxByTypeSummaryForService;
}

/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
*/
export class SalesDefaultLocations {
    'serviceRendered': ServiceRendered;
}

export class SalesEntity {
    /**
    * SERVICE BUYER NAME OFFICIAL
    */
    'name': string;
    'type': EntityType;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'cnpjcpf': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': FederalTaxRegime;
    /**
    * Entity Special Tax Regime  - 'MEM' # Microempresa municipal - 'EST' # Estimativa - 'SPR' # Sociedade de profissionais - 'COP' # Cooperativa - 'MEI' # Microempresário Individual (MEI) - 'MPP' # Microempresário e Empresa de Pequeno Porte (ME EPP) 
    */
    'specialTaxRegime': SalesEntity.SpecialTaxRegimeEnum;
    /**
    * Companies subject to rule follow same rule of Government
    */
    'subjectToSRF1234': boolean;
    /**
    * If Withholding ISS is required, independently the rules applied.
    */
    'requiredWithholdingISS': boolean;
    /**
    * technical note. Anota\\u00e7\\u00e3o de Responsabilidade T\\u00e9cnica-ART, estabelece que todos os contratos referentes à  execu\\u00e7\\u00e3o de servi\\u00e7os ou obras de Engenharia, Agronomia, Geologia, Geografia ou Meteorologia dever\\u00e3o ser objeto de anota\\u00e7\\u00e3o no Conselho Regional de Engenharia e Agronomia
    */
    'art': string;
    /**
    * PROCESS NUMBER TO ISS SUSPENDED FOR ADMINISTRATIVE PROCESS
    */
    'adminProcess': string;
    /**
    * Business code. Código da obra OBRA
    */
    'buildCode': string;
}

export namespace SalesEntity {
    export enum SpecialTaxRegimeEnum {
        MEM = <any> 'MEM',
        EST = <any> 'EST',
        SPR = <any> 'SPR',
        COP = <any> 'COP',
        MEI = <any> 'MEI',
        MPP = <any> 'MPP'
    }
}
export class SalesHeaderIn {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': SalesHeaderIn.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': SalesHeaderIn.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is a code maintained by the client application and recorded in Customer Portal to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
    */
    'customerCode': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    /**
    * Provisional receipt services, sequencial number maintained by the client application, unique by serie
    */
    'rpsNumber': number;
    /**
    * set name identifier for rps number sequency.
    */
    'rpsSerie': string;
    /**
    * Service discrimination, free description about service
    */
    'discriminationIn': string;
    'entity': SalesEntity;
    'payment': SalesHeaderInPayment;
    'taxesConfig': SalesTaxesConfig;
    'defaultLocations': SalesDefaultLocations;
}

export namespace SalesHeaderIn {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
}
export class SalesHeaderInPayment {
    'terms': PaymentTerms;
    /**
    * installments
    */
    'installments': Array<SalesInstallmentIn>;
}

export class SalesHeaderOut {
    /**
    * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
    */
    'accountId': string;
    /**
    * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'companyCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': SalesHeaderOut.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': SalesHeaderOut.CurrencyEnum;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is a code maintained by the client application and recorded in Customer Portal to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
    */
    'customerCode': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    /**
    * Provisional receipt services, sequencial number maintained by the client application, unique by serie
    */
    'rpsNumber': number;
    /**
    * set name identifier for rps number sequency.
    */
    'rpsSerie': string;
    /**
    * Service discrimination, free description about service
    */
    'discriminationIn': string;
    'entity': SalesEntity;
    'payment': SalesHeaderOutPayment;
    'taxesConfig': SalesTaxesConfig;
    'defaultLocations': SalesDefaultLocations;
    /**
    * Invoice discrimination, it is discriminationIn plus automatic messages
    */
    'discriminationOut': string;
    /**
    * RPS XML or NFSe XML generated, when the client system doesn't have EDI with government then BR16 return RPS when transaction is created.
    */
    'xml': string;
    /**
    * Service sales usually has a EDI integration with government to get Final document or Authorization. This is external process and the integration status is followed by this property. - 'STORED' - 'WAITING APPROVAL' - 'AUTHORIZED' - 'AUTHORIZED with NOTE' - 'ERROR' - 'CANCELED REPLACED' - 'CANCELED' - 'CANCELLATION REQUESTED' 
    */
    'ediSyncState': SalesHeaderOut.EdiSyncStateEnum;
}

export namespace SalesHeaderOut {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum CurrencyEnum {
        BRL = <any> 'BRL'
    }
    export enum EdiSyncStateEnum {
        STORED = <any> 'STORED',
        WAITINGAPPROVAL = <any> 'WAITING APPROVAL',
        AUTHORIZED = <any> 'AUTHORIZED',
        AUTHORIZEDWithNOTE = <any> 'AUTHORIZED with NOTE',
        ERROR = <any> 'ERROR',
        CANCELEDREPLACED = <any> 'CANCELED REPLACED',
        CANCELED = <any> 'CANCELED',
        CANCELLATIONREQUESTED = <any> 'CANCELLATION REQUESTED'
    }
}
export class SalesHeaderOutPayment {
    'terms': PaymentTerms;
    /**
    * To avoid having to verify multiple attributes from a Invoice at the time of funds collection which subject to Tax Withholding, this attribute will allow a referenced Invoice to be quickly checked for withholdings during the cash transaction. This is an SALES.Transaction attribute to be consisted in the Tax Engine that can be used during the receivable process. The values are enumeration where each letter identify if that tax has been withheld PCC,xxx, PCx, PxC ...
    */
    'withholdingMode': WithholdingMode;
    /**
    * installments
    */
    'installments': Array<InstallmentComplete>;
}

export class SalesInstallmentIn {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment Due Date
    */
    'date': Date;
    /**
    * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
}

export class SalesLinesIn {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    'taxDeductions': SalesLinesInTaxDeductions;
}

export class SalesLinesInTaxDeductions {
    /**
    * Deduction amount not taxable by ISS . Example constructions materials included in a service invoice
    */
    'iss': number;
}

export class SalesLinesOut {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    'taxDeductions': SalesLinesOutTaxDeductions;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineNetValue = (lineAmount - discountTaxable - sum of whithholdings).
    */
    'lineNetValue': number;
    /**
    * - '01' # ORIGIN MODE - '02' # ORIGIN MODE BUT EXEMPT - '03' # ORIGIN MODE BUT IMMUNE - '04' # ORIGIN MODE BUT SUSPENDED FOR LEGAL REASON - '05' # ORIGIN MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '21' # DESTINATION MODE - '22' # DESTINATION MODE BUT EXEMPT - '23' # DESTINATION MODE BUT IMMUNE - '24' # DESTINATION MODE BUT SUSPENDED - '25' # DESTINATION MODE BUT SUSPENDED - '40' # FOREIGN IMMUNE MODE 
    */
    'cst': SalesLinesOut.CstEnum;
    /**
    * - '61' # WITHHOLD NORMAL MODE - '62' # WITHHOLD NORMAL MODE BUT EXEMPT - '63' # WITHHOLD NORMAL MODE BUT IMMUNE - '64' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR LEGAL REASON - '65' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '66' # WITHHOLD FORCED MODE - '67' # WITHHOLD FORCED MODE BUT EXEMPT - '68' # WITHHOLD FORCED MODE BUT IMMUNE - '69' # WITHHOLD FORCED MODE BUT SUSPENDED FOR LEGAL REASON - '70' # WITHHOLD FORCED MODE BUT SUSPENDED FOR ADMINISTRATIVE PROCESS - '71' # NO WITHHOLD MODE - '72' # NO WITHHOLD FOREIGN MODE 
    */
    'cstRf': SalesLinesOut.CstRfEnum;
    'calculatedTax': SalesCalculatedTax;
}

export namespace SalesLinesOut {
    export enum CstEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _40 = <any> '40'
    }
    export enum CstRfEnum {
        _61 = <any> '61',
        _62 = <any> '62',
        _63 = <any> '63',
        _64 = <any> '64',
        _65 = <any> '65',
        _66 = <any> '66',
        _67 = <any> '67',
        _68 = <any> '68',
        _69 = <any> '69',
        _70 = <any> '70',
        _71 = <any> '71',
        _72 = <any> '72'
    }
}
export class SalesLinesOutTaxDeductions {
    /**
    * Deduction amount not ISS taxable. Example Building material
    */
    'iss': number;
}

/**
* Object with summary of all taxes returned by engine
*/
export class SalesTaxByType {
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'cofins': TaxByTypeTax;
    'csll': TaxByTypeTax;
    'issRf': TaxByTypeTax;
    'iss': TaxByTypeTax;
    'aproxtribCity': TaxByTypeTax;
    'aproxtribFed': TaxByTypeTax;
    'irpj': TaxByTypeTax;
    'inss': TaxByTypeTax;
}

export class SalesTaxByTypeDetail {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': SalesTaxByTypeDetail.JurisdictionTypeEnum;
    /**
    * Tax identificator - 'aproxtribCity' - 'aproxtribFed' - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inss' - 'inssRf' - 'iss' - 'issRf' - 'irpj' 
    */
    'taxType': SalesTaxByTypeDetail.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures how much of the lineAmount was non-taxed. This is simply the line amount minus the taxable.
    */
    'subtotalExempt': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
    */
    'taxRuleType': SalesTaxByTypeDetail.TaxRuleTypeEnum;
}

export namespace SalesTaxByTypeDetail {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        AproxtribCity = <any> 'aproxtribCity',
        AproxtribFed = <any> 'aproxtribFed',
        Pis = <any> 'pis',
        PisRf = <any> 'pisRf',
        Cofins = <any> 'cofins',
        CofinsRf = <any> 'cofinsRf',
        Csll = <any> 'csll',
        CsllRf = <any> 'csllRf',
        Irrf = <any> 'irrf',
        Inss = <any> 'inss',
        InssRf = <any> 'inssRf',
        Iss = <any> 'iss',
        IssRf = <any> 'issRf',
        Irpj = <any> 'irpj'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class SalesTaxesConfig {
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'accruableCOFINSTaxation': SalesTaxesConfig.AccruableCOFINSTaxationEnum;
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
    */
    'accruableCSLLTaxation': SalesTaxesConfig.AccruableCSLLTaxationEnum;
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'accruablePISTaxation': SalesTaxesConfig.AccruablePISTaxationEnum;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
    */
    'accruableCOFINSExempCodeTaxation': string;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
    */
    'accruablePISExempCodeTaxation': string;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCOFINS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCSLL': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingIRRF': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingPIS': boolean;
    /**
    * When property withholdingIRRF is false is mandatory inform the reason
    */
    'withholdIRRFExemptReasonTaxation': string;
}

export namespace SalesTaxesConfig {
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
}
export class SalesTransactionIn {
    'header': SalesHeaderIn;
    'lines': Array<SalesLinesIn>;
}

export class SalesTransactionOut {
    'header': SalesHeaderOut;
    'lines': Array<SalesLinesOut>;
    'calculatedTaxSummary': SalesCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class SefazDisableRangeIn {
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - '55' # Nota Fiscal Eletrônica (NF-e) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
    */
    'transactionModel': SefazDisableRangeIn.TransactionModelEnum;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
    */
    'invoiceSerial': number;
    'year': number;
    'message': string;
    /**
    * First number of disable range.
    */
    'invoiceNumberInit': number;
    /**
    * Last number of disable range.
    */
    'invoiceNumberEnd': number;
}

export namespace SefazDisableRangeIn {
    export enum TransactionModelEnum {
        _55 = <any> '55',
        _65 = <any> '65'
    }
}
export class SefazInvoiceBasicStatus {
    'code': string;
    'desc': string;
}

export class SefazInvoiceStatus {
    'code': string;
    'desc': string;
    'protocol': string;
    'rec': string;
    'date': Date;
    /**
    * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação 
    */
    'environment': SefazInvoiceStatus.EnvironmentEnum;
    'appVersion': string;
}

export namespace SefazInvoiceStatus {
    export enum EnvironmentEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
}
export class SefazItDeleteIn {
    'message': string;
}

export class SefazItGetOut {
    /**
    * Invoice Access Key
    */
    'key': string;
    /**
    * XML Signed
    */
    'xml': string;
    'status': SefazInvoiceStatus;
}

export class SefazItPutIn {
    'code': string;
    'text': string;
}

export class SefazPostOut {
    'key': string;
    'documentCode': string;
    'status': SefazInvoiceStatus;
}

export class ServiceItemTaxRate {
    'taxType': string;
    'rateType': string;
    'rate': number;
    'isExempt': boolean;
    'discount': number;
    'zone1': number;
    'zone2': number;
    'period': ServiceItemTaxRatePeriod;
    'reason': string;
    'message': string;
}

export class ServiceItemTaxRatePeriod {
    'startDate': Date;
    'expirationDate': Date;
}

/**
* Address where the rendered service.
*/
export class ServiceRendered {
    'address': SimpleAddress;
}

export class SimpleAddress {
    /**
    * Address
    */
    'line1': string;
    /**
    * Number
    */
    'line2': string;
    /**
    * District
    */
    'line3': string;
    'city': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    'state': StateEnum;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

/**
* State Abreviation: - 'AC' - 'AL' - 'AP' - 'AM' - 'BA' - 'CE' - 'DF' - 'ES' - 'GO' - 'MA' - 'MT' - 'MS' - 'MG' - 'PA' - 'PB' - 'PR' - 'PE' - 'PI' - 'RJ' - 'RN' - 'RS' - 'RO' - 'RR' - 'SC' - 'SP' - 'SE' - 'TO' 
*/
export class StateEnum {
}

export class StateTransition {
    /**
    * - 'voided' - 'unvoided' - 'reconciled' - 'unreconciled' - 'filed' - 'unfiled' - 'filedByAvalara' 
    */
    'type': StateTransition.TypeEnum;
    'comment': string;
}

export namespace StateTransition {
    export enum TypeEnum {
        Voided = <any> 'voided',
        Unvoided = <any> 'unvoided',
        Reconciled = <any> 'reconciled',
        Unreconciled = <any> 'unreconciled',
        Filed = <any> 'filed',
        Unfiled = <any> 'unfiled',
        FiledByAvalara = <any> 'filedByAvalara'
    }
}
/**
* summary of all taxes
*/
export class TaxByTypeSummaryForGoods {
    /**
    * sum of all lines calcbase
    */
    'calcbase': number;
    /**
    * sum of referenced tax value
    */
    'tax': number;
    'jurisdictions': Array<TaxByTypeSummaryJurisdictionForGoods>;
}

/**
* summary of all taxes
*/
export class TaxByTypeSummaryForService {
    /**
    * sum of referenced tax value
    */
    'tax': number;
    'jurisdictions': Array<TaxByTypeSummaryJurisdiction>;
}

export class TaxByTypeSummaryJurisdiction {
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': TaxByTypeSummaryJurisdiction.JurisdictionTypeEnum;
    /**
    * sum of referenced tax value by jurisdiction
    */
    'tax': number;
}

export namespace TaxByTypeSummaryJurisdiction {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class TaxByTypeSummaryJurisdictionForGoods {
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': TaxByTypeSummaryJurisdictionForGoods.JurisdictionTypeEnum;
    /**
    * sum of referenced tax value by jurisdiction
    */
    'tax': number;
}

export namespace TaxByTypeSummaryJurisdictionForGoods {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class TaxByTypeTax {
    /**
    * Tax value, negative value for withhold value
    */
    'tax': number;
}

export class TaxConf {
    /**
    * main unique identificator
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': TaxConf.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': TaxConf.AccruablePISTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': TaxConf.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
}

export namespace TaxConf {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
}
/**
* Tax Rate Obs: AR - \"a recolher\" (serviço). RP e PP - filtrado para alvos de lucro real ou lucro presumido (serviço) 
*/
export class TaxType {
}

export class TaxTypeRate {
    'taxType': TaxType;
    /**
    * Tax can be calculated by rate or by quantity
    */
    'taxModel': TaxTypeRate.TaxModelEnum;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'rate': number;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'srvAmount': number;
    'quantityUnidBase': string;
    'specializationType': TaxTypeRate.SpecializationTypeEnum;
}

export namespace TaxTypeRate {
    export enum TaxModelEnum {
        Rate = <any> 'rate',
        Srf = <any> 'srf'
    }
    export enum SpecializationTypeEnum {
        Basic = <any> 'basic',
        Monophase = <any> 'monophase',
        TaxSubstitution = <any> 'taxSubstitution'
    }
}
export class TransactionForGoodsIn {
    'header': HeaderForGoods;
    'lines': Array<LineForGoods>;
}

export class TransactionForGoodsOut {
    'header': HeaderForGoods;
    'lines': Array<LineForGoods>;
    'calculatedTaxSummary': CalculatedTaxSummaryForGoods;
    'processingInfo': ProcessingInfo;
}

export class TransactionForSefazGoods {
    'header': HeaderForGoods;
    'lines': Array<LineForSefazGoods>;
    'calculatedTaxSummary': CalculatedTaxSummaryForGoods;
}

export class TransactionForSefazGoodsList extends Array<TransactionForSefazGoods> {
}

export class Transport {
    /**
    * Freight model  - 0 - CIF,  - 1 - FOB,  - 2 - Thrid party, - 9 - Free shipping when 9 - Free shipping, the fields below will be ignored if present - 'transporter' - 'withholdICMSTransport' - 'volumes' - 'vehicle' 
    */
    'modFreight': Transport.ModFreightEnum;
    /**
    * Forces witholding of ICMS on transport amount (freight)
    */
    'withholdICMSTransport': boolean;
    /**
    * Packages
    */
    'volumes': Array<TransportVolumes>;
    'vehicle': VehicleTransp;
}

export namespace Transport {
    export enum ModFreightEnum {
        CIF = <any> 'CIF',
        FOB = <any> 'FOB',
        Thridparty = <any> 'Thridparty',
        FreeShipping = <any> 'FreeShipping'
    }
}
export class TransportVolumes {
    /**
    * Quantity of packages transported
    */
    'qVol': string;
    /**
    * package type
    */
    'specie': string;
    /**
    * brand
    */
    'brand': string;
    /**
    * packages numeration
    */
    'volumeNumeration': string;
    /**
    * net weight using Kg
    */
    'netWeight': number;
    /**
    * gross weight using Kg
    */
    'grossWeight': number;
    'seal': Array<string>;
}

export class ValidationError {
    'message': string;
    'errors': Array<ModelError>;
}

export class Vehicle {
    /**
    * - 1 # Sales by car dealership - 2 # Direct billing - 3 # Direct sales - 0 # Other 
    */
    'tpOp': number;
    'chassisNumber': string;
    /**
    * color code used by factory
    */
    'colorCode': string;
    /**
    * color name
    */
    'colorName': string;
    /**
    * Power using CV unid
    */
    'cvPower': string;
    /**
    * engine size in cubic centimeters
    */
    'cylinderVolumCC': string;
    /**
    * net weight
    */
    'netWeight': string;
    /**
    * gross weight
    */
    'grossWeight': string;
    /**
    * serie
    */
    'serialNumber': string;
    /**
    * - '01' # Alcohol - '02' # Gas - '03' # Diesel - '16' # Alcohol/Gas - '17' # Gas/Alcohol/GNV - '18' # Gas/Electric 
    */
    'fuelType': Vehicle.FuelTypeEnum;
    /**
    * engine number
    */
    'engineNumber': string;
    /**
    * traction capacity, tonne
    */
    'cmt': string;
    /**
    * length between axis
    */
    'lengthBetweenAxis': string;
    /**
    * model year
    */
    'modelYear': string;
    /**
    * year of factory
    */
    'manufactoryYear': string;
    /**
    * paynt type
    */
    'paintType': string;
    'vehicleRENAVAMType': string;
    'specieRENAVAMType': string;
    'modelRENAVAMCode': string;
    /**
    * - '01' # YELLOW - '02' # BLUE - '03' # BEIGE - '04' # WHITE - '05' # GRAY - '06' # GOLDEN - '07' # GRENA - '08' # ORANGE - '09' # BROWN - '10' # SILVER - '11' # BLACK - '12' # PINK - '13' # PURPLE - '14' # GREEN - '15' # RED - '16' # FANTASY 
    */
    'colorDENATRANCode': Vehicle.ColorDENATRANCodeEnum;
    /**
    * chassis condition original or modified (remarcado)
    */
    'vin': Vehicle.VinEnum;
    /**
    * - '1' # Finished(Done) - '2' # Not finished - '3' # Semi-finished 
    */
    'vehicleManufactoryStatus': Vehicle.VehicleManufactoryStatusEnum;
    /**
    * max number of sit occupants
    */
    'maxOccupantsQuantity': string;
    /**
    * Lien/restriction type - '0' # No one; - '1' # Alienação Fiduciária; - '2' # Arrendamento Mercantil; - '3' # Reserva de Domínio; - '4' # Penhor de Veículos; - '9' # Other. 
    */
    'restrictionType': Vehicle.RestrictionTypeEnum;
}

export namespace Vehicle {
    export enum FuelTypeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18'
    }
    export enum ColorDENATRANCodeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16'
    }
    export enum VinEnum {
        R = <any> 'R',
        N = <any> 'N'
    }
    export enum VehicleManufactoryStatusEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3'
    }
    export enum RestrictionTypeEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _9 = <any> '9'
    }
}
export class VehicleID {
    'licensePlate': string;
    'stateCode': StateEnum;
    /**
    * Cargo Transport National Register, Registro Nacional de Transportador de Carga (ANTT)
    */
    'rtnc': string;
}

/**
* Identify type of vehicle used to transport the attributes, except atribute type,  follow rule allOf then only one of this atributes will be informed. 
*/
export class VehicleTransp {
    'type': VehicleTransp.TypeEnum;
    'automobile': VehicleID;
    /**
    * Trailer
    */
    'trailer': Array<VehicleID>;
    'wagon': string;
    /**
    * Ferry
    */
    'ferry': string;
}

export namespace VehicleTransp {
    export enum TypeEnum {
        Automobile = <any> 'automobile',
        Wagon = <any> 'wagon',
        Ferry = <any> 'ferry',
        Trailer = <any> 'trailer'
    }
}
export class Weapon {
    /**
    * - '0' # restrict use - '1' # public use 
    */
    'weaponRestrictionType': Weapon.WeaponRestrictionTypeEnum;
    'serieNumber': string;
    /**
    * Barrel's serial number. Número de série do cano 
    */
    'gunBarrelSerieNumber': string;
    /**
    * weapon description
    */
    'weaponDescription': string;
}

export namespace Weapon {
    export enum WeaponRestrictionTypeEnum {
        _0 = <any> '0',
        _1 = <any> '1'
    }
}
/**
* Using the placing reference in PCC for PIS (P), COFINS (C) and COFINS (C).  x = tax is not subject to withholding.  - 'xxx' - 'PCC' - 'PCx' - 'PxC' - 'Pxx' - 'xCC' - 'xxC' - 'xCx' 
*/
export class WithholdingMode {
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AGASTApiApiKeys {
}

export class AGASTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AGASTApiApiKeys, value: string) {
        this.authentications[AGASTApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return agast configurations that match with parameters queries 
     * @param code Agast Code
     */
    public agastsCodeGet (code: string) : Promise<{ response: http.ClientResponse; body: Agast;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling agastsCodeGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Agast;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create agast
     * This method operation create a AGAST 
     * @param body Transaction Message
     */
    public createAgast (body: Agast) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/agasts';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAgast.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param code Agast Code
     */
    public deleteAgast (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteAgast.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return agast configurations that match with parameters queries 
     * @param text Text query
     */
    public getAgastList (text?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }> {
        const localVarPath = this.basePath + '/agasts';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update agast
     * This method operation create a agast 
     * @param code Agast Code
     * @param body Transaction Message
     */
    public updateAgast (code: string, body: Agast) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateAgast.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountApiApiKeys {
}

export class AccountApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        this.authentications[AccountApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param accountId Account ID
     */
    public accountsAccountIdCompaniesGet (accountId: string) : Promise<{ response: http.ClientResponse; body: Array<AccountCompany>;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies'
            .replace('{' + 'accountId' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling accountsAccountIdCompaniesGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AccountCompany>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param accountId Account ID
     * @param body Company Code
     */
    public createAccountCompany (accountId: string, body: Body) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies'
            .replace('{' + 'accountId' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountCompany.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAccountCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddressApiApiKeys {
}

export class AddressApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AddressApiApiKeys, value: string) {
        this.authentications[AddressApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return address
     * @param zipcode ZIP Code
     */
    public getZipCode (zipcode: string) : Promise<{ response: http.ClientResponse; body: Array<Address>;  }> {
        const localVarPath = this.basePath + '/addresses/{zipcode}'
            .replace('{' + 'zipcode' + '}', String(zipcode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'zipcode' is not null or undefined
        if (zipcode === null || zipcode === undefined) {
            throw new Error('Required parameter zipcode was null or undefined when calling getZipCode.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Address>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthApiApiKeys {
}

export class AuthApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthApiApiKeys, value: string) {
        this.authentications[AuthApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Accepts \&quot;Basic + hash\&quot;, where hash is {user}:{password} base64 encoded. 
     */
    public authPost (authorization: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/auth';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling authPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Accepts \&quot;Basic + hash\&quot;, where hash is {user}:{password} base64 encoded. 
     */
    public v2AuthPost (authorization: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/v2/auth';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling v2AuthPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyApiApiKeys {
}

export class CompanyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyApiApiKeys, value: string) {
        this.authentications[CompanyApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve Companies by account
     * Retrieve list companies of one account
     */
    public companiesGet () : Promise<{ response: http.ClientResponse; body: Array<Company>;  }> {
        const localVarPath = this.basePath + '/companies';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Company>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param body Transaction Message
     */
    public createCompany (body: Company) : Promise<{ response: http.ClientResponse; body: Company;  }> {
        const localVarPath = this.basePath + '/companies';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Company;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param accountId Account ID
     * @param companyId Company ID
     */
    public deleteAccountCompany (accountId: string, companyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies/{companyId}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountCompany.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteAccountCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    public deleteCompany (companyId: string, companyId2: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCompany.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling deleteCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get company information and your data configuration
     * This method operation get a company for a account 
     * @param companyId Company ID
     */
    public infoCompany (companyId: string) : Promise<{ response: http.ClientResponse; body: Company;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling infoCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Company;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update company information and your data configuration
     * This method operation create a company for a account 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public updateCompany (companyId: string, body: Company) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCompany.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCompany.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyAGASTApiApiKeys {
}

export class CompanyAGASTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyAGASTApiApiKeys, value: string) {
        this.authentications[CompanyAGASTApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries - Alannes. 
     * @param companyId Company ID
     * @param code Agast Code
     * @param parent Agast parent code, means that this agast is a specialization of parent agast 
     */
    public companiesCompanyIdAgastsCodeGet (companyId: string, code: string, parent?: string) : Promise<{ response: http.ClientResponse; body: CustomAgast;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdAgastsCodeGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdAgastsCodeGet.');
        }

        if (parent !== undefined) {
            queryParameters['parent'] = parent;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomAgast;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param agast Custom Agast Code
     * @param parent Agast Code
     */
    public companiesCompanyIdAgastsGet (companyId: string, text?: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, agast?: string, parent?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdAgastsGet.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        if (parent !== undefined) {
            queryParameters['parent'] = parent;
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    public createCustomAgast (companyId: string, body: CustomAgast, text?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomAgast.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Agast Code
     */
    public deleteAgast (companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteAgast.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Agast Code
     * @param body Transaction Message
     */
    public updateCustomAgast (companyId: string, code: string, body: CustomAgast) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCustomAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomAgast.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyFilesApiApiKeys {
}

export class CompanyFilesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyFilesApiApiKeys, value: string) {
        this.authentications[CompanyFilesApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * Deletes a company file store.  
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    public companiesCompanyIdNfseCertificateDelete (companyId: string, companyId2: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/nfse-certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdNfseCertificateDelete.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling companiesCompanyIdNfseCertificateDelete.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Gets an existing NFSe certificate file for this company. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param peek Use this parameter to check the existence of the file without downloading it.
     */
    public companiesCompanyIdNfseCertificateGet (companyId: string, companyId2: string, peek?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/nfse-certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdNfseCertificateGet.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling companiesCompanyIdNfseCertificateGet.');
        }

        if (peek !== undefined) {
            queryParameters['peek'] = peek;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * If it still not exists, uploads a new NFSe Certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param body Content
     */
    public companiesCompanyIdNfseCertificatePost (companyId: string, body: Body3) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/nfse-certificate'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdNfseCertificatePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companiesCompanyIdNfseCertificatePost.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Updates an existing NFSe certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param body Content
     */
    public companiesCompanyIdNfseCertificatePut (companyId: string, companyId2: string, body: Body2) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/nfse-certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdNfseCertificatePut.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling companiesCompanyIdNfseCertificatePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companiesCompanyIdNfseCertificatePut.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyICMSApiApiKeys {
}

export class CompanyICMSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyICMSApiApiKeys, value: string) {
        this.authentications[CompanyICMSApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public companiesCompanyIdIcmsGet (companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomIcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdIcmsGet.');
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomIcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    public companiesCompanyIdIcmsStateGet (companyId: string, state: string) : Promise<{ response: http.ClientResponse; body: CustomIcmsConfByState;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdIcmsStateGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling companiesCompanyIdIcmsStateGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomIcmsConfByState;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom ICMS tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createICMS (companyId: string, body: CustomIcmsConfByState) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createICMS.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createICMS.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    public deleteCustomIcmsConfByState (companyId: string, state: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomIcmsConfByState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling deleteCustomIcmsConfByState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation update a custom ICMS tax for one company 
     * @param companyId Company ID
     * @param state Brazilian State
     * @param body Transaction Message
     */
    public updateCustomIcmsConfByState (companyId: string, state: string, body: CustomIcmsConfByState) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomIcmsConfByState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateCustomIcmsConfByState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomIcmsConfByState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemCPOMServiceApiApiKeys {
}

export class CompanyItemCPOMServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemCPOMServiceApiApiKeys, value: string) {
        this.authentications[CompanyItemCPOMServiceApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    public companiesCompanyIdItemsCodeCpomCityCodeGet (companyId: string, code: string, cityCode: number) : Promise<{ response: http.ClientResponse; body: ItemCpom;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodeCpomCityCodeGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodeCpomCityCodeGet.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling companiesCompanyIdItemsCodeCpomCityCodeGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemCpom;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public companiesCompanyIdItemsCodeCpomGet (companyId: string, code: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemCpom>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodeCpomGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodeCpomGet.');
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemCpom>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     */
    public createItemCPOM (companyId: string, code: string, body: ItemCpom) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling createItemCPOM.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItemCPOM.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    public deleteItemCPOM (companyId: string, code: string, cityCode: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItemCPOM.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling deleteItemCPOM.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     * @param body Transaction Message
     */
    public updateItemCPOM (companyId: string, code: string, cityCode: number, body: ItemCpom) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemCPOM.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemGoodsApiApiKeys {
}

export class CompanyItemGoodsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemGoodsApiApiKeys, value: string) {
        this.authentications[CompanyItemGoodsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    public companiesCompanyIdItemsCodeChangeCodePut (companyId: string, code: string, body: Body1, goods?: string, service?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/change-code'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        if (goods !== undefined) {
            queryParameters['goods'] = goods;
        }

        if (service !== undefined) {
            queryParameters['service'] = service;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    public companiesCompanyIdItemsCodegoodsGet (companyId: string, code: string, avalaraProductType: string, agast?: string) : Promise<{ response: http.ClientResponse; body: ItemGoods;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodegoodsGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodegoodsGet.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling companiesCompanyIdItemsCodegoodsGet.');
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemGoods;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    public companiesCompanyIdItemsgoodsGet (companyId: string, avalaraProductType: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, code?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemGoods>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?goods'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsgoodsGet.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling companiesCompanyIdItemsgoodsGet.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemGoods>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    public createItem (companyId: string, avalaraProductType: string, body: ItemGoods) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?goods'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling createItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItem.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    public deleteItem (companyId: string, code: string, avalaraProductType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling deleteItem.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    public updateItem (companyId: string, code: string, avalaraProductType: string, body: ItemGoods) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItem.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling updateItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItem.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemServiceApiApiKeys {
}

export class CompanyItemServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemServiceApiApiKeys, value: string) {
        this.authentications[CompanyItemServiceApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    public companiesCompanyIdItemsCodeChangeCodePut (companyId: string, code: string, body: Body1, goods?: string, service?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/change-code'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companiesCompanyIdItemsCodeChangeCodePut.');
        }

        if (goods !== undefined) {
            queryParameters['goods'] = goods;
        }

        if (service !== undefined) {
            queryParameters['service'] = service;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    public companiesCompanyIdItemsCodeserviceGet (companyId: string, code: string, avalaraProductType?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: ItemSimple;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsCodeserviceGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdItemsCodeserviceGet.');
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemSimple;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    public companiesCompanyIdItemsserviceGet (companyId: string, avalaraProductType?: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, code?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemSimple>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?service'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdItemsserviceGet.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemSimple>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    public createItemService (companyId: string, body: ItemSimple, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?service'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItemService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItemService.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    public deleteItemService (companyId: string, code: string, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItemService.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItemService.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    public updateItemService (companyId: string, code: string, body: ItemSimple, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItemService.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItemService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemService.');
        }

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyLocationApiApiKeys {
}

export class CompanyLocationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyLocationApiApiKeys, value: string) {
        this.authentications[CompanyLocationApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return location 
     * @param companyId Company ID
     * @param code Location Code
     */
    public companiesCompanyIdLocationsCodeGet (companyId: string, code: string) : Promise<{ response: http.ClientResponse; body: Location;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdLocationsCodeGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdLocationsCodeGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Location;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return all locations 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public companiesCompanyIdLocationsGet (companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<Location>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdLocationsGet.');
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Location>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create new location for company
     * This method operation create a new location for company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createLocation (companyId: string, body: Location) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLocation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Location Code
     */
    public deleteLocation (companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteLocation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update location for company
     * This method operation update a location for company 
     * @param companyId Company ID
     * @param code Location Code
     * @param body Transaction Message
     */
    public updateLocation (companyId: string, code: string, body: Location) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateLocation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyProcessApiApiKeys {
}

export class CompanyProcessApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyProcessApiApiKeys, value: string) {
        this.authentications[CompanyProcessApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Process Code
     */
    public companiesCompanyIdProcessCodeGet (companyId: string, code: string) : Promise<{ response: http.ClientResponse; body: CustomProcessScenario;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdProcessCodeGet.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companiesCompanyIdProcessCodeGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public companiesCompanyIdProcessGet (companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomProcessScenario>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdProcessGet.');
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomProcessScenario>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom process tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createCustomProcessScenario (companyId: string, body: CustomProcessScenario) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomProcessScenario.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomProcessScenario.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param code Process Code
     */
    public deleteCustomProcessScenario (companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomProcessScenario.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCustomProcessScenario.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation update a custom process for one company 
     * @param companyId Company ID
     * @param code Process Code
     * @param body Transaction Message
     */
    public updateCustomProcessScenario (companyId: string, code: string, body: CustomProcessScenario) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomProcessScenario.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCustomProcessScenario.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomProcessScenario.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyTaxRatesApiApiKeys {
}

export class CompanyTaxRatesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyTaxRatesApiApiKeys, value: string) {
        this.authentications[CompanyTaxRatesApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public companiesCompanyIdTaxratesGet (companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomTaxTypeRate>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdTaxratesGet.');
        }

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomTaxTypeRate>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    public companiesCompanyIdTaxratesTaxTypeGet (companyId: string, taxType: string) : Promise<{ response: http.ClientResponse; body: CustomTaxTypeRate;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companiesCompanyIdTaxratesTaxTypeGet.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling companiesCompanyIdTaxratesTaxTypeGet.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomTaxTypeRate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createCustomTaxes (companyId: string, body: CustomTaxTypeRate) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomTaxes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomTaxes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    public deleteCustomTaxes (companyId: string, taxType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomTaxes.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling deleteCustomTaxes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param taxType Tax Type
     * @param body Transaction Message
     */
    public updateCustomTaxes (companyId: string, taxType: string, body: CustomTaxTypeRate) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomTaxes.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling updateCustomTaxes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomTaxes.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoodsCalculationsApiApiKeys {
}

export class GoodsCalculationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GoodsCalculationsApiApiKeys, value: string) {
        this.authentications[GoodsCalculationsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsgoodsPurchasePost (authorization: string, body: TransactionForGoodsIn) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/calculations?goods-purchase';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsgoodsPurchasePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsgoodsPurchasePost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsgoodsSalesPost (authorization: string, body: TransactionForGoodsIn) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/calculations?goods-sales';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsgoodsSalesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsgoodsSalesPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoodsTransactionsApiApiKeys {
}

export class GoodsTransactionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GoodsTransactionsApiApiKeys, value: string) {
        this.authentications[GoodsTransactionsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsgoodsPurchasePost (authorization: string, body: TransactionForGoodsIn) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/transactions?goods-purchase';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsgoodsPurchasePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsgoodsPurchasePost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fields, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates the taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsgoodsSalesPost (authorization: string, body: TransactionForGoodsIn) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/transactions?goods-sales';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsgoodsSalesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsgoodsSalesPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceContingencyApiApiKeys {
}

export class InvoiceContingencyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceContingencyApiApiKeys, value: string) {
        this.authentications[InvoiceContingencyApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Invoice Drop Contingency per State
     * Drop State in Contingency
     * @param state Brazilian State
     */
    public invoiceDropContingency (state: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceDropContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invoice Set Contingency per State
     * Set State in Contingency
     * @param state Brazilian State
     * @param body Set Contingency
     */
    public invoiceSetContingency (state: string, body: Body4) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceSetContingency.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoiceSetContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invoice Verify Contingency per State
     * Check if State was in Contingency
     * @param state Brazilian State
     */
    public invoiceVerifyContingency (state: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceVerifyContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceNFCeDANFEApiApiKeys {
}

export class InvoiceNFCeDANFEApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceNFCeDANFEApiApiKeys, value: string) {
        this.authentications[InvoiceNFCeDANFEApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * NFCe Danfe Print
     * Retrieve the Danfe in NFCe format. 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public invoicesNfceKeyGet (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/invoices/nfce/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesNfceKeyGet.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling invoicesNfceKeyGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceNFeDANFEApiApiKeys {
}

export class InvoiceNFeDANFEApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceNFeDANFEApiApiKeys, value: string) {
        this.authentications[InvoiceNFeDANFEApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve Danfe
     * Retrieve the Danfe 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public nfePrint (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/invoices/nfe/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling nfePrint.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling nfePrint.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceSEFAZApiApiKeys {
}

export class InvoiceSEFAZApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceSEFAZApiApiKeys, value: string) {
        this.authentications[InvoiceSEFAZApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Disable Range e-Invoice
     * Send disable range of NFes to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Disable Range e-Invoice
     */
    public invoicesSefazDelete (authorization: string, body: SefazDisableRangeIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazDelete.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoicesSefazDelete.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel invoice
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    public invoicesSefazKeyDelete (authorization: string, key: string, body: SefazItDeleteIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazKeyDelete.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling invoicesSefazKeyDelete.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoicesSefazKeyDelete.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public invoicesSefazKeyGet (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: SefazItGetOut;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazKeyGet.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling invoicesSefazKeyGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazItGetOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public invoicesSefazKeyLookupGet (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: TransactionForSefazGoodsList;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}/lookup'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazKeyLookupGet.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling invoicesSefazKeyLookupGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForSefazGoodsList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Fix Letter
     * Fix Letter
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Fix Message
     */
    public invoicesSefazKeyPut (authorization: string, key: string, body: SefazItPutIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazKeyPut.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling invoicesSefazKeyPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoicesSefazKeyPut.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send an e-Invoice
     * Send a invoice to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    public invoicesSefazPost (authorization: string, body: Array<TransactionForSefazGoods>) : Promise<{ response: http.ClientResponse; body: SefazPostOut;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoicesSefazPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazPostOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Status of SEFAZ Server
     * Retrieve Status of SEFAZ Server
     * @param authorization Bearer {auth}
     */
    public invoicesSefazStatusGet (authorization: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/status';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling invoicesSefazStatusGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceSettingsApiApiKeys {
}

export class InvoiceSettingsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceSettingsApiApiKeys, value: string) {
        this.authentications[InvoiceSettingsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Invoice Settigns
     * Get Enviroment Settigns
     */
    public invoiceSettings () : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/invoices/settings';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LegalReasonApiApiKeys {
}

export class LegalReasonApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LegalReasonApiApiKeys, value: string) {
        this.authentications[LegalReasonApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Create Legal Reason.
     * 
     * @param body 
     */
    public createReason_ (body: LegalReason) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createReason_.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Legal Reason entry.
     * 
     * @param uuid 
     */
    public deleteReason_ (uuid: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason/{uuid}'
            .replace('{' + 'uuid' + '}', String(uuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling deleteReason_.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get single Legal Reason.
     * 
     * @param uuid 
     */
    public getReason_ (uuid: string) : Promise<{ response: http.ClientResponse; body: ProcessScenario;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason/{uuid}'
            .replace('{' + 'uuid' + '}', String(uuid));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getReason_.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Legal Reasons.
     * 
     * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
     */
    public listReason (companyId?: string) : Promise<{ response: http.ClientResponse; body: Array<LegalReason>;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (companyId !== undefined) {
            queryParameters['companyId'] = companyId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LegalReason>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Legal Reason.
     * 
     * @param body 
     */
    public updateReason_ (body: LegalReason) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateReason_.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceCalculationsApiApiKeys {
}

export class ServiceCalculationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ServiceCalculationsApiApiKeys, value: string) {
        this.authentications[ServiceCalculationsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet (authorization: string, accountId: string, companyCode: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Promote a calculation to transaction
     * Promote a calculation to transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost (authorization: string, accountId: string, companyCode: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}/transactions'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    public calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet (authorization: string, accountId: string, companyCode: string, transactionType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/account/{accountId}/company/{companyCode}/{transactionType}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsservicePaymentPost (authorization: string, body: PaymentTransactionIn) : Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-payment';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsservicePaymentPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsservicePaymentPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsservicePurchasePost (authorization: string, body: PurchaseTransactionIn) : Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-purchase';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsservicePurchasePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsservicePurchasePost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsserviceReceiptPost (authorization: string, body: ReceiptTransactionIn) : Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-receipt';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsserviceReceiptPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsserviceReceiptPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public calculationsserviceSalesPost (authorization: string, body: SalesTransactionIn) : Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-sales';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationsserviceSalesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationsserviceSalesPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceTransactionsApiApiKeys {
}

export class ServiceTransactionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ServiceTransactionsApiApiKeys, value: string) {
        this.authentications[ServiceTransactionsApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet (authorization: string, accountId: string, companyCode: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Transaction State Transition
     * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     * @param body Transaction Message
     */
    public transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost (authorization: string, accountId: string, companyCode: string, transactionType: string, documentCode: string, body: StateTransition) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}/stateTransitions'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    public transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet (authorization: string, accountId: string, companyCode: string, transactionType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/account/{accountId}/company/{companyCode}/{transactionType}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyCode' + '}', String(companyCode))
            .replace('{' + 'transactionType' + '}', String(transactionType));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'companyCode' is not null or undefined
        if (companyCode === null || companyCode === undefined) {
            throw new Error('Required parameter companyCode was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsservicePaymentPost (authorization: string, body: PaymentTransactionIn) : Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-payment';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsservicePaymentPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsservicePaymentPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsservicePurchasePost (authorization: string, body: PurchaseTransactionIn) : Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-purchase';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsservicePurchasePost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsservicePurchasePost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsserviceReceiptPost (authorization: string, body: ReceiptTransactionIn) : Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-receipt';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsserviceReceiptPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsserviceReceiptPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionsserviceSalesPost (authorization: string, body: SalesTransactionIn) : Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-sales';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionsserviceSalesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionsserviceSalesPost.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfCFOPApiApiKeys {
}

export class TaxConfCFOPApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfCFOPApiApiKeys, value: string) {
        this.authentications[TaxConfCFOPApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new CFOP configuration
     * 
     * @param body The pet JSON you want to post
     */
    public createCfop (body: CfopConf) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCfop.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a CFOP.
     * 
     * @param code CFOP Code
     */
    public deleteCfop (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCfop.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get CFOP information.
     * This operation return CFOP configuration 
     * @param code CFOP Code
     */
    public getCfop (code: string) : Promise<{ response: http.ClientResponse; body: CfopConf;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCfop.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CfopConf;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of CFOP.
     * This operation return CFOP configurations that match with parameters queries 
     * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getCfopList (suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<CfopConf>;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CfopConf>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a CFOP configuration
     * 
     * @param code CFOP Code
     * @param taxconfcfop The pet JSON you want to post
     */
    public updateCfop (code: string, taxconfcfop: CfopConf) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCfop.');
        }

        // verify required parameter 'taxconfcfop' is not null or undefined
        if (taxconfcfop === null || taxconfcfop === undefined) {
            throw new Error('Required parameter taxconfcfop was null or undefined when calling updateCfop.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfcfop,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfIBPTApiApiKeys {
}

export class TaxConfIBPTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfIBPTApiApiKeys, value: string) {
        this.authentications[TaxConfIBPTApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new Process Type configuration
     * 
     * @param taxconfprocess The pet JSON you want to post
     */
    public createIbptConf (taxconfprocess: IbptConf) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling createIbptConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a IBPT.
     * 
     * @param code IBPT Code
     */
    public deleteIbptConf (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteIbptConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get IBPT information.
     * This operation return Process Type configuration 
     * @param code IBPT Code
     */
    public getIbptConf (code: string) : Promise<{ response: http.ClientResponse; body: IbptConf;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getIbptConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IbptConf;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of IBPT.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getIbptConfList (accountId?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IbptConf>;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accountId !== undefined) {
            queryParameters['accountId'] = accountId;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IbptConf>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a Process Type configuration
     * 
     * @param code IBPT Code
     * @param taxconfprocess The pet JSON you want to post
     */
    public updateIbptConf (code: string, taxconfprocess: IbptConf) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateIbptConf.');
        }

        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling updateIbptConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfICMSApiApiKeys {
}

export class TaxConfICMSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfICMSApiApiKeys, value: string) {
        this.authentications[TaxConfICMSApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new ICMS Configuration
     * 
     * @param state Brazilian State
     * @param icmsConfState The pet JSON you want to post
     */
    public createIcmsconfstate (state: string, icmsConfState: IcmsConfByState) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling createIcmsconfstate.');
        }

        // verify required parameter 'icmsConfState' is not null or undefined
        if (icmsConfState === null || icmsConfState === undefined) {
            throw new Error('Required parameter icmsConfState was null or undefined when calling createIcmsconfstate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: icmsConfState,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a ICMS by State.
     * 
     * @param state Brazilian State
     * @param code ICMS Code
     */
    public deleteIcmsConf (state: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling deleteIcmsConf.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteIcmsConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get ICMS information by State.
     * This operation return configurations of icms that match with parameters queries 
     * @param state Brazilian State
     * @param code ICMS Code
     */
    public getIcmsConfByState (state: string, code: string) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling getIcmsConfByState.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getIcmsConfByState.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param state Brazilian State
     * @param suffixcode Identify this ICMS
     * @param date When informed return valid version configuration for this date
     * @param inactive return the inactive versions too
     */
    public getIcmsList (state: string, suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling getIcmsList.');
        }

        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param text Search for codes
     * @param state Filter for states
     */
    public getIcmsList_1 (text: string, state?: string) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms-search/';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'text' is not null or undefined
        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling getIcmsList_1.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a IcmsConf State,
     * 
     * @param state Brazilian State
     * @param code ICMS Code
     * @param icmsConfState The pet JSON you want to post
     */
    public updateIcmsconfstate (state: string, code: string, icmsConfState: IcmsConfByState) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateIcmsconfstate.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateIcmsconfstate.');
        }

        // verify required parameter 'icmsConfState' is not null or undefined
        if (icmsConfState === null || icmsConfState === undefined) {
            throw new Error('Required parameter icmsConfState was null or undefined when calling updateIcmsconfstate.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: icmsConfState,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfISSApiApiKeys {
}

export class TaxConfISSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfISSApiApiKeys, value: string) {
        this.authentications[TaxConfISSApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new ISS Configuration
     * 
     * @param issConfByCity The pet JSON you want to post
     */
    public createIssConfByCity (issConfByCity: IssConfByCity) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/iss';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'issConfByCity' is not null or undefined
        if (issConfByCity === null || issConfByCity === undefined) {
            throw new Error('Required parameter issConfByCity was null or undefined when calling createIssConfByCity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: issConfByCity,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a ISS by City Code.
     * 
     * @param cityCode City Code
     */
    public deleteIssConf (cityCode: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling deleteIssConf.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get ISS information by City Code.
     * This operation return configurations of ISS that match with parameters queries 
     * @param cityCode City Code
     * @param code Identificator of this configuration, it is unique for account or standard namedspace 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inctives versions too 
     */
    public getIssConfByCity (cityCode: number, code?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling getIssConfByCity.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ISS
     * This operation return ISS configurations that match with parameters queries 
     * @param suffixcode Identify this ISS 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getIssList (suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }> {
        const localVarPath = this.basePath + '/taxconf/iss';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a ISS by City Code.
     * 
     * @param cityCode City Code
     * @param issConfByCity The pet JSON you want to post
     */
    public updateIssConfByCity (cityCode: number, issConfByCity: IssConfByCity) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling updateIssConfByCity.');
        }

        // verify required parameter 'issConfByCity' is not null or undefined
        if (issConfByCity === null || issConfByCity === undefined) {
            throw new Error('Required parameter issConfByCity was null or undefined when calling updateIssConfByCity.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: issConfByCity,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfProcessApiApiKeys {
}

export class TaxConfProcessApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfProcessApiApiKeys, value: string) {
        this.authentications[TaxConfProcessApiApiKeys[key]].apiKey = value;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * create a new Process Type configuration
     * 
     * @param taxconfprocess The pet JSON you want to post
     */
    public createProcess (taxconfprocess: ProcessScenario) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/process';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling createProcess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a Process.
     * 
     * @param code Process Code
     */
    public deleteProcess (code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteProcess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get Process information.
     * This operation return Process Type configuration 
     * @param code Process Code
     */
    public getProcess (code: string) : Promise<{ response: http.ClientResponse; body: ProcessScenario;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getProcess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of Process.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getProcessList (accountId?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<ProcessScenario>;  }> {
        const localVarPath = this.basePath + '/taxconf/process';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accountId !== undefined) {
            queryParameters['accountId'] = accountId;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ProcessScenario>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a Process Type configuration
     * 
     * @param code Process Code
     * @param taxconfprocess The pet JSON you want to post
     */
    public updateProcess (code: string, taxconfprocess: ProcessScenario) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateProcess.');
        }

        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling updateProcess.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
