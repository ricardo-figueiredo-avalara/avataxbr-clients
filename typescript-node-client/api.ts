/**
 * AvaTax Brazil
 * The Avatax-Brazil API exposes the most commonly services available for interacting with the AvaTax-Brazil services, allowing calculation of taxes, issuing electronic invoice documents and modifying existing transactions when allowed by tax authorities.  This API is exclusively for use by business with a physical presence in Brazil.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://avataxbr-sandbox.avalarabrasil.com.br/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AbrasfItDeleteIn {
    /**
    * Cancel Code
    */
    'code': string;
}

export class AbrasfItGetOut {
    /**
    * Invoice Access Key
    */
    'key': string;
    /**
    * XML Signed
    */
    'xml': string;
}

export class AbrasfPostOut {
    /**
    * Invoice Access Key
    */
    'key': string;
    'xml': string;
}

export class AccountCompany {
    'companyId': string;
    'companyCode': string;
    'companyName': string;
}

export class AdditionalInformation {
    /**
    * Additional information of fiscal interest
    */
    'fiscalInfo': string;
    /**
    * Additional information of user interest
    */
    'complementaryInfo': string;
    /**
    * Referenced Process
    */
    'procRef': Array<AdditionalInformationProcRef>;
}

export class AdditionalInformationProcRef {
    /**
    * Process Identifier
    */
    'nProc': string;
    /**
    * Process Origin - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
    */
    'indProc': AdditionalInformationProcRef.IndProcEnum;
}

export namespace AdditionalInformationProcRef {
    export enum IndProcEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _9 = <any> '9'
    }
}
export class Address {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

export class Agast {
    /**
    * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
    */
    'code': string;
    /**
    * Agast Description
    */
    'description': string;
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    'codeType': AgastCodeType;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'N'  # NO TAXABLE     - 'I'  # IMMUNE 
    */
    'cstIPI': Agast.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * when the company is Real Profit inform if this item is cumulative or no cumulative by default
    */
    'pisCofinsTaxReporting': Agast.PisCofinsTaxReportingEnum;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruablePISTaxation': Agast.AccruablePISTaxationEnum;
    /**
    * Reference to a tax exemption reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruableCOFINSTaxation': Agast.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
    */
    'accruableCSLLTaxation': Agast.AccruableCSLLTaxationEnum;
    'csllExemptLegalReason': string;
    'csllExemptLegalReasonCode': string;
    'withholding': AgastWithholding;
    /**
    * for service items with City Jurisdiction, inform where the ISS tax is due
    */
    'issDueatDestination': boolean;
    /**
    * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
    */
    'pisCofinsCreditNotAllowed': boolean;
    /**
    * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
    */
    'issTaxation': Agast.IssTaxationEnum;
    /**
    * This is an array of tax object related to an agast.
    */
    'federalTaxRate': Array<TaxTypeRate>;
    'specialProductClass': Agast.SpecialProductClassEnum;
    /**
    * One per State
    */
    'icmsConf': Array<AgastIcmsConf>;
    /**
    * Sujeito à desoneração de folha de pagamento.
    */
    'subjectToPayrollExemption': boolean;
}

export namespace Agast {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        N = <any> 'N',
        I = <any> 'I'
    }
    export enum PisCofinsTaxReportingEnum {
        Cumulative = <any> 'cumulative',
        NoCumulative = <any> 'noCumulative'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum IssTaxationEnum {
        T = <any> 'T',
        E = <any> 'E',
        F = <any> 'F',
        A = <any> 'A',
        L = <any> 'L',
        I = <any> 'I'
    }
    export enum SpecialProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRICANT = <any> 'FUEL AND LUBRICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUME = <any> 'PERFUME',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class AgastCodeType {
    /**
    * - 'NCM' - 'NBS' - 'LC116' - 'SERVICE UNREGULATED' 
    */
    'code': number;
    'name': AgastCodeType.NameEnum;
}

export namespace AgastCodeType {
    export enum NameEnum {
        NCM = <any> 'NCM',
        NBS = <any> 'NBS',
        LC116 = <any> 'LC116',
        SERVICEUNREGULATED = <any> 'SERVICE UNREGULATED'
    }
}
export class AgastExtendForSefaz {
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    /**
    * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
    */
    'nve': string;
    /**
    * Sales Unit
    */
    'unit': string;
    /**
    * Sales Taxable Unit
    */
    'unitTaxable': string;
    /**
    * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
    */
    'nFCI': string;
    /**
    * - 'Normal' # Normal - 'Complementary' # Complemento de Valores - 'Voided' # Anulação - 'Replacement' # Substituto - 'Return' # Devolução ou retorno - 'Adjustment' # Ajuste 
    */
    'goal': AgastExtendForSefaz.GoalEnum;
}

export namespace AgastExtendForSefaz {
    export enum GoalEnum {
        Normal = <any> 'Normal',
        Complementary = <any> 'Complementary',
        Voided = <any> 'Voided',
        Replacement = <any> 'Replacement',
        Return = <any> 'Return',
        Adjustment = <any> 'Adjustment'
    }
}
/**
* See definitions IcmsConfByState
*/
export class AgastIcmsConf {
    'code': string;
    'state': StateEnum;
}

/**
* inform if this item is subject to withholding tax on service Transactions, default true
*/
export class AgastWithholding {
    'iRRF': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iRRFLegalReason': string;
    /**
    * Item subjecto to payroll discharge Item sujeto à desoneraçãode folha de pagamento 
    */
    'iNSSSubjectToDischarge': boolean;
    'iNSS': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iNSSLegalReason': string;
    'iNSsForSimples': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'iNSSForSimplesLegalReason': string;
    'pIS': AgastWithholdingPIS;
    'cOFINS': AgastWithholdingCOFINS;
    'cSLL': AgastWithholdingCSLL;
}

/**
* inform if this item is subject to withholding COFINS on service Transactions, by entity type, default true
*/
export class AgastWithholdingCOFINS {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

/**
* inform if this item is subject to withholding CSLL on service Transactions, by entity type, default true
*/
export class AgastWithholdingCSLL {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

/**
* inform if this item is subject to withholding PIS on service Transactions, by entity type, default true
*/
export class AgastWithholdingPIS {
    'legalReason': string;
    'business': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'businessLegalReason': string;
    'federalGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'federalGovernmentLegalReason': string;
    'stateGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'stateGovernmentLegalReason': string;
    'cityGovernment': boolean;
    /**
    * reference id to TaxLegalReason
    */
    'cityGovernmentLegalReason': string;
}

export class Body {
    'companyCode': string;
}

export class Body1 {
    /**
    * Destination code.
    */
    'newCode': string;
}

export class Body2 {
    'content': string;
}

export class Body3 {
    'content': string;
}

export class Body4 {
    'startDate': Date;
    'finishDate': Date;
}

/**
* Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '01' # Operação Tributável com Alíquota Básica - '02' # Operação Tributável com Alíquota Diferenciada - '03' # Operação Tributável com Alíquota por Unidade de Medida de Produto - '04' # Operação Tributável Monofásica - 'Revenda a Alíquota Zero - '05' # Operação Tributável por Substituição Tributária - '06' # Operação Tributável a Alíquota Zero - '07' # Operação Isenta da Contribuição - '08' # Operação sem Incidência da Contribuição - '09' # Operação com Suspensão da Contribuição - '49' # Outras Operações de Saída - '50' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '51' # Operação com Direito a Crédito – Vinculada Exclusivamente a Receita Não Tributada no Mercado Interno - '52' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita de Exportação - '53' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '54' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '55' # Operação com Direito a Crédito - 'Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '56' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '60' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '61' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Não-Tributada no Mercado Interno - '62' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita de Exportação - '63' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '64' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '65' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '66' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '67' # Crédito Presumido - 'Outras Operações - '70' # Operação de Aquisição sem Direito a Crédito - '71' # Operação de Aquisição com Isenção - '72' # Operação de Aquisição com Suspensão - '73' # Operação de Aquisição a Alíquota Zero - '74' # Operação de Aquisição sem Incidência da Contribuição - '75' # Operação de Aquisição por Substituição Tributária - '98' # Outras Operações de Entrada - '99' # Outras Operações 
*/
export class CSTPistCofinsEnum {
}

/**
* Source of product or merchandise, - '0' # National goods - 'except those treated in codes 3,4, 5 and 8 - '1' # Imported directly by seller, except those in code 6 - '2' # Foreign goods - 'Acquired in the internal market (inside Brazil), except those in code 7 - '3' # Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - 'Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - 'Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - 'Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # Merchandise or goods with imported content above 70% 
*/
export class CSTTableAEnum {
}

/**
* Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '00' # Taxed in its totality - '10' # Taxed and subject to tax substitution (ICMS ST) - '20' # Taxed with Tax Base Reduction - '30' # Exempt /Not Taxed and subject to tax Substitution (ICMS#ST) - '40' # Tax Exempt - '41' # Not Taxed - '50' # Taxes Suspended - '51' # Taxes Diferred - '60' # ICMS Tax already collected through Substituition (ICMS ST) - '70' # Taxed with Tax Base Reduction and subject to Tax Subsititution (ICMS ST) - '90' # Others 
*/
export class CSTTableBEnum {
}

export class CalcModelEnum {
}

export class CalculatedTaxSummaryForGoods {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line taxed discounts
    */
    'taxedDiscount': number;
    /**
    * sum of all line untaxed discounts
    */
    'untaxedDiscount': number;
    /**
    * sum of all line lineAmount attribute
    */
    'subtotal': number;
    /**
    * sum of all line tax attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute + sum of all line tax attribute not VAT - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': CalculatedTaxSummaryForGoodsTaxByType;
}

export class CalculatedTaxSummaryForGoodsTaxByType {
    'icms': TaxByTypeSummaryForGoods;
    'icmsSt': TaxByTypeSummaryForGoods;
    'icmsStSd': TaxByTypeSummaryForGoods;
    'icmsPartOwn': TaxByTypeSummaryForGoods;
    'icmsPartDest': TaxByTypeSummaryForGoods;
    'icmsDifaFCP': TaxByTypeSummaryForGoods;
    'icmsDifaDest': TaxByTypeSummaryForGoods;
    'icmsDifaRemet': TaxByTypeSummaryForGoods;
    'icmsRf': TaxByTypeSummaryForGoods;
    'icmsDeson': TaxByTypeSummaryForGoods;
    'icmsCredsn': TaxByTypeSummaryForGoods;
    'pis': TaxByTypeSummaryForGoods;
    'pisSt': TaxByTypeSummaryForGoods;
    'cofins': TaxByTypeSummaryForGoods;
    'cofinsSt': TaxByTypeSummaryForGoods;
    'ipi': TaxByTypeSummaryForGoods;
    'ipiReturned': TaxByTypeSummaryForGoods;
    'ii': TaxByTypeSummaryForGoods;
    'iof': TaxByTypeSummaryForGoods;
    'aproxtribState': TaxByTypeSummaryForGoods;
    'aproxtribFed': TaxByTypeSummaryForGoods;
}

export class CfopConf {
    /**
    * main unique identificator
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': CfopConf.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': CfopConf.AccruablePISTaxationEnum;
    /**
    * Reference to a tax reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': CfopConf.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    'name': string;
    'description': string;
    /**
    * inform if the transaction is an operation to internalizing item or value
    */
    'wayType': CfopConf.WayTypeEnum;
    /**
    * CFOP code (tax code operation) when the transactions are within the same state.
    */
    'codInState': number;
    /**
    * CFOP code (tax code operation) when the transactions are to another state.
    */
    'codOtherState': number;
    /**
    * CFOP code (tax code operation) when the transactions are to another country.
    */
    'codOtherCountry': number;
    'cstICMSSameState': CstIcmsEnum;
    'cstICMSOtherState': CstIcmsEnum;
    'cstICMSOtherCountry': CstIcmsEnum;
    /**
    * this field is used to define right CFOP, one operation type can be specialized to item product, item merchandise or generic
    */
    'productType': CfopConf.ProductTypeEnum;
    /**
    * field used to indicate an operation to ICMS tax payer
    */
    'operationToTaxPayerOtherState': boolean;
    /**
    * field used to indicate an operation to items sibject to ICMS-ST
    */
    'operationWithST': boolean;
    /**
    * field used to indicate an operation to free zone
    */
    'operationToFreeZone': boolean;
    /**
    * field used to indicate an operation to some product class specifically
    */
    'specificForProductClass': CfopConf.SpecificForProductClassEnum;
}

export namespace CfopConf {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum ProductTypeEnum {
        FORPRODUCT = <any> 'FOR PRODUCT',
        FORMERCHANDISE = <any> 'FOR MERCHANDISE',
        NORESTRICTION = <any> 'NO RESTRICTION'
    }
    export enum SpecificForProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRICANT = <any> 'FUEL AND LUBRICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUME = <any> 'PERFUME',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class Company {
    /**
    * string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
    */
    'code': string;
    /**
    * Official Company name (Razão Social)
    */
    'officialName': string;
    /**
    * Company name (DBA - Nome de Fantasia),  Used to identify branches/subsidiaries with same name
    */
    'name': string;
    'entityType': EntityType;
    /**
    * Company has participation of state-owned capital (it will be considerated like a government entity)
    */
    'subjectToSRF1234': boolean;
    'federalTaxRegime': FederalTaxRegime;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'pisSubjectTo': Company.PisSubjectToEnum;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'cofinsSubjectTo': Company.CofinsSubjectToEnum;
    /**
    * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
    */
    'csllSubjectTo': Company.CsllSubjectToEnum;
    /**
    * When th company is REAL PROFIT usually it operates under a Non-Cumulative PIS/COFINS regime But exist some services that are always Cumulative regime. If the company has all receipts from Non-Cumulative services this flag will be set to True. This flag informs special conditions to credit of PIS/COFINS when this company is out of Free zone and  purchases from Free Zone Company Quando uma empresa fora da Zona Franca adquire uma produto ou serviço de uma empresa situada na Zona Franca de Manaus, o crédito de PIS E COFINS segue estas aliquotas diferenciadas. Fundamentação, art. 5º da Instrução Normativa SRF nº 546/2005; art. 3º, § 12 da Lei nº 10.637/2002; art. 3º, § 17 da Lei nº 10.833/2003; art. 4º da Lei nº 11.307/2006. DESTINATÁRIO ALÍQUOTAS PIS COFINS a) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure a Contribuição para o PIS/PASEP no regime de não-cumulatividade débito 0,65% 3% crédito 1% 4,6% c) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure o imposto de renda com base no lucro real e que tenha sua receita, total ou parcialmente, excluída do regime de incidência não-cumulativa da Contribuição para o PIS/PASEP débito 1,3% 6% crédito 1,65% 7,6% 
    */
    'receiptsAreFullNoCumulativePisCofins': boolean;
    /**
    * On purchase transaction, to force withholding INSS this Flag can be set to True
    */
    'inssWithholdSubjectTo': boolean;
    /**
    * On purchase transaction, to force withhold ISS this Flag can be set to True
    */
    'issWithholdSubjectTo': boolean;
    /**
    * On purchase transaction, if this flag is FALSE, the system will not withhold IRRF. if this flag is TRUE the system will analise other rules to define if will have witholding 
    */
    'irrfWithholdSubjectTo': boolean;
    /**
    * Actual ICMS Rate for this company (if the company is Tax Regime Simplified). Aliquota de ICMS da companhia caso Optante do Simples 
    */
    'icmsRateForSimplestaxregime': number;
    /**
    * ICMS Exempt when Tax Regime is Simplified because total gross revenue is bellow amount defined by state (see PARANÁ State) Isenção do ICMS no Simples Nacional para faixa de receita bruta 
    */
    'isExemptByGrossRevenueForSimplestaxregime': boolean;
    /**
    * Sujeito à desoneração de folha de pagamento.
    */
    'subjectToPayrollExemption': boolean;
    'configuration': CompanyConfiguration;
    'mailServer': CompanyMailServer;
    /**
    * Person or company authorized to downloadNFe
    */
    'authorizedToDownloadNFe': Array<CompanyAuthorizedToDownloadNFe>;
}

export namespace Company {
    export enum PisSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
    export enum CofinsSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
    export enum CsllSubjectToEnum {
        TAXABLE = <any> 'TAXABLE',
        NOTTAXABLE = <any> 'NOT TAXABLE',
        EXEMPT = <any> 'EXEMPT'
    }
}
export class CompanyAuthorizedToDownloadNFe {
    /**
    * Federal tax id, CNPJ or CPF
    */
    'federalTaxId': string;
}

export class CompanyConfiguration {
    /**
    * digital certificate A1 model, p12, encoded by base64
    */
    'certificate': string;
    /**
    * certificate password
    */
    'certificatepwd': string;
    /**
    * expiration date of this certificate
    */
    'certificateexpiration': Date;
    /**
    * company logo image encoded by base64
    */
    'logo': string;
    /**
    * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; 
    */
    'tpImpNFe': CompanyConfiguration.TpImpNFeEnum;
    /**
    * how the document will be printed - '0' # without DANFE; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
    */
    'tpImpNFCe': CompanyConfiguration.TpImpNFCeEnum;
}

export namespace CompanyConfiguration {
    export enum TpImpNFeEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2'
    }
    export enum TpImpNFCeEnum {
        _0 = <any> '0',
        _4 = <any> '4',
        _5 = <any> '5'
    }
}
export class CompanyMailServer {
    /**
    * User for login on email server
    */
    'user': string;
    /**
    * Password to login on email server
    */
    'password': string;
    /**
    * smtp address to email server
    */
    'smtpAddress': string;
    /**
    * port
    */
    'port': number;
    /**
    * email address to identify the sender e-mail, to send a XML and DANFE
    */
    'emailFrom': string;
    /**
    * protocol SSL or TLS
    */
    'protocol': CompanyMailServer.ProtocolEnum;
    /**
    * Message to add to email body
    */
    'templatemessageToEmail': string;
}

export namespace CompanyMailServer {
    export enum ProtocolEnum {
        Ssl = <any> 'ssl',
        Tls = <any> 'tls'
    }
}
/**
* On sales process inform the CST that the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
*/
export class CstIcmsEnum {
}

export class CsvIbptList extends Array<Array> {
}

export class CustomAgast {
    /**
    * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
    */
    'code': string;
    /**
    * Agast Description
    */
    'description': string;
    /**
    * harmonized code, NCM or LC 116
    */
    'hsCode': string;
    /**
    * hsCode Exception for IPI tax
    */
    'ex': number;
    /**
    * tax substitution code - Codigo especificador da Substuicao Tributaria
    */
    'cest': string;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    'codeType': AgastCodeType;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'N'  # NO TAXABLE     - 'I'  # IMMUNE 
    */
    'cstIPI': CustomAgast.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * when the company is Real Profit inform if this item is cumulative or no cumulative by default
    */
    'pisCofinsTaxReporting': CustomAgast.PisCofinsTaxReportingEnum;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruablePISTaxation': CustomAgast.AccruablePISTaxationEnum;
    /**
    * Reference to a tax exemption reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
    */
    'accruableCOFINSTaxation': CustomAgast.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero rate, suspended, not taxable, this field informs the official code number for the exemption
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specified a reason, this field holds the reason's description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
    */
    'accruableCSLLTaxation': CustomAgast.AccruableCSLLTaxationEnum;
    'csllExemptLegalReason': string;
    'csllExemptLegalReasonCode': string;
    'withholding': AgastWithholding;
    /**
    * for service items with City Jurisdiction, inform where the ISS tax is due
    */
    'issDueatDestination': boolean;
    /**
    * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
    */
    'pisCofinsCreditNotAllowed': boolean;
    /**
    * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
    */
    'issTaxation': CustomAgast.IssTaxationEnum;
    /**
    * This is an array of tax object related to an agast.
    */
    'federalTaxRate': Array<TaxTypeRate>;
    'specialProductClass': CustomAgast.SpecialProductClassEnum;
    /**
    * One per State
    */
    'icmsConf': Array<AgastIcmsConf>;
    /**
    * Sujeito à desoneração de folha de pagamento.
    */
    'subjectToPayrollExemption': boolean;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomAgast {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        N = <any> 'N',
        I = <any> 'I'
    }
    export enum PisCofinsTaxReportingEnum {
        Cumulative = <any> 'cumulative',
        NoCumulative = <any> 'noCumulative'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum IssTaxationEnum {
        T = <any> 'T',
        E = <any> 'E',
        F = <any> 'F',
        A = <any> 'A',
        L = <any> 'L',
        I = <any> 'I'
    }
    export enum SpecialProductClassEnum {
        OTHERS = <any> 'OTHERS',
        COMMUNICATION = <any> 'COMMUNICATION',
        ENERGY = <any> 'ENERGY',
        TRANSPORT = <any> 'TRANSPORT',
        FUELANDLUBRICANT = <any> 'FUEL AND LUBRICANT',
        VEHICLE = <any> 'VEHICLE',
        ALCOHOLICBEVERAGES = <any> 'ALCOHOLIC BEVERAGES',
        WEAPONS = <any> 'WEAPONS',
        AMMO = <any> 'AMMO',
        PERFUME = <any> 'PERFUME',
        TOBACCO = <any> 'TOBACCO'
    }
}
export class CustomIcmsConfByState {
    /**
    * Identify the IcmsConfState in namespace
    */
    'code': string;
    'state': StateEnum;
    /**
    * name for this configuration
    */
    'name': string;
    /**
    * date when this configuration values starts
    */
    'startDate': Date;
    /**
    * date when this configuration values expire
    */
    'expirationDate': Date;
    /**
    * set this configuration to Inactive
    */
    'inactive': boolean;
    /**
    * inform that the item linked to this configuration is subject to ICMS ST on this state
    */
    'subjectToST': boolean;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': CustomIcmsConfByState.IcmsCSTEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': CustomIcmsConfByState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS for transactions inside state
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    /**
    * Fundo de Combate à pobreza / Fund Against Poverty
    */
    'fcpRate': number;
    'icmsSTConf': IcmsConfByStateIcmsSTConf;
    /**
    * the map key is state code
    */
    'icmsInterStateConf': Array<IcmsConfInterState>;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomIcmsConfByState {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class CustomProcessScenario {
    /**
    * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': CustomProcessScenario.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': CustomProcessScenario.AccruablePISTaxationEnum;
    /**
    * Reference to a tax reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': CustomProcessScenario.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    /**
    * Process name to Identify this configuration
    */
    'name': string;
    'type': CustomProcessScenario.TypeEnum;
    /**
    * inform if the transaction is an operation to internalizing (receive) item or value
    */
    'wayType': CustomProcessScenario.WayTypeEnum;
    /**
    * - 'Normal' # Normal - 'Complementary' # Complemento de Valores - 'Voided' # Anulação - 'Replacement' # Substituto - 'Return' # Devolução ou retorno - 'Adjustment' # Ajuste 
    */
    'goal': CustomProcessScenario.GoalEnum;
    /**
    * inform that the configuration process overwrites the cfop configuration.
    */
    'overWriteCFOP': boolean;
    'cfops': Array<CfopConf>;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomProcessScenario {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum TypeEnum {
        SALES = <any> 'SALES',
        PURCHASE = <any> 'PURCHASE',
        SALESRETURN = <any> 'SALES_RETURN',
        PURCHASERETURN = <any> 'PURCHASE_RETURN',
        TRANSFERRETURN = <any> 'TRANSFER_RETURN',
        SHIPPING = <any> 'SHIPPING',
        SHIPPINGRETURN = <any> 'SHIPPING_RETURN',
        TRANSFER = <any> 'TRANSFER',
        RECEIPTAJUSTE = <any> 'RECEIPT_AJUSTE',
        TRANSFERAJUSTE = <any> 'TRANSFER_AJUSTE'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum GoalEnum {
        Normal = <any> 'Normal',
        Complementary = <any> 'Complementary',
        Voided = <any> 'Voided',
        Replacement = <any> 'Replacement',
        Return = <any> 'Return',
        Adjustment = <any> 'Adjustment'
    }
}
export class CustomTaxTypeRate {
    'taxType': TaxType;
    /**
    * Tax can be calculated by rate or by quantity
    */
    'taxModel': CustomTaxTypeRate.TaxModelEnum;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'rate': number;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'srvAmount': number;
    'quantityUnidBase': string;
    'specializationType': CustomTaxTypeRate.SpecializationTypeEnum;
    /**
    * Company ID
    */
    'companyId': string;
}

export namespace CustomTaxTypeRate {
    export enum TaxModelEnum {
        Rate = <any> 'rate',
        Srf = <any> 'srf'
    }
    export enum SpecializationTypeEnum {
        Basic = <any> 'basic',
        Monophase = <any> 'monophase',
        TaxSubstitution = <any> 'taxSubstitution'
    }
}
/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. These locations may be overridden within each line item. The key for each location in the dictionary is the location 'purpose'. Valid locations purposes are 'ShipFrom', 'ShipTo', 'POS', 'POM', 'POO', 'BillingLocation', 'CallPlaced', 'CallReceived', 'ServiceRendered', 'POA' and 'FirstUse'. There can only be one location of a given purpose in the dictionary.
*/
export class DefaultLocations {
    'entity': EntityLocation;
    'company': EntityLocation;
    'transporter': EntityLocation;
    'deliveryLocation': EntityLocation;
    'pickupLocation': EntityLocation;
}

export class DetailsCalculatedTax {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': DetailsCalculatedTax.JurisdictionTypeEnum;
    /**
    * Tax identificator
    */
    'taxType': DetailsCalculatedTax.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule
    */
    'taxRuleType': DetailsCalculatedTax.TaxRuleTypeEnum;
}

export namespace DetailsCalculatedTax {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof',
        AproxtribState = <any> 'aproxtribState',
        AproxtribFed = <any> 'aproxtribFed',
        Aproxtrib = <any> 'aproxtrib'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class DetailsCalculatedTaxItem {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': DetailsCalculatedTaxItem.JurisdictionTypeEnum;
    /**
    * Tax identificator
    */
    'taxType': DetailsCalculatedTaxItem.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule
    */
    'taxRuleType': DetailsCalculatedTaxItem.TaxRuleTypeEnum;
    'source': CSTTableAEnum;
    'cstB': CSTTableBEnum;
    'cst': string;
    'modBC': string;
    /**
    * Percent of Value-added margin (%)
    */
    'pMVA': number;
    /**
    * calc base percent of discount
    */
    'pRedBC': number;
    /**
    * percent of calc base of own icms
    */
    'pBCOp': number;
    'ufst': StateEnum;
    'calcMode': CalcModelEnum;
    /**
    * Legal tax classificação for IPI (enquadramento tributário)
    */
    'legalTaxClass': number;
    /**
    * Legal tax classificação for IPI (enquadramento) for Drinks and Cigarettes
    */
    'legalTaxClassDC': number;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}' Federal tax ID of real manufacturer, nly for exportation 
    */
    'cnpjProd': string;
    /**
    * Seal Code for ipi tax control (código do selo para controle de IPI)
    */
    'sealCode': string;
    /**
    * Seal Code for ipi tax control (código do selo para controle de IPI)
    */
    'sealQuantity': string;
    /**
    * percent of icms apportionment between two states
    */
    'icmsInterPartRate': number;
    'icmsSesonReason': ICMSSesonReason;
    /**
    * percent of merchandise returned
    */
    'perQuantityReturned': number;
}

export namespace DetailsCalculatedTaxItem {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof',
        AproxtribState = <any> 'aproxtribState',
        AproxtribFed = <any> 'aproxtribFed',
        Aproxtrib = <any> 'aproxtrib'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class Entity {
    /**
    * Entity name, official name (Razão Social)
    */
    'name': string;
    /**
    * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
    */
    'role': Entity.RoleEnum;
    'type': EntityType;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'federalTaxId': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': Entity.TaxRegimeEnum;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * Companies subject to follow same rules of Government entities (Instrução Normativa SRF1234)
    */
    'subjectToSRF1234': boolean;
    /**
    * Sujeito à desoneração de folha de pagamento.
    */
    'subjectToPayrollExemption': boolean;
}

export namespace Entity {
    export enum RoleEnum {
        Transporter = <any> 'transporter',
        Sender = <any> 'sender',
        Dispatcher = <any> 'dispatcher',
        Receiver = <any> 'receiver',
        Addressee = <any> 'addressee',
        Other = <any> 'other'
    }
    export enum TaxRegimeEnum {
        RealProfit = <any> 'realProfit',
        EstimatedProfit = <any> 'estimatedProfit',
        Simplified = <any> 'simplified',
        SimplifiedOverGrossthreshold = <any> 'simplifiedOverGrossthreshold',
        SimplifiedEntrepreneur = <any> 'simplifiedEntrepreneur',
        NotApplicable = <any> 'notApplicable',
        Individual = <any> 'individual'
    }
}
export class EntityForGoods {
    /**
    * Entity name, official name (Razão Social)
    */
    'name': string;
    /**
    * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
    */
    'role': EntityForGoods.RoleEnum;
    'type': EntityType;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'federalTaxId': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': EntityForGoods.TaxRegimeEnum;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * Companies subject to follow same rules of Government entities (Instrução Normativa SRF1234)
    */
    'subjectToSRF1234': boolean;
    /**
    * Sujeito à desoneração de folha de pagamento.
    */
    'subjectToPayrollExemption': boolean;
    /**
    * Inform if the entity is ICMS tax payer.
    */
    'icmsTaxPayer': boolean;
}

export namespace EntityForGoods {
    export enum RoleEnum {
        Transporter = <any> 'transporter',
        Sender = <any> 'sender',
        Dispatcher = <any> 'dispatcher',
        Receiver = <any> 'receiver',
        Addressee = <any> 'addressee',
        Other = <any> 'other'
    }
    export enum TaxRegimeEnum {
        RealProfit = <any> 'realProfit',
        EstimatedProfit = <any> 'estimatedProfit',
        Simplified = <any> 'simplified',
        SimplifiedOverGrossthreshold = <any> 'simplifiedOverGrossthreshold',
        SimplifiedEntrepreneur = <any> 'simplifiedEntrepreneur',
        NotApplicable = <any> 'notApplicable',
        Individual = <any> 'individual'
    }
}
export class EntityInformerForGoods {
    'type': EntityType;
    'taxRegime': FederalTaxRegime;
    'federalTaxRegime': EntityInformerForGoodsFederalTaxRegime;
    'cityCode': string;
    'address': Address;
    'details': any;
    'icmsTaxPayer': boolean;
}

export class EntityInformerForGoodsFederalTaxRegime {
    'code': string;
    'name': string;
    'abbr': string;
}

export class EntityLocation {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

/**
* Entity Type (business, individual, federal government, state government, city government, foreign)
*/
export class EntityType {
}

/**
* Export information
*/
export class ExportInfo {
    /**
    * shipping state
    */
    'shippingState': StateEnum;
    /**
    * shipping place
    */
    'place': string;
    /**
    * description of shipping place
    */
    'placeDescription': string;
}

/**
* - Federal tax regime - realProfit - REAL PROFIT LUCRO REAL - estimatedProfit - ESTIMATED PROFIT / LUCRO PRESUMIDO - simplified - SIMPLIFIED - OPTANTE TO SIMPLES - simplifiedOverGrossthreshold - OPTANTE DO SIMPLES COM LIMITE DE GROSS REVENUE - simplifiedEntrepreneur - SIMPLIFIED ENTREPRENEUR / MEI MICRO EMPREENDEDOR INDIVIDUAL  - notApplicable - Not Applicable 1  - individual - INDIVIDUAL / INDIVIDUO 
*/
export class FederalTaxRegime {
}

export class Fuel {
    'prodANPCode': string;
    /**
    * percentage of natural gas (GLP)
    */
    'perMixGN': number;
    'authorizationCodeCODIF': string;
    /**
    * This decimal 12 integers and 0 to 4 decimals Quantidade de combustível faturada à temperatura ambiente. Informar quando a quantidade faturada informada no campo qCom (I10) tiver sido ajustada para uma temperatura diferente da ambiente. 
    */
    'quantityOnRoomTemperature': number;
    /**
    * state where fuel was used
    */
    'stateCodeOfUndUser': StateEnum;
    'cide': FuelCide;
    'pumpNumber': FuelPumpNumber;
}

export class FuelCide {
    /**
    * percentage of natural gas (GLP), this decimal 12 integers and 0 to 4 decimals
    */
    'baseCalcCIDE': number;
    /**
    * percentage of natural gas (GLP), this decimal 11 integers and 0 to 4 decimals - R$
    */
    'rateCIDE': number;
    /**
    * percentage of natural gas (GLP), this decimal 13 integers and 2 decimals - R$
    */
    'valueCIDE': number;
}

export class FuelPumpNumber {
    /**
    * Identification number of nozzle used in the dispensing process.   Numero de identificação do Bico utilizado no abastecimento 
    */
    'nozzleNumberFuelSupply': string;
    /**
    * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
    */
    'fuelPumpNumber': string;
    /**
    * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
    */
    'fuelTankNumber': string;
    /**
    * Valor do Encerrante no ínicio do abastecimento.  Reading of auto-counter (encerrante) at the start of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
    */
    'startValueOfPumpNumber': number;
    /**
    * Valor do Encerrante no final do abastecimento.  Reading of auto-counter (encerrante) at the end of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
    */
    'endValueOfPumpNumber': number;
}

export class HeaderBaseInfo {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': HeaderBaseInfo.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
}

export namespace HeaderBaseInfo {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
}
export class HeaderForGoods {
    'messageType': HeaderForGoods.MessageTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    'participants': HeaderForGoodsParticipants;
    /**
    * This is the public NF id. With this number is possible get invoice information directly from government.
    */
    'nfAccessKey': string;
    /**
    * qr code printed on DANFE;
    */
    'nfceQrCode': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated.
    */
    'transactionType': HeaderForGoods.TransactionTypeEnum;
    /**
    * - '01' # Nota Fiscal 1/1A - '1B' # Nota Fiscal Avulsa - '02' # Nota Fiscal de Venda a-Consumidor - '2D' # Cupom Fiscal - '2E' # Cupom Fiscal-Bilhete de Passagem - '04' # Nota Fiscal de Produtor - '06' # Nota Fiscal/Conta de Energia Elétrica - '07' # Nota Fiscal de Serviço de Transporte - '08' # Conhecimento de Transporte Rodoviário de-Cargas - '8B' # Conhecimento de Transporte de-Cargas Avulso - '09' # Conhecimento de Transporte Aquaviário de-Cargas - '10' # Conhecimento Aéreo - '11' # Conhecimento de Transporte Ferroviário de-Cargas - '13' # Bilhete de Passagem Rodoviário - '14' # Bilhete de Passagem Aquaviário - '15' # Bilhete de Passagem e-Nota de-Bagagem - '16' # Bilhete de Passagem Ferroviário - '18' # Resumo de Movimento Diário - '21' # Nota Fiscal de Serviço de-Comunicação - '22' # Nota Fiscal de Serviço de Telecomunicação - '26' # Conhecimento de Transporte Multimodal de-Cargas - '27' # Nota Fiscal De Transporte Ferroviário De-Carga - '28' # Nota Fiscal/Conta de Fornecimento de Gás-Canalizado - '29' # Nota Fiscal/Conta de Fornecimento de Água-Canalizada - '55' # Nota Fiscal Eletrônica (NF-e) - '57' # Conhecimento de Transporte Eletrônico (CT-e) - '59' # Cupom Fiscal Eletrônico (CF-e-SAT) - '60' # Cupom Fiscal Eletrônico (CF-e-ECF) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
    */
    'transactionModel': HeaderForGoods.TransactionModelEnum;
    /**
    * Natureza da Opreração - 'Describe kind of this transaction, summary
    */
    'transactionClass': string;
    'eDocCreatorType': HeaderForGoods.EDocCreatorTypeEnum;
    'eDocCreatorPerspective': boolean;
    /**
    * currency code
    */
    'currency': string;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string is the transaction date in ISO 8601 format, create transaction date
    */
    'transactionDate': string;
    /**
    * This string is the transaction date in ISO 8601 format, when products were shipped, can be empty or absent
    */
    'shippingDate': string;
    'additionalInfo': AdditionalInformation;
    /**
    * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; - '3' # DANFe Simplified; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
    */
    'tpImp': HeaderForGoods.TpImpEnum;
    /**
    * This indicator inform transaction target place, when is AUTOMATIC the company address and entity address are analyzed to identify type of transaction target place 1- same state; 2 - interstate; 3-with exterior. Exist some cases where is necessary force this situation like when buyer from another state buy something in loco, the address are from different states, but transaction no.  Identificador de Local de destino da operação, na opção AUTOMATIC endereços da Companhia e da entidade destino são analisados para saber se é uma operação dentro do mesmo estado, interestadual ou com o exterior. Há situações onde é necessário forçar este indicador como por exemplo  Quando uma pessoa com endereço em outro estado, compra uma mercadoria de forma presencial, é uma operação interna apesar dos endereços dos envolvidos estarem em estados distintos. - 0 # AUTOMATIC - DEFAULT - 1 # Interna; - 2 # Interestadual; - 3 # Exterior) 
    */
    'idDest': number;
    /**
    * Presence indicator - '0' # Not applicable - '1' # Presential; - '2' # Remote, internet; - '3' # Remote, phone; - '4' # NFC-e home delivery; - '9' # Remote, others 
    */
    'indPres': HeaderForGoods.IndPresEnum;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal)
    */
    'invoiceNumber': number;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
    */
    'invoiceSerial': number;
    'defaultLocations': DefaultLocations;
    /**
    * Shipment
    */
    'transport': Transport;
    /**
    * Transactions or other invoices referenced
    */
    'nfRef': Array<NRef>;
    'payment': Payment;
    'purchaseInfo': PurchaseInfo;
    'export': ExportInfo;
}

export namespace HeaderForGoods {
    export enum MessageTypeEnum {
        Goods = <any> 'goods'
    }
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        SalesReturn = <any> 'SalesReturn',
        PurchaseReturn = <any> 'PurchaseReturn',
        TransferReturn = <any> 'TransferReturn',
        Shipping = <any> 'Shipping',
        ShippingReturn = <any> 'ShippingReturn',
        Transfer = <any> 'Transfer',
        ReceiptAdjustment = <any> 'ReceiptAdjustment',
        TransferAdjustment = <any> 'TransferAdjustment'
    }
    export enum TransactionModelEnum {
        _01 = <any> '01',
        _1B = <any> '1B',
        _02 = <any> '02',
        _2D = <any> '2D',
        _2E = <any> '2E',
        _04 = <any> '04',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _8B = <any> '8B',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16',
        _18 = <any> '18',
        _21 = <any> '21',
        _22 = <any> '22',
        _26 = <any> '26',
        _27 = <any> '27',
        _28 = <any> '28',
        _29 = <any> '29',
        _55 = <any> '55',
        _57 = <any> '57',
        _59 = <any> '59',
        _60 = <any> '60',
        _65 = <any> '65'
    }
    export enum EDocCreatorTypeEnum {
        Self = <any> 'self',
        Other = <any> 'other'
    }
    export enum TpImpEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5'
    }
    export enum IndPresEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _9 = <any> '9'
    }
}
/**
* List of transaction participants, Seller, Buyer, Carrier
*/
export class HeaderForGoodsParticipants {
    'entity': EntityForGoods;
    'transporter': EntityForGoods;
}

/**
* - '0' # NO ICMS TAX RELIEF - '1' # TAXI - '3' # AGRICULTURAL PRODUCTION - '4' # FLEET OWNERS - '5' # DIPLOMATIC MISSIONS - '6' # VEHICLE AND MOTORCICLE OF FREE ZONE AREA AND OCIDENTAL AMAZON - '7' # SUFRAMA - '8' # SALES TO GOVERNMENT - '9' # OTHERS - '10' # DISABLED PERSON DRIVER - '11' # DISABLED PERSON NOT DRIVER 
*/
export class ICMSSesonReason {
}

export class IbptConf {
    /**
    * IBPT Code
    */
    'code': string;
    'description': string;
    'list': Array<IpbtConfItem>;
}

export class IcmsConfByState {
    /**
    * Identify the IcmsConfState in namespace
    */
    'code': string;
    'state': StateEnum;
    /**
    * name for this configuration
    */
    'name': string;
    /**
    * date when this configuration values starts
    */
    'startDate': Date;
    /**
    * date when this configuration values expire
    */
    'expirationDate': Date;
    /**
    * set this configuration to Inactive
    */
    'inactive': boolean;
    /**
    * inform that the item linked to this configuration is subject to ICMS ST on this state
    */
    'subjectToST': boolean;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsConfByState.IcmsCSTEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfByState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS for transactions inside state
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    /**
    * Fundo de Combate à pobreza / Fund Against Poverty
    */
    'fcpRate': number;
    'icmsSTConf': IcmsConfByStateIcmsSTConf;
    /**
    * the map key is state code
    */
    'icmsInterStateConf': Array<IcmsConfInterState>;
}

export namespace IcmsConfByState {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class IcmsConfByStateIcmsSTConf {
    /**
    * inform that substituted is tax regime Simplified the operation MVA will be reduced
    */
    'hasReductionOfMVAForSimples': boolean;
    /**
    * mva reduction when substituted is tax regime Simplified.
    */
    'reductionOfMVAForSimples': number;
    /**
    * how this ICMS-ST will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfByStateIcmsSTConf.CalcModeEnum;
    /**
    * ICMS-ST mva rate to define calc base
    */
    'mvaRate': number;
    /**
    * ICMS rate - Redução da BC ICMS ST (%)
    */
    'icmsStBaseDiscount': number;
    /**
    * SRP or MSRP amount base for this ICMS-ST configuration
    */
    'srp': number;
    /**
    * unit used to srv amount value
    */
    'srpUnit': string;
}

export namespace IcmsConfByStateIcmsSTConf {
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MSRP = <any> 'MSRP'
    }
}
export class IcmsConfInterState {
    'state': StateEnum;
    /**
    * how this ICMS will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfInterState.CalcModeEnum;
    /**
    * discount if the item is subject to monophase PIS/COFINS when operation interstate
    */
    'discountRateForMonoPhase': number;
    /**
    * ICMS rate
    */
    'rate': number;
    /**
    * FCP rate (Fundo de Combate à Probreza / Fund Against Poverty
    */
    'fcpRate': number;
    /**
    * ICMS rate
    */
    'icmsBaseDiscount': number;
    /**
    * SRP or MMSRP amount base for this icms configuration
    */
    'msrp': number;
    /**
    * ICMS MVA rate to define calc base
    */
    'mvaRate': number;
    /**
    * unit used to SRP amount value
    */
    'msrpUnit': string;
    /**
    * Code for the ICM legal reason, this message will be placed on invoice.
    */
    'icmsLegalReason': string;
    'icmsSTConf': IcmsConfInterStateIcmsSTConf;
}

export namespace IcmsConfInterState {
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MMSRP = <any> 'MMSRP',
        OPERATIONAMOUNT = <any> 'OPERATIONAMOUNT'
    }
}
export class IcmsConfInterStateIcmsSTConf {
    'protocolType': IcmsConfInterStateIcmsSTConf.ProtocolTypeEnum;
    /**
    * inform that substituted is tax regime Simplified the operation MVA will be reduced
    */
    'hasReductionOfMVAForSimples': boolean;
    /**
    * MVA reduction when substituted is tax regime Simplified.
    */
    'reductionOfMVAForSimples': number;
    /**
    * how this ICMS-ST will be calculed for itens linked to this configuration
    */
    'calcMode': IcmsConfInterStateIcmsSTConf.CalcModeEnum;
    /**
    * ICMS rate - Redução da BC ICMS ST (%)
    */
    'icmsStBaseDiscount': number;
    /**
    * ICMS-ST MVA rate to define calc base
    */
    'mvaRate': number;
    /**
    * SRP or MSRP amount base for this ICMS-ST configuration
    */
    'srp': number;
    /**
    * unit used to SRP amount value
    */
    'srpUnit': string;
}

export namespace IcmsConfInterStateIcmsSTConf {
    export enum ProtocolTypeEnum {
        COVENANT = <any> 'COVENANT',
        PROTOCOL = <any> 'PROTOCOL',
        NOTHING = <any> 'NOTHING'
    }
    export enum CalcModeEnum {
        BYMVARATE = <any> 'BYMVARATE',
        SRP = <any> 'SRP',
        MSRP = <any> 'MSRP'
    }
}
export class IcmsTaxConf {
    'state': StateEnum;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsTaxConf.IcmsCSTEnum;
    /**
    * Message to add to NF when this configuration is used
    */
    'messageCode': string;
    /**
    * the mapping key is state code / A chave do mapeamento é o código do Estado.
    */
    'relationShip': Array<IcmsTaxConfBase>;
}

export namespace IcmsTaxConf {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
}
export class IcmsTaxConfBase {
    'state': StateEnum;
    /**
    * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
    */
    'icmsCST': IcmsTaxConfBase.IcmsCSTEnum;
    /**
    * Message to add to NF when this configuration is used
    */
    'messageCode': string;
}

export namespace IcmsTaxConfBase {
    export enum IcmsCSTEnum {
        _00 = <any> '00',
        _20 = <any> '20',
        _40 = <any> '40',
        _41 = <any> '41',
        _50 = <any> '50'
    }
}
/**
* Internal Type used to references all taxes.
*/
export class InformerForGoods {
    'header': HeaderForGoods;
    'line': LineForGoods;
    'company': EntityInformerForGoods;
    'entity': EntityInformerForGoods;
    'emitter': EntityInformerForGoods;
    'receiver': EntityInformerForGoods;
    'transporter': EntityInformerForGoods;
    'csts': InformerForGoodsCsts;
    'amount': number;
    'discount': number;
    'quantity': number;
    'unitPrice': number;
    'freightAmount': number;
    'insuranceAmount': number;
    'otherCostAmount': number;
    'exemptValue': number;
}

export class InformerForGoodsCsts {
    /**
    * CST-B
    */
    'icms': string;
    /**
    * CST-IPI
    */
    'ipi': string;
    /**
    * CST PIS/COFINS
    */
    'pisCofins': string;
}

export class InlineResponse200 {
    'token': string;
    'expired': Date;
}

export class InlineResponse2001 {
    /**
    * Item description
    */
    'description': string;
    /**
    * uuid
    */
    'id': string;
    /**
    * Custom item code
    */
    'code': string;
}

export class InlineResponse2002 {
    'companyId': string;
}

export class InlineResponse2003 {
    'contingency': boolean;
    'startDate': Date;
    'finishDate': Date;
}

export class InlineResponse2004 {
    /**
    * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação                 
    */
    'environment': InlineResponse2004.EnvironmentEnum;
}

export namespace InlineResponse2004 {
    export enum EnvironmentEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
}
export class InlineResponse201 {
    'id': number;
}

export class InstallmentComplete {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment Due Date
    */
    'date': Date;
    /**
    * Intallment amount, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
    /**
    * net amount due for this installment, grossValue - ∑ (withhold amounts)
    */
    'netValue': number;
    /**
    * Inform if this payment is subject to Pis, Cofins or CSLL
    */
    'withholdingMode': WithholdingMode;
    /**
    * calculated PIS-RF tax for this payment
    */
    'withholdingPIS': number;
    /**
    * calculated COFINS-RF tax for this payment
    */
    'withholdingCOFINS': number;
    /**
    * calculated CSLL-RF tax for this payment
    */
    'withholdingCSLL': number;
}

export class IpbtConfItem {
    'state': StateEnum;
    'federalTax': number;
    'importTax': number;
    'stateTax': number;
    'cityTax': number;
    'source': string;
}

export class IssConfByCity {
    /**
    * City Code (IBGE)
    */
    'cityCode': number;
    'name': string;
    'state': StateEnum;
    'issWhDestOtherCities': boolean;
    'issWhDestSameCity': boolean;
    'issWhOriginUnregSeller': boolean;
    'serviceList': Array<IssConfServiceList>;
}

export class IssConfServiceList {
    'agast': string;
    'cityServiceCode': string;
    'taxRate': IssConfServiceListTaxRate;
}

export class IssConfServiceListTaxRate {
    'iSS': ServiceItemTaxRate;
    'iSSRF': ServiceItemTaxRate;
    'iSSE': ServiceItemTaxRate;
    'iSSI': ServiceItemTaxRate;
    'ibpt': IssConfServiceListTaxRateIbpt;
}

export class IssConfServiceListTaxRateIbpt {
    'nationalFedTax': number;
    'cityTax': number;
}

export class ItemCpom {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * IBGE city code
    */
    'cityCode': string;
    /**
    * ERP Code
    */
    'itemCode': string;
    /**
    * Code in City
    */
    'code': string;
}

export class ItemGoods {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * ERP Code
    */
    'code': string;
    /**
    * Agast Code
    */
    'agast': string;
    /**
    * Item Description
    */
    'description': string;
    /**
    * Applies the \"is Labor Cession\" tax scenario. (Cessão de mão de obra). 
    */
    'isLaborCession': boolean;
    /**
    * Seal Code for ipi tax control (código do selo para controle de IPI)
    */
    'sealCode': string;
    /**
    * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
    */
    'nFCI': string;
    /**
    * this field inform that this merchandise or product is ICMS Substitute Must be used when the item is for resale and the company will assume the role of ICMS Substitute (wholesaler, retailer, distributor). Example: when Importing some product the company does not pay IcmsSt at the time of customs clearance but when selling sale the item. Deverá ser utilizado quando a empresa que irá vender a mercadoria sujeita ao ICMS ST for o SUBSTITUTO TRIBUTÁRIO (Distribuidor, atacadista e varejista), como por exemplo das mercadorias IMPORTADAS, neste sentido, a empresa não irá pagar o ICMS ST no desembaraço aduaneiro e irá recolher quando for vender as mesmas. 
    */
    'isIcmsStSubstitute': boolean;
    /**
    * - '0' # National goods - except those treated in codes 3,4, 5 and 8 - '1' # Foreign goods - Imported directly by seller, except those in code 6 - '2' # Foreign goods - Acquired in the internal market (inside Brazil), except those in code 7 - '3' # National goods - Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # National goods - Merchandise or goods with imported content above 70% 
    */
    'source': ItemGoods.SourceEnum;
    'productType': ItemGoods.ProductTypeEnum;
    /**
    * Item is merchandise but will be considered product
    */
    'manufacturerEquivalent': boolean;
    /**
    * Inform that this item will have rights to aprropriate IPI credit
    */
    'appropriateIPIcreditWhenInGoing': boolean;
    /**
    * Subject to appropriate PIS/COFINS credit, when NO CUMULATIVE
    */
    'usuallyAppropriatePISCOFINSCredit': boolean;
    /**
    * The credit PIS/COFINS is subject to purchase form companies, but exist some exceptions, when the credit will be a estimated amount
    */
    'isPisCofinsEstimatedCredit': boolean;
    /**
    * - '01' # Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '02' # Exclusivamente a Receita Não Tributada no Mercado Interno - '03' # Exclusivamente a Receita de Exportação - '04' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '05' # Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '06' # Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '07' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação 
    */
    'piscofinsRevenueType': ItemGoods.PiscofinsRevenueTypeEnum;
    /**
    * Discount allowed on icms base when PIS/COFINS are Monophase
    */
    'icmsBaseDiscountForMonoPhaseSocialContr': number;
    /**
    * GTIN NUMBER
    */
    'cean': string;
    /**
    * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
    */
    'nve': string;
    'salesUnit': string;
    /**
    * factor to convert sales quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIPIfactor': number;
    /**
    * factor to convert sales quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIcmsfactor': number;
    /**
    * factor to convert sales quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitIcmsStfactor': number;
    /**
    * factor to convert sales quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'salesUnitPisCofinsfactor': number;
    'purchaseUnit': string;
    /**
    * factor to convert purchase quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIPIfactor': number;
    /**
    * factor to convert purchase quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIcmsfactor': number;
    /**
    * factor to convert purchase quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitIcmsStfactor': number;
    /**
    * factor to convert purchase quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
    */
    'purchaseUnitPisCofinsfactor': number;
    /**
    * When the product is new, and will be retail, firt time that it exit it is subject to IPI
    */
    'firstUse': boolean;
}

export namespace ItemGoods {
    export enum SourceEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8'
    }
    export enum ProductTypeEnum {
        FORPRODUCT = <any> 'FOR PRODUCT',
        FORMERCHANDISE = <any> 'FOR MERCHANDISE',
        NORESTRICTION = <any> 'NO RESTRICTION',
        SERVICE = <any> 'SERVICE',
        FEEDSTOCK = <any> 'FEEDSTOCK',
        FIXEDASSETS = <any> 'FIXED ASSETS'
    }
    export enum PiscofinsRevenueTypeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07'
    }
}
export class ItemSimple {
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * ERP Code
    */
    'code': string;
    /**
    * Agast Code
    */
    'agast': string;
    /**
    * Item Description
    */
    'description': string;
    /**
    * Applies the \"is Labor Cession\" tax scenario. (Cessão de mão de obra). 
    */
    'isLaborCession': boolean;
}

/**
* Legal Reason (Fundamentação Legal): - 'name' - 'description' - 'scope' 
*/
export class LegalReason {
    /**
    * Internal ID
    */
    'id': string;
    /**
    * Message scope. May be one of these. general - This message is not linked to any entity (agast/process/cfop) and will be applied to any item in a transacition. (Esta mensagem tem escopo geral, nao está relacionadas diretamente qualquer objeto.); linkedTo - This message is linked to an entity, and its processing will only occur when the context involves it. (Esta mensagens estão relacionadas diretamente a algum objeto como um AGAST por exemplo, um Processo ou uma CFOP.); 
    */
    'scope': LegalReason.ScopeEnum;
    /**
    * Set this message as no longer valid
    */
    'disable': boolean;
    /**
    * Legal reason textual description;
    */
    'description': string;
    /**
    * Short name to this message
    */
    'name': string;
    /**
    * this field inform the official code number
    */
    'legalCode': string;
    /**
    * Optional. Show this message when used in Invoice (NFe, NFCe, others...). Where to show this.
    */
    'showInInvoice': LegalReason.ShowInInvoiceEnum;
    /**
    * Referenced Process
    */
    'referencedProcesses': Array<LegalReasonReferencedProcesses>;
    'taxScope': LegalReasonTaxScope;
}

export namespace LegalReason {
    export enum ScopeEnum {
        General = <any> 'general',
        LinkedTo = <any> 'linkedTo'
    }
    export enum ShowInInvoiceEnum {
        ComplementaryInfoMessage = <any> 'complementaryInfoMessage',
        FiscalInfoMessage = <any> 'fiscalInfoMessage',
        ItemInfoMessage = <any> 'itemInfoMessage'
    }
}
export class LegalReasonReferencedProcesses {
    /**
    * Process Identifier (NFe <nProc> tag)
    */
    'nProc': string;
    /**
    * Process Origin (NFe <indProc> tag) - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
    */
    'indProc': LegalReasonReferencedProcesses.IndProcEnum;
}

export namespace LegalReasonReferencedProcesses {
    export enum IndProcEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _9 = <any> '9'
    }
}
/**
* Filter this message application to specified tax cases. - taxtype - jurisdictionType 
*/
export class LegalReasonTaxScope {
    /**
    * This is the Tax Type to apply legal messages. - 'NONE' - 'INSS' - 'IRRF' - 'IRPJ' - 'PIS' - 'COFINS' - 'CSLL' - 'IPI' - 'ICMS' - 'II' - 'IOF' - 'ISS' - 'APROXTOTALTAX' 
    */
    'taxType': LegalReasonTaxScope.TaxTypeEnum;
    /**
    * These are the specific tax types to which a message may be applied - 'icms' - 'icmsSt' - 'icmsStSd' - 'icmsPartOwn' - 'icmsPartDest' - 'icmsDifaFCP' - 'icmsDifaDest' - 'icmsDifaRemet' - 'icmsRf' - 'icmsDeson' - 'icmsCredsn' - 'pis' - 'pisSt' - 'cofins' - 'cofinsSt' - 'ipi' - 'ipiReturned' - 'ii' - 'iof' 
    */
    'specializedTaxType': LegalReasonTaxScope.SpecializedTaxTypeEnum;
    /**
    * Types of jurisdiction - 'NONE' - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': LegalReasonTaxScope.JurisdictionTypeEnum;
    /**
    * Code to identify the Jurisdiction
    */
    'jurisdictionIbgeCode': string;
}

export namespace LegalReasonTaxScope {
    export enum TaxTypeEnum {
        NONE = <any> 'NONE',
        INSS = <any> 'INSS',
        IRRF = <any> 'IRRF',
        IRPJ = <any> 'IRPJ',
        PIS = <any> 'PIS',
        COFINS = <any> 'COFINS',
        CSLL = <any> 'CSLL',
        IPI = <any> 'IPI',
        ICMS = <any> 'ICMS',
        II = <any> 'II',
        IOF = <any> 'IOF',
        ISS = <any> 'ISS',
        APROXTOTALTAX = <any> 'APROXTOTALTAX'
    }
    export enum SpecializedTaxTypeEnum {
        Icms = <any> 'icms',
        IcmsSt = <any> 'icmsSt',
        IcmsStSd = <any> 'icmsStSd',
        IcmsPartOwn = <any> 'icmsPartOwn',
        IcmsPartDest = <any> 'icmsPartDest',
        IcmsDifaFCP = <any> 'icmsDifaFCP',
        IcmsDifaDest = <any> 'icmsDifaDest',
        IcmsDifaRemet = <any> 'icmsDifaRemet',
        IcmsRf = <any> 'icmsRf',
        IcmsDeson = <any> 'icmsDeson',
        IcmsCredsn = <any> 'icmsCredsn',
        Pis = <any> 'pis',
        PisSt = <any> 'pisSt',
        Cofins = <any> 'cofins',
        CofinsSt = <any> 'cofinsSt',
        Ipi = <any> 'ipi',
        IpiReturned = <any> 'ipiReturned',
        Ii = <any> 'ii',
        Iof = <any> 'iof'
    }
    export enum JurisdictionTypeEnum {
        NONE = <any> 'NONE',
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class LineForGoods {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
    */
    'returnedPercentageAmount': number;
    /**
    * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
    */
    'lineUnitPrice': number;
    /**
    * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Discount conditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineTaxedDiscount': number;
    /**
    * discount unconditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineUntaxedDiscount': number;
    /**
    * This is a enumeration folowing table
    */
    'useType': LineForGoods.UseTypeEnum;
    /**
    * Reference to process configurantion of this transaction, See ProcessScenario definition
    */
    'processScenario': string;
    /**
    * Fiscal Operation Code of transport service
    */
    'cfop': number;
    /**
    * return if this transaction has stock impact for this process or CFOP
    */
    'hasStockImpact': boolean;
    /**
    * return if this transaction has finantial impact for this process or CFOP
    */
    'hasFinantialImpact': boolean;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'freightAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'insuranceAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'otherCostAmount': number;
    /**
    * The item value will compose the invoice total value.
    */
    'indTotType': boolean;
    /**
    * order number, information used for B2B control process
    */
    'orderNumber': string;
    /**
    * number of the item from order number, information used for B2B control process
    */
    'orderItemNumber': string;
    /**
    * Gloal Unique identifier (Importation form)
    */
    'fciNumber': string;
    /**
    * RECOPI number
    */
    'recopiNumber': string;
    /**
    * additional information about product (referenced standard, complementary info, etc)
    */
    'infAdProd': string;
    'vehicle': Vehicle;
    'medicine': Medicine;
    'weapon': Weapon;
    'fuel': Fuel;
    /**
    * Inform that for this item the Entity referenced is ICMS Substitute
    */
    'entityIsIcmsSubstitute': boolean;
    /**
    * Inform that this item has ICMS withheld for transport value service.
    */
    'isTransportIcmsWithheld': boolean;
    'icmsTaxRelief': LineForGoodsIcmsTaxRelief;
    /**
    * Exportation detail
    */
    'export': Array<LineForGoodsExport>;
    /**
    * Import declaration
    */
    'di': Array<LineForGoodsDi>;
    'calculatedTax': LineForGoodsCalculatedTax;
}

export namespace LineForGoods {
    export enum UseTypeEnum {
        UseOrConsumption = <any> 'use or consumption',
        Resale = <any> 'resale',
        AgriculturalProduction = <any> 'agricultural production',
        Production = <any> 'production',
        UseOrConsumptionOnBusinessEstablishment = <any> 'use or consumption on business establishment',
        UseOrConsumptionOnTransporterServiceEstablishment = <any> 'use or consumption on transporter service establishment',
        UseOrConsumptionOnCommunicationServiceEstablishment = <any> 'use or consumption on communication service establishment',
        UseOrConsumptionOnDemandByContract = <any> 'use or consumption on demand by contract',
        UseOrConsumptionOnEnergySupplierEstablishment = <any> 'use or consumption on energy supplier establishment',
        UseOrConsumptionOfFuelTransactionTypeExportation = <any> 'use or consumption of fuel transaction type exportation',
        FixedAssets = <any> 'fixed assets',
        ResaleExport = <any> 'resale export',
        ResaleIcmsExempt = <any> 'resale icms exempt',
        ResaleBuyerUnderTheSameIcmsStTaxRule = <any> 'resale buyer under the same icmsSt tax rule',
        TransportOfGoodsThatDontNeedInvoiceNf = <any> 'transport of goods that don't need invoice (nf)'
    }
}
export class LineForGoodsAdi {
    /**
    * aditional sequence number (1 to 100)
    */
    'addNumber': number;
    /**
    * sequential item number for this adi, sequence number (1 to 999)
    */
    'sequentialNumber': number;
    /**
    * Manufatorer erp internal code
    */
    'manufacturerCode': string;
    /**
    * This decimal 13 integers and 2 decimals, aditional adi discount
    */
    'adiDiscount': number;
    /**
    * Drawback number
    */
    'drawbackNumber': string;
}

export class LineForGoodsCalculatedTax {
    'taxByType': LineForGoodsCalculatedTaxTaxByType;
    'tax': number;
    'details': Array<DetailsCalculatedTaxItem>;
}

export class LineForGoodsCalculatedTaxTaxByType {
    'icms': TaxByTypeTax;
    'icmsSt': TaxByTypeTax;
    'icmsStSd': TaxByTypeTax;
    'icmsPartOwn': TaxByTypeTax;
    'icmsPartDest': TaxByTypeTax;
    'icmsDifaFCP': TaxByTypeTax;
    'icmsDifaDest': TaxByTypeTax;
    'icmsDifaRemet': TaxByTypeTax;
    'icmsRf': TaxByTypeTax;
    'icmsDeson': TaxByTypeTax;
    'icmsCredsn': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'pisSt': TaxByTypeTax;
    'cofins': TaxByTypeTax;
    'cofinsSt': TaxByTypeTax;
    'ipi': TaxByTypeTax;
    'ii': TaxByTypeTax;
    'iof': TaxByTypeTax;
    'aproxtribState': TaxByTypeTax;
    'aproxtribFed': TaxByTypeTax;
}

export class LineForGoodsDi {
    /**
    * customs value, valor aduaneiro (II Block of NFe)
    */
    'customsValue': number;
    /**
    * Import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
    */
    'diNumber': string;
    /**
    * Register date of import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
    */
    'registerDateDI': Date;
    /**
    * Clerance Site Local do desembaraço aduaneiro 
    */
    'clearanceSite': string;
    /**
    * Clerance Site State Estado onde ocorrreu o desembaraço aduaneiro 
    */
    'clearanceState': StateEnum;
    /**
    * Clerance date
    */
    'clearanceDate': Date;
    /**
    * - '1' # Maritima - '2' # Fluvial - '3' # Lacustre - '4' # Aerea - '5' # Postal - '6' # Ferroviaria - '7' # Rodoviaria - '8' # Conduto - '9' # Meios Proprios - '10' # Entrada/Saida Ficta 
    */
    'transportDIType': LineForGoodsDi.TransportDITypeEnum;
    /**
    * Aditional amount to freight to renew merchant marine, This decimal 13 integers and 2 decimals [Valor Adicional ao frete para renovação de marinha mercante] 
    */
    'afrmmValue': number;
    /**
    * - '1' # On One's Own [1-por conta propria] - '2' # On Behalf And Order [2-por conta e ordem] - '3' # Order [3-encomenda] 
    */
    'intermediateType': LineForGoodsDi.IntermediateTypeEnum;
    /**
    * Buyer federal tax id CNPJ do comprador ou encomendante 
    */
    'buyerFederalTaxID': string;
    /**
    * Buyer sate Estado do comprador ou encomendante 
    */
    'buyerState': StateEnum;
    /**
    * Exporter code
    */
    'exporterCode': string;
    /**
    * aditional import declaration
    */
    'adi': Array<LineForGoodsAdi>;
}

export namespace LineForGoodsDi {
    export enum TransportDITypeEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8',
        _9 = <any> '9',
        _10 = <any> '10'
    }
    export enum IntermediateTypeEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3'
    }
}
export class LineForGoodsExport {
    'drawbackNumber': string;
    'indExport': LineForGoodsIndExport;
}

export class LineForGoodsIcmsTaxRelief {
    /**
    * When item transaction subject to desoneration, this is the reason code - '1' # Táxi; - '3' # Produtor Agropecuário; - '4' # Frotista/Locadora; - '5' # Diplomático/Consular; - '6' # Utilitários e Motocicletas da Amazônia Ocidental e Áreas de Livre Comércio (Resolução 714/88 e 790/94 – CONTRAN e suas alterações); - '7' # SUFRAMA; - '8' # Venda a órgão Público; - '9' # Outros - '10' # Deficiente Condutor - '11' # Deficiente não condutor - '12' # Fomento agropecuário - '16' # Olimpíadas Rio 2016 
    */
    'reasonCode': LineForGoodsIcmsTaxRelief.ReasonCodeEnum;
    /**
    * ICMS Tax base rate discount  (desconto na base do ICMS referetne a desoneração)
    */
    'taxBaseDiscount': number;
    /**
    * Amount for Icms Relief (desoneração)
    */
    'taxAmount': number;
}

export namespace LineForGoodsIcmsTaxRelief {
    export enum ReasonCodeEnum {
        _1 = <any> '1',
        _3 = <any> '3',
        _4 = <any> '4',
        _5 = <any> '5',
        _6 = <any> '6',
        _7 = <any> '7',
        _8 = <any> '8',
        _9 = <any> '9',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _16 = <any> '16'
    }
}
/**
* indirect exportation
*/
export class LineForGoodsIndExport {
    /**
    * Exportation register number
    */
    'registerNumber': string;
    /**
    * invoice access key received to export
    */
    'accessKey': string;
    /**
    * This decimal 11 integers and 0 to 4 decimals, quantity exported in real
    */
    'quantity': number;
}

export class LineForSefazGoods {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
    */
    'returnedPercentageAmount': number;
    /**
    * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
    */
    'lineUnitPrice': number;
    /**
    * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Discount conditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineTaxedDiscount': number;
    /**
    * discount unconditional, This decimal 13 integers and 0 to 2 decimals
    */
    'lineUntaxedDiscount': number;
    /**
    * This is a enumeration folowing table
    */
    'useType': LineForSefazGoods.UseTypeEnum;
    /**
    * Reference to process configurantion of this transaction, See ProcessScenario definition
    */
    'processScenario': string;
    /**
    * Fiscal Operation Code of transport service
    */
    'cfop': number;
    /**
    * return if this transaction has stock impact for this process or CFOP
    */
    'hasStockImpact': boolean;
    /**
    * return if this transaction has finantial impact for this process or CFOP
    */
    'hasFinantialImpact': boolean;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'freightAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'insuranceAmount': number;
    /**
    * This decimal 13 integers and 0 to 2 decimals
    */
    'otherCostAmount': number;
    /**
    * The item value will compose the invoice total value.
    */
    'indTotType': boolean;
    /**
    * order number, information used for B2B control process
    */
    'orderNumber': string;
    /**
    * number of the item from order number, information used for B2B control process
    */
    'orderItemNumber': string;
    /**
    * Gloal Unique identifier (Importation form)
    */
    'fciNumber': string;
    /**
    * RECOPI number
    */
    'recopiNumber': string;
    /**
    * additional information about product (referenced standard, complementary info, etc)
    */
    'infAdProd': string;
    'vehicle': Vehicle;
    'medicine': Medicine;
    'weapon': Weapon;
    'fuel': Fuel;
    /**
    * Inform that for this item the Entity referenced is ICMS Substitute
    */
    'entityIsIcmsSubstitute': boolean;
    /**
    * Inform that this item has ICMS withheld for transport value service.
    */
    'isTransportIcmsWithheld': boolean;
    'icmsTaxRelief': LineForGoodsIcmsTaxRelief;
    /**
    * Exportation detail
    */
    'export': Array<LineForGoodsExport>;
    /**
    * Import declaration
    */
    'di': Array<LineForGoodsDi>;
    'calculatedTax': LineForGoodsCalculatedTax;
    'extend': AgastExtendForSefaz;
}

export namespace LineForSefazGoods {
    export enum UseTypeEnum {
        UseOrConsumption = <any> 'use or consumption',
        Resale = <any> 'resale',
        AgriculturalProduction = <any> 'agricultural production',
        Production = <any> 'production',
        UseOrConsumptionOnBusinessEstablishment = <any> 'use or consumption on business establishment',
        UseOrConsumptionOnTransporterServiceEstablishment = <any> 'use or consumption on transporter service establishment',
        UseOrConsumptionOnCommunicationServiceEstablishment = <any> 'use or consumption on communication service establishment',
        UseOrConsumptionOnDemandByContract = <any> 'use or consumption on demand by contract',
        UseOrConsumptionOnEnergySupplierEstablishment = <any> 'use or consumption on energy supplier establishment',
        UseOrConsumptionOfFuelTransactionTypeExportation = <any> 'use or consumption of fuel transaction type exportation',
        FixedAssets = <any> 'fixed assets',
        ResaleExport = <any> 'resale export',
        ResaleIcmsExempt = <any> 'resale icms exempt',
        ResaleBuyerUnderTheSameIcmsStTaxRule = <any> 'resale buyer under the same icmsSt tax rule',
        TransportOfGoodsThatDontNeedInvoiceNf = <any> 'transport of goods that don't need invoice (nf)'
    }
}
export class Location {
    /**
    * Street Name
    */
    'street': string;
    /**
    * Neighborhood Name
    */
    'neighborhood': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    /**
    * City Code (IBGE)
    */
    'cityCode': string;
    /**
    * City Name
    */
    'cityName': string;
    'state': StateEnum;
    /**
    * Country Code
    */
    'countryCode': string;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
    /**
    * House number
    */
    'number': string;
    /**
    * Any other information about the address (Room, Suite, Floor, etc)).
    */
    'complement': string;
    /**
    * Phone number
    */
    'phone': string;
    /**
    * Company ID
    */
    'companyId': string;
    /**
    * this property identify the location, it is unique for this company
    */
    'code': string;
    /**
    * this property identify the location, it is unique for this company
    */
    'type': Location.TypeEnum;
    /**
    * Email
    */
    'email': string;
    /**
    * Federal tax id, CNPJ or CPF
    */
    'federalTaxId': string;
    /**
    * state tax id for this location
    */
    'stateTaxId': string;
    'secondaryStateTaxId': Array<LocationSecondaryStateTaxId>;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    'suframa': string;
    /**
    * Main location activity
    */
    'mainActivity': Location.MainActivityEnum;
    /**
    * - 'edi' # City hall has web service and the integration is automatic - 'xml' # Create RPS specific to City, bat does not have webservice integration - 'rps' # Create a generic RPS, NF is by hands 
    */
    'nfseProcessModel': Location.NfseProcessModelEnum;
}

export namespace Location {
    export enum TypeEnum {
        ShipFrom = <any> 'ShipFrom',
        ShipTo = <any> 'ShipTo',
        ServiceRendered = <any> 'ServiceRendered'
    }
    export enum MainActivityEnum {
        Commerce = <any> 'commerce',
        Industry = <any> 'industry',
        Service = <any> 'service'
    }
    export enum NfseProcessModelEnum {
        Edi = <any> 'edi',
        Xml = <any> 'xml',
        Rps = <any> 'rps'
    }
}
export class LocationSecondaryStateTaxId {
    'stateTaxId': string;
    'state': StateEnum;
}

export class Medicine {
    'loteNumber': string;
    /**
    * This is a decimal type with 11 digits including 3 decimal positions.
    */
    'loteQuantity': number;
    'manufactotyDate': Date;
    'expirationDate': Date;
    /**
    * This is a decimal type with 15 digits including 2 decimal positions.  Max value to end user.
    */
    'maxValueToEndUser': number;
}

export class Message {
    'message': string;
}

export class ModelError {
    'code': number;
    'message': string;
    'field': string;
    'value': string;
    'in': ModelError.ModelInEnum;
}

export namespace ModelError {
    export enum ModelInEnum {
        Params = <any> 'params',
        Body = <any> 'body',
        Query = <any> 'query'
    }
}
/**
* Referenced Invoices The invoice can be one of this types, - 'refNFe - Eletronic Invoice' - 'refCTE - Transport Invoice' - 'refECF - Reatail Cupom' - 'refNF  - Invoice model 1 or 1A' - 'refFarmerNF - farmer invoice' 
*/
export class NRef {
    'type': NRef.TypeEnum;
    'refNFe': string;
    'refCTe': string;
    'refECF': NRefRefECF;
    'refNF': NRefRefNF;
    'refFarmerNF': NRefRefFarmerNF;
}

export namespace NRef {
    export enum TypeEnum {
        RefNFe = <any> 'refNFe',
        RefCTE = <any> 'refCTE',
        RefECF = <any> 'refECF',
        RefNF = <any> 'refNF',
        RefFarmerNF = <any> 'refFarmerNF'
    }
}
export class NRefRefECF {
    /**
    * ECF Sequential number that generated Cupom attached to NFe informar o número de ordem seqüencial do ECF que emitiu o Cupom Fiscal vinculado à NF-e 
    */
    'nECF': string;
    /**
    * Operational counter number attached to NFe Informar o Número do Contador de Ordem de Operação - COO vinculado à NF-e 
    */
    'nCOO': string;
    /**
    * Fiscal document model - '2B' # coupon tax not ECF - '2C' # PDV coupon tax - '2D' # ECF coupon tax 
    */
    'modECF': NRefRefECF.ModECFEnum;
}

export namespace NRefRefECF {
    export enum ModECFEnum {
        _2B = <any> '2B',
        _2C = <any> '2C',
        _2D = <any> '2D'
    }
}
export class NRefRefFarmerNF {
    /**
    * State code of fiscal Document creator, farmer
    */
    'stateCd': StateEnum;
    /**
    * year and month of fiscal document creation
    */
    'yymm': string;
    /**
    * fiscal document creator farmer federalTaxId
    */
    'federalTaxId': string;
    /**
    * fiscal document creator, farmer stateTaxId
    */
    'stateTaxId': string;
    /**
    * Document Fiscal model - '04' # FARMER DOCUMENT - '01' # DETACHED DOCUMENT - AVULSO 
    */
    'model': NRefRefFarmerNF.ModelEnum;
    /**
    * fiscal document serie
    */
    'serie': string;
    /**
    * fiscal document number
    */
    'number': string;
}

export namespace NRefRefFarmerNF {
    export enum ModelEnum {
        _04 = <any> '04',
        _01 = <any> '01'
    }
}
export class NRefRefNF {
    /**
    * State code of fiscal Document creator
    */
    'stateCd': StateEnum;
    /**
    * year and month of fiscal document creation
    */
    'yymm': string;
    /**
    * fiscal document creator federalTaxId
    */
    'federalTaxId': string;
    /**
    * fiscal document serie
    */
    'serie': string;
    /**
    * fiscal document number
    */
    'number': string;
}

export class PayRecCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * Sum of grossvalues
    */
    'subtotal': number;
    /**
    * Sum of all withholding values
    */
    'totalTax': number;
    /**
    * Sum all NetValues
    */
    'grandTotal': number;
    'pccWithholdingModes': Array<PccWithholdingMode>;
    'taxByType': PayRecCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class PayRecCalculatedTaxSummaryForServiceTaxByType {
    'issRf': TaxByTypeSummaryForService;
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
}

export class PayRecHeader {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PayRecHeader.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code. 'BRL' for Brazilian Reais.
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * - 'CALCULATE' - 'ASIS' When ASIS, the transaction is stored without executing tax determination (no Calculation). 
    */
    'paymentMode': PayRecHeader.PaymentModeEnum;
}

export namespace PayRecHeader {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum PaymentModeEnum {
        CALCULATE = <any> 'CALCULATE',
        ASIS = <any> 'ASIS'
    }
}
export class PayRecLinesIn {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PayRecLinesIn.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
}

export namespace PayRecLinesIn {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class PayRecLinesOut {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PayRecLinesOut.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
    /**
    * GrossAmount of this installment line
    */
    'lineAmount': number;
    /**
    * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
    */
    'lineNetValue': number;
    /**
    * x is because not subject of this tax independent of Threshold
    */
    'withholdingMode': WithholdingMode;
    'calculatedTax': PaymentCalculatedTax;
}

export namespace PayRecLinesOut {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class Payment {
    /**
    * Installment terms - 0 # cash - 1 # on terms - 2 # other 
    */
    'installmentsTerms': number;
    'bill': PaymentBill;
    'installment': Array<PaymentInstallment>;
    'paymentMode': Array<PaymentPaymentMode>;
}

/**
* Bill information
*/
export class PaymentBill {
    /**
    * Bill identifier
    */
    'nFat': string;
    /**
    * Orignal value
    */
    'vOrig': number;
    /**
    * Discount
    */
    'vDiscount': number;
    /**
    * Net value
    */
    'vNet': number;
}

/**
* Structure with value for each tax withhold value of this line
*/
export class PaymentCalculatedTax {
    'taxByType': PaymentTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
}

export class PaymentInstallment {
    /**
    * Instalment number identifier
    */
    'documentNumber': string;
    /**
    * Installment expiration date
    */
    'date': Date;
    /**
    * Installment value
    */
    'grossValue': number;
}

export class PaymentLinesIn {
    /**
    * Installment number in this document
    */
    'lineCode': number;
    'lineType': PaymentLinesIn.LineTypeEnum;
    /**
    * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
    */
    'itemCode': string;
    /**
    * Free description about this payment
    */
    'itemDescription': string;
    /**
    * Installment number, when paid AS IS
    */
    'itemDocNumber': string;
    /**
    * Penalty, usually because paid after due date
    */
    'lineUntaxedPenality': number;
    /**
    * unconditional discounts
    */
    'lineUntaxedDiscount': number;
    /**
    * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
    */
    'lineNetValue': number;
}

export namespace PaymentLinesIn {
    export enum LineTypeEnum {
        Installment = <any> 'installment'
    }
}
export class PaymentPaymentMode {
    /**
    * Payment mode - '01' # Dinheiro - '02' # Cheque - '03' # Cartão de Crédito - '04' # Cartão de Débito - '05' # Crédito Loja - '10' # Vale Alimentação - '11' # Vale Refeição - '12' # Vale Presente - '13' # Vale Combustível - '99' # Outros 
    */
    'mode': PaymentPaymentMode.ModeEnum;
    /**
    * payment value
    */
    'value': number;
    /**
    * - '1' # Payment integrated with system, - '2' # Payment not integrated with system 
    */
    'cardTpIntegration': PaymentPaymentMode.CardTpIntegrationEnum;
    /**
    * Federal tax id of accrediting card (credenciadora do cartão)
    */
    'cardCNPJ': string;
    /**
    * card brand - '01' # Visa - '02' # Mastercard - '03' # American Express - '04' # Sorocred - '99' # Other 
    */
    'cardBrand': PaymentPaymentMode.CardBrandEnum;
    /**
    * transaction authorization number
    */
    'cardAuthorization': string;
}

export namespace PaymentPaymentMode {
    export enum ModeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _99 = <any> '99'
    }
    export enum CardTpIntegrationEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
    export enum CardBrandEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _99 = <any> '99'
    }
}
/**
* Object with summary of all taxes returned by engine
*/
export class PaymentTaxByType {
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'issRf': TaxByTypeTax;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
}

/**
* 0 – cash pagamento à vista 1 – on terms, pagamento à prazo; 
*/
export class PaymentTerms {
}

export class PaymentTransactionIn {
    'header': PayRecHeader;
    'lines': Array<PaymentLinesIn>;
}

export class PaymentTransactionOut {
    'header': PayRecHeader;
    'lines': Array<PayRecLinesOut>;
    'calculatedTaxSummary': PayRecCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class PccWithholdingMode {
    /**
    * Inform if this group of tax are calculated considering the threashold by PCC or Individualy (each tax separately)
    */
    'type': PccWithholdingMode.TypeEnum;
    /**
    * this attribute occurs only for CSRF type, When CRSF mode, this is sum of pisRf, CofinsRf and CsllRf
    */
    'totalTax': number;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
}

export namespace PccWithholdingMode {
    export enum TypeEnum {
        CSRF = <any> 'CSRF',
        Individual = <any> 'individual'
    }
}
/**
* Address where the service is rendered.
*/
export class PointOfOrderOrigin {
    'address': SimpleAddress;
}

export class ProcessScenario {
    /**
    * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': ProcessScenario.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': ProcessScenario.AccruablePISTaxationEnum;
    /**
    * Reference to a tax reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': ProcessScenario.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
    /**
    * Process name to Identify this configuration
    */
    'name': string;
    'type': ProcessScenario.TypeEnum;
    /**
    * inform if the transaction is an operation to internalizing (receive) item or value
    */
    'wayType': ProcessScenario.WayTypeEnum;
    /**
    * - 'Normal' # Normal - 'Complementary' # Complemento de Valores - 'Voided' # Anulação - 'Replacement' # Substituto - 'Return' # Devolução ou retorno - 'Adjustment' # Ajuste 
    */
    'goal': ProcessScenario.GoalEnum;
    /**
    * inform that the configuration process overwrites the cfop configuration.
    */
    'overWriteCFOP': boolean;
    'cfops': Array<CfopConf>;
}

export namespace ProcessScenario {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum TypeEnum {
        SALES = <any> 'SALES',
        PURCHASE = <any> 'PURCHASE',
        SALESRETURN = <any> 'SALES_RETURN',
        PURCHASERETURN = <any> 'PURCHASE_RETURN',
        TRANSFERRETURN = <any> 'TRANSFER_RETURN',
        SHIPPING = <any> 'SHIPPING',
        SHIPPINGRETURN = <any> 'SHIPPING_RETURN',
        TRANSFER = <any> 'TRANSFER',
        RECEIPTAJUSTE = <any> 'RECEIPT_AJUSTE',
        TRANSFERAJUSTE = <any> 'TRANSFER_AJUSTE'
    }
    export enum WayTypeEnum {
        In = <any> 'in',
        Out = <any> 'out'
    }
    export enum GoalEnum {
        Normal = <any> 'Normal',
        Complementary = <any> 'Complementary',
        Voided = <any> 'Voided',
        Replacement = <any> 'Replacement',
        Return = <any> 'Return',
        Adjustment = <any> 'Adjustment'
    }
}
export class ProcessingInfo {
    'versionId': string;
    'duration': number;
}

export class PurchaseCalculatedTax {
    'taxByType': PurchaseTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
    'details': Array<PurchaseTaxByTypeDetail>;
}

export class PurchaseCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line tax attribute
    */
    'subtotal': number;
    /**
    * sum of all line lineAmount attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': PurchaseCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class PurchaseCalculatedTaxSummaryForServiceTaxByType {
    'issRf': TaxByTypeSummaryForService;
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
    'inssAr': TaxByTypeSummaryForService;
    'pis': TaxByTypeSummaryForService;
    'cofins': TaxByTypeSummaryForService;
}

/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
*/
export class PurchaseDefaultLocations {
    'pointOfOrderOrigin': PointOfOrderOrigin;
}

export class PurchaseEntity {
    /**
    * Legal Name of Service buyer.
    */
    'name': string;
    'type': EntityType;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * CNPJ/CPF of Sales Buyer. If CPF, pattern is '[0-9]{11}' if CNPJ, pattern is '[0-9]{14}'
    */
    'cnpjcpf': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': FederalTaxRegime;
    /**
    * Some cities require PURCHASE.Buyers to withhold ISS (City Tax) from PURCHASE.Sellers stablished in different cities. In case the PURCHASE.Seller has acquired a Tax Registration in this destination city, by providing this information in the service invoice, this withholding obligation is lifted.
    */
    'hasCpom': boolean;
    /**
    * These are the federal taxes attributes that determine whether withholding of taxes should take place. In special cases where the PURCHASE.Seller is exempt of one or more of these taxes the withholding follows the same rules. The Business type may also dictate these rules as well.
    */
    'subjectWithholdingIrrf': boolean;
    /**
    * The INSS contribution is capped at a maximum limit (amount of actual retired payment available in the country).  Individuals sellers subject to INSS withholding can provide the amount already tax by other transactions (with the same buyer or different ones) to deduct to the tax basis. This amount is to be provided to the Seller in a form of a signed document.
    */
    'inssPreviousContrib': number;
    /**
    * The INSS contribution is applicable only to the labor amount in a service contract.  There are several items that may be deducted from the service invoice total to arrive at the INSS taxable amount. This amount is to be provided to the Seller in the body of the Invoice or calculated during the transaction input.
    */
    'inssBasisDiscount': number;
    /**
    * When Seller is Simples regime, the seller needs send RF rate.
    */
    'issRfRate': number;
}

export class PurchaseHeaderIn {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PurchaseHeaderIn.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    'entity': PurchaseEntity;
    'payment': PurchaseHeaderInPayment;
    'taxesConfig': PurchaseTaxesConfig;
    'defaultLocations': PurchaseDefaultLocations;
}

export namespace PurchaseHeaderIn {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
}
export class PurchaseHeaderInPayment {
    'terms': PaymentTerms;
    /**
    * installments
    */
    'installments': Array<PurchaseInstallmentIn>;
}

export class PurchaseHeaderOut {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': PurchaseHeaderOut.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    'entity': PurchaseEntity;
    'payment': PurchaseHeaderOutPayment;
    'taxesConfig': PurchaseTaxesConfig;
    'defaultLocations': PurchaseDefaultLocations;
}

export namespace PurchaseHeaderOut {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
}
export class PurchaseHeaderOutPayment {
    'terms': PaymentTerms;
    'withholdingMode': WithholdingMode;
    /**
    * installments
    */
    'installments': Array<InstallmentComplete>;
}

export class PurchaseInfo {
    /**
    * Invoice info for government purchase orders Informação da Nota de Empenho de compras públicas 
    */
    'governmentOrder': string;
    /**
    * Order info Informação do pedido 
    */
    'orderNumber': string;
    /**
    * Agreement info Informação do contrato 
    */
    'contractNumber': string;
}

export class PurchaseInstallmentIn {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment, Due Date
    */
    'date': Date;
    /**
    * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
}

export class PurchaseLinesIn {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    /**
    * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
    */
    'useType': PurchaseLinesIn.UseTypeEnum;
    'taxDeductions': SalesLinesOutTaxDeductions;
}

export namespace PurchaseLinesIn {
    export enum UseTypeEnum {
        Resale = <any> 'resale',
        Production = <any> 'production',
        UseOrConsumption = <any> 'use or consumption',
        FixedAssets = <any> 'fixed assets'
    }
}
export class PurchaseLinesOut {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    /**
    * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
    */
    'useType': PurchaseLinesOut.UseTypeEnum;
    'taxDeductions': SalesLinesOutTaxDeductions;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal captures the value of lineAmount - lineTaxedDiscount - sum of withholding.
    */
    'lineNetValue': number;
    'calculatedTax': PurchaseCalculatedTax;
}

export namespace PurchaseLinesOut {
    export enum UseTypeEnum {
        Resale = <any> 'resale',
        Production = <any> 'production',
        UseOrConsumption = <any> 'use or consumption',
        FixedAssets = <any> 'fixed assets'
    }
}
/**
* Object with summary of all taxes returned by engine
*/
export class PurchaseTaxByType {
    'issRf': TaxByTypeTax;
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'inssAr': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'cofins': TaxByTypeTax;
}

export class PurchaseTaxByTypeDetail {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': PurchaseTaxByTypeDetail.JurisdictionTypeEnum;
    /**
    * Tax identificator - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inssAr' - 'inssRf' - 'issRf' 
    */
    'taxType': PurchaseTaxByTypeDetail.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
    */
    'taxRuleType': PurchaseTaxByTypeDetail.TaxRuleTypeEnum;
}

export namespace PurchaseTaxByTypeDetail {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        Pis = <any> 'pis',
        PisRf = <any> 'pisRf',
        Cofins = <any> 'cofins',
        CofinsRf = <any> 'cofinsRf',
        Csll = <any> 'csll',
        CsllRf = <any> 'csllRf',
        Irrf = <any> 'irrf',
        InssAr = <any> 'inssAr',
        InssRf = <any> 'inssRf',
        IssRf = <any> 'issRf'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class PurchaseTaxesConfig {
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'entityAccruableCOFINSTaxation': PurchaseTaxesConfig.EntityAccruableCOFINSTaxationEnum;
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.   This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
    */
    'entityAccruableCSLLTaxation': PurchaseTaxesConfig.EntityAccruableCSLLTaxationEnum;
    /**
    * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'entityAccruablePISTaxation': PurchaseTaxesConfig.EntityAccruablePISTaxationEnum;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
    */
    'accruableCOFINSExempCodeTaxation': string;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
    */
    'accruablePISExempCodeTaxation': string;
    /**
    * When Code is 999 the user system need send the custom reason to Exemption
    */
    'accruablePISExemptReasonTaxation': string;
    /**
    * When Code is 999 the user system need send the custom reason to Exemption
    */
    'accruableCOFINSExemptReasonTaxation': string;
    /**
    * CSLL no withholding Custom Reason
    */
    'accruableCSLLExemptReasonTaxation': string;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingPIS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCOFINS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCSLL': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingIRRF': boolean;
    /**
    * COFINS no withholding Custom Reason
    */
    'withholdCOFINSExemptReasonTaxation': string;
    /**
    * CSLL no withholding Custom Reason
    */
    'withholdCSLLExemptReasonTaxation': string;
    /**
    * PIS no withholding Custom Reason
    */
    'withholdPISExemptReasonTaxation': string;
}

export namespace PurchaseTaxesConfig {
    export enum EntityAccruableCOFINSTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
    export enum EntityAccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum EntityAccruablePISTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
}
export class PurchaseTransactionIn {
    'header': PurchaseHeaderIn;
    'lines': Array<PurchaseLinesIn>;
}

export class PurchaseTransactionOut {
    'header': PurchaseHeaderOut;
    'lines': Array<PurchaseLinesOut>;
    'calculatedTaxSummary': PurchaseCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class ReceiptTransactionIn {
    'header': PayRecHeader;
    'lines': Array<PaymentLinesIn>;
}

export class ReceiptTransactionOut {
    'header': PayRecHeader;
    'lines': Array<PayRecLinesOut>;
    'calculatedTaxSummary': PayRecCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class SalesCalculatedTax {
    'taxByType': SalesTaxByType;
    /**
    * Sum of tax type not VAT (Value Added Tax)
    */
    'tax': number;
    'details': Array<SalesTaxByTypeDetail>;
}

export class SalesCalculatedTaxSummaryForService {
    /**
    * Count of lines
    */
    'numberOfLines': number;
    /**
    * sum of all line tax attribute
    */
    'subtotal': number;
    /**
    * sum of all line lineAmount attribute
    */
    'totalTax': number;
    /**
    * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
    */
    'grandTotal': number;
    'taxByType': SalesCalculatedTaxSummaryForServiceTaxByType;
}

/**
* Object with summary of all taxes returned by engine
*/
export class SalesCalculatedTaxSummaryForServiceTaxByType {
    'pisRf': TaxByTypeSummaryForService;
    'cofinsRf': TaxByTypeSummaryForService;
    'csllRf': TaxByTypeSummaryForService;
    'irrf': TaxByTypeSummaryForService;
    'inssRf': TaxByTypeSummaryForService;
    'pis': TaxByTypeSummaryForService;
    'cofins': TaxByTypeSummaryForService;
    'csll': TaxByTypeSummaryForService;
    'issRf': TaxByTypeSummaryForService;
    'iss': TaxByTypeSummaryForService;
    'aproxtribCity': TaxByTypeSummaryForService;
    'aproxtribFed': TaxByTypeSummaryForService;
    'irpj': TaxByTypeSummaryForService;
    'inss': TaxByTypeSummaryForService;
}

/**
* This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
*/
export class SalesDefaultLocations {
    'serviceRendered': ServiceRendered;
}

export class SalesEntity {
    /**
    * SERVICE BUYER NAME OFFICIAL
    */
    'name': string;
    'type': EntityType;
    /**
    * Entity Email
    */
    'email': string;
    /**
    * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
    */
    'cnpjcpf': string;
    /**
    * City Tax ID
    */
    'cityTaxId': string;
    /**
    * State Tax ID
    */
    'stateTaxId': string;
    /**
    * Suframa ID
    */
    'suframa': string;
    /**
    * Entity Phone
    */
    'phone': string;
    'taxRegime': FederalTaxRegime;
    /**
    * Entity Special Tax Regime  - 'MEM' # Microempresa municipal - 'EST' # Estimativa - 'SPR' # Sociedade de profissionais - 'COP' # Cooperativa - 'MEI' # Microempresário Individual (MEI) - 'MPP' # Microempresário e Empresa de Pequeno Porte (ME EPP) 
    */
    'specialTaxRegime': SalesEntity.SpecialTaxRegimeEnum;
    /**
    * Companies subject to rule follow same rule of Government
    */
    'subjectToSRF1234': boolean;
    /**
    * If Withholding ISS is required, independently the rules applied.
    */
    'requiredWithholdingISS': boolean;
    /**
    * technical note. Anota\\u00e7\\u00e3o de Responsabilidade T\\u00e9cnica-ART, estabelece que todos os contratos referentes à  execu\\u00e7\\u00e3o de servi\\u00e7os ou obras de Engenharia, Agronomia, Geologia, Geografia ou Meteorologia dever\\u00e3o ser objeto de anota\\u00e7\\u00e3o no Conselho Regional de Engenharia e Agronomia
    */
    'art': string;
    /**
    * PROCESS NUMBER TO ISS SUSPENDED FOR ADMINISTRATIVE PROCESS
    */
    'adminProcess': string;
    /**
    * Business code. Código da obra OBRA
    */
    'buildCode': string;
}

export namespace SalesEntity {
    export enum SpecialTaxRegimeEnum {
        MEM = <any> 'MEM',
        EST = <any> 'EST',
        SPR = <any> 'SPR',
        COP = <any> 'COP',
        MEI = <any> 'MEI',
        MPP = <any> 'MPP'
    }
}
export class SalesHeaderIn {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': SalesHeaderIn.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    /**
    * Provisional receipt services, sequencial number maintained by the client application, unique by serie
    */
    'rpsNumber': number;
    /**
    * set name identifier for rps number sequency.
    */
    'rpsSerie': string;
    /**
    * Service discrimination, free description about service
    */
    'discriminationIn': string;
    'entity': SalesEntity;
    'payment': SalesHeaderInPayment;
    'taxesConfig': SalesTaxesConfig;
    'defaultLocations': SalesDefaultLocations;
}

export namespace SalesHeaderIn {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
}
export class SalesHeaderInPayment {
    'terms': PaymentTerms;
    /**
    * installments
    */
    'installments': Array<SalesInstallmentIn>;
}

export class SalesHeaderOut {
    /**
    * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
    */
    'transactionType': SalesHeaderOut.TransactionTypeEnum;
    /**
    * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
    */
    'documentCode': string;
    /**
    * currency code / transactions must be in Brazilian Reais \"BRL\"
    */
    'currency': string;
    /**
    * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
    */
    'transactionDate': Date;
    /**
    * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
    */
    'taxCalculationDate': Date;
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * The number of Purchase Order
    */
    'purchaseOrderNumber': string;
    /**
    * Provisional receipt services, sequencial number maintained by the client application, unique by serie
    */
    'rpsNumber': number;
    /**
    * set name identifier for rps number sequency.
    */
    'rpsSerie': string;
    /**
    * Service discrimination, free description about service
    */
    'discriminationIn': string;
    'entity': SalesEntity;
    'payment': SalesHeaderOutPayment;
    'taxesConfig': SalesTaxesConfig;
    'defaultLocations': SalesDefaultLocations;
    /**
    * Invoice discrimination, it is discriminationIn plus automatic messages
    */
    'discriminationOut': string;
    /**
    * RPS XML or NFSe XML generated, when the client system doesn't have EDI with government then BR16 return RPS when transaction is created.
    */
    'xml': string;
    /**
    * Service sales usually has a EDI integration with government to get Final document or Authorization. This is external process and the integration status is followed by this property. - 'STORED' - 'WAITING APPROVAL' - 'AUTHORIZED' - 'AUTHORIZED with NOTE' - 'ERROR' - 'CANCELED REPLACED' - 'CANCELED' - 'CANCELLATION REQUESTED' 
    */
    'ediSyncState': SalesHeaderOut.EdiSyncStateEnum;
}

export namespace SalesHeaderOut {
    export enum TransactionTypeEnum {
        Sale = <any> 'Sale',
        Purchase = <any> 'Purchase',
        Payment = <any> 'Payment',
        Receipt = <any> 'Receipt'
    }
    export enum EdiSyncStateEnum {
        STORED = <any> 'STORED',
        WAITINGAPPROVAL = <any> 'WAITING APPROVAL',
        AUTHORIZED = <any> 'AUTHORIZED',
        AUTHORIZEDWithNOTE = <any> 'AUTHORIZED with NOTE',
        ERROR = <any> 'ERROR',
        CANCELEDREPLACED = <any> 'CANCELED REPLACED',
        CANCELED = <any> 'CANCELED',
        CANCELLATIONREQUESTED = <any> 'CANCELLATION REQUESTED'
    }
}
export class SalesHeaderOutPayment {
    'terms': PaymentTerms;
    /**
    * To avoid having to verify multiple attributes from a Invoice at the time of funds collection which subject to Tax Withholding, this attribute will allow a referenced Invoice to be quickly checked for withholdings during the cash transaction. This is an SALES.Transaction attribute to be consisted in the Tax Engine that can be used during the receivable process. The values are enumeration where each letter identify if that tax has been withheld PCC,xxx, PCx, PxC ...
    */
    'withholdingMode': WithholdingMode;
    /**
    * installments
    */
    'installments': Array<InstallmentComplete>;
}

export class SalesInstallmentIn {
    /**
    * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
    */
    'documentNumber': string;
    /**
    * installment Due Date
    */
    'date': Date;
    /**
    * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
    */
    'grossValue': number;
}

export class SalesLinesIn {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    'taxDeductions': SalesLinesInTaxDeductions;
}

export class SalesLinesInTaxDeductions {
    /**
    * Deduction amount not taxable by ISS . Example constructions materials included in a service invoice
    */
    'iss': number;
}

export class SalesLinesOut {
    /**
    * This string is a unique identifier for this line in the transaction
    */
    'lineCode': number;
    /**
    * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
    */
    'itemCode': string;
    /**
    * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
    */
    'numberOfItems': number;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
    */
    'lineAmount': number;
    /**
    * This string captures the description of the item represented by this line, will be used LC 116
    */
    'itemDescription': string;
    /**
    * Conditional discount
    */
    'lineTaxedDiscount': number;
    /**
    * Unconditional discount
    */
    'lineUntaxedDiscount': number;
    'taxDeductions': SalesLinesOutTaxDeductions;
    /**
    * AGAST CODE for itemCode
    */
    'avalaraGoodsAndServicesType': string;
    /**
    * This decimal captures the total cost of this line. In its simplest form lineNetValue = (lineAmount - discountTaxable - sum of whithholdings).
    */
    'lineNetValue': number;
    /**
    * - '01' # ORIGIN MODE - '02' # ORIGIN MODE BUT EXEMPT - '03' # ORIGIN MODE BUT IMMUNE - '04' # ORIGIN MODE BUT SUSPENDED FOR LEGAL REASON - '05' # ORIGIN MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '21' # DESTINATION MODE - '22' # DESTINATION MODE BUT EXEMPT - '23' # DESTINATION MODE BUT IMMUNE - '24' # DESTINATION MODE BUT SUSPENDED - '25' # DESTINATION MODE BUT SUSPENDED - '40' # FOREIGN IMMUNE MODE 
    */
    'cst': SalesLinesOut.CstEnum;
    /**
    * - '61' # WITHHOLD NORMAL MODE - '62' # WITHHOLD NORMAL MODE BUT EXEMPT - '63' # WITHHOLD NORMAL MODE BUT IMMUNE - '64' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR LEGAL REASON - '65' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '66' # WITHHOLD FORCED MODE - '67' # WITHHOLD FORCED MODE BUT EXEMPT - '68' # WITHHOLD FORCED MODE BUT IMMUNE - '69' # WITHHOLD FORCED MODE BUT SUSPENDED FOR LEGAL REASON - '70' # WITHHOLD FORCED MODE BUT SUSPENDED FOR ADMINISTRATIVE PROCESS - '71' # NO WITHHOLD MODE - '72' # NO WITHHOLD FOREIGN MODE 
    */
    'cstRf': SalesLinesOut.CstRfEnum;
    'calculatedTax': SalesCalculatedTax;
}

export namespace SalesLinesOut {
    export enum CstEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _21 = <any> '21',
        _22 = <any> '22',
        _23 = <any> '23',
        _24 = <any> '24',
        _25 = <any> '25',
        _40 = <any> '40'
    }
    export enum CstRfEnum {
        _61 = <any> '61',
        _62 = <any> '62',
        _63 = <any> '63',
        _64 = <any> '64',
        _65 = <any> '65',
        _66 = <any> '66',
        _67 = <any> '67',
        _68 = <any> '68',
        _69 = <any> '69',
        _70 = <any> '70',
        _71 = <any> '71',
        _72 = <any> '72'
    }
}
export class SalesLinesOutTaxDeductions {
    /**
    * Deduction amount not ISS taxable. Example Building material
    */
    'iss': number;
}

/**
* Object with summary of all taxes returned by engine
*/
export class SalesTaxByType {
    'pisRf': TaxByTypeTax;
    'cofinsRf': TaxByTypeTax;
    'csllRf': TaxByTypeTax;
    'irrf': TaxByTypeTax;
    'inssRf': TaxByTypeTax;
    'pis': TaxByTypeTax;
    'cofins': TaxByTypeTax;
    'csll': TaxByTypeTax;
    'issRf': TaxByTypeTax;
    'iss': TaxByTypeTax;
    'aproxtribCity': TaxByTypeTax;
    'aproxtribFed': TaxByTypeTax;
    'irpj': TaxByTypeTax;
    'inss': TaxByTypeTax;
}

export class SalesTaxByTypeDetail {
    /**
    * This string captures the applicable location type. Location used for calc. Buyer or Seller
    */
    'locationType': string;
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': SalesTaxByTypeDetail.JurisdictionTypeEnum;
    /**
    * Tax identificator - 'aproxtribCity' - 'aproxtribFed' - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inss' - 'inssRf' - 'iss' - 'issRf' - 'irpj' 
    */
    'taxType': SalesTaxByTypeDetail.TaxTypeEnum;
    /**
    * Name of configuration rate
    */
    'rateType': string;
    /**
    * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
    */
    'scenario': string;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax, calc base
    */
    'subtotalTaxable': number;
    /**
    * This decimal captures the tax rate for this tax.3.00 (3%)
    */
    'rate': number;
    /**
    * This decimal captures how much of the lineAmount was taxable by this tax
    */
    'tax': number;
    /**
    * This string is required if is exempt
    */
    'exemptionCode': string;
    /**
    * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
    */
    'significantLocations': Array<string>;
    /**
    * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
    */
    'taxRuleType': SalesTaxByTypeDetail.TaxRuleTypeEnum;
}

export namespace SalesTaxByTypeDetail {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
    export enum TaxTypeEnum {
        AproxtribCity = <any> 'aproxtribCity',
        AproxtribFed = <any> 'aproxtribFed',
        Pis = <any> 'pis',
        PisRf = <any> 'pisRf',
        Cofins = <any> 'cofins',
        CofinsRf = <any> 'cofinsRf',
        Csll = <any> 'csll',
        CsllRf = <any> 'csllRf',
        Irrf = <any> 'irrf',
        Inss = <any> 'inss',
        InssRf = <any> 'inssRf',
        Iss = <any> 'iss',
        IssRf = <any> 'issRf',
        Irpj = <any> 'irpj'
    }
    export enum TaxRuleTypeEnum {
        SELLER = <any> 'SELLER',
        BUYER = <any> 'BUYER',
        TRANSACTION = <any> 'TRANSACTION',
        ITEM = <any> 'ITEM',
        TAX = <any> 'TAX'
    }
}
export class SalesTaxesConfig {
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'accruableCOFINSTaxation': SalesTaxesConfig.AccruableCOFINSTaxationEnum;
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
    */
    'accruableCSLLTaxation': SalesTaxesConfig.AccruableCSLLTaxationEnum;
    /**
    * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
    */
    'accruablePISTaxation': SalesTaxesConfig.AccruablePISTaxationEnum;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
    */
    'accruableCOFINSExempCodeTaxation': string;
    /**
    * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
    */
    'accruablePISExempCodeTaxation': string;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCOFINS': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingCSLL': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingIRRF': boolean;
    /**
    * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
    */
    'withholdingPIS': boolean;
    /**
    * When property withholdingIRRF is false is mandatory inform the reason
    */
    'withholdIRRFExemptReasonTaxation': string;
}

export namespace SalesTaxesConfig {
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
    export enum AccruableCSLLTaxationEnum {
        T = <any> 'T',
        E = <any> 'E'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        N = <any> 'N',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        S = <any> 'S'
    }
}
export class SalesTransactionIn {
    'header': SalesHeaderIn;
    'lines': Array<SalesLinesIn>;
}

export class SalesTransactionOut {
    'header': SalesHeaderOut;
    'lines': Array<SalesLinesOut>;
    'calculatedTaxSummary': SalesCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class SefazDisableRangeIn {
    /**
    * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
    */
    'companyLocation': string;
    /**
    * This string indicates the type of transaction for which tax should be calculated. - '55' # Nota Fiscal Eletrônica (NF-e) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
    */
    'transactionModel': SefazDisableRangeIn.TransactionModelEnum;
    /**
    * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
    */
    'invoiceSerial': number;
    'year': number;
    'message': string;
    /**
    * First number of disable range.
    */
    'invoiceNumberInit': number;
    /**
    * Last number of disable range.
    */
    'invoiceNumberEnd': number;
}

export namespace SefazDisableRangeIn {
    export enum TransactionModelEnum {
        _55 = <any> '55',
        _65 = <any> '65'
    }
}
export class SefazInvoiceBasicStatus {
    'code': string;
    'desc': string;
}

export class SefazInvoiceStatus {
    'code': string;
    'desc': string;
    'protocol': string;
    'rec': string;
    'date': Date;
    /**
    * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação 
    */
    'environment': SefazInvoiceStatus.EnvironmentEnum;
    'appVersion': string;
}

export namespace SefazInvoiceStatus {
    export enum EnvironmentEnum {
        _1 = <any> '1',
        _2 = <any> '2'
    }
}
export class SefazItDeleteIn {
    'message': string;
}

export class SefazItGetOut {
    /**
    * Invoice Access Key
    */
    'key': string;
    /**
    * XML Signed
    */
    'xml': string;
    'status': SefazInvoiceStatus;
}

export class SefazItPutIn {
    'code': string;
    'text': string;
}

export class SefazPostOut {
    'key': string;
    'documentCode': string;
    'status': SefazInvoiceStatus;
}

export class ServiceItemTaxRate {
    'taxType': string;
    'rateType': string;
    'rate': number;
    'isExempt': boolean;
    'discount': number;
    'zone1': number;
    'zone2': number;
    'period': ServiceItemTaxRatePeriod;
    'reason': string;
    'message': string;
}

export class ServiceItemTaxRatePeriod {
    'startDate': Date;
    'expirationDate': Date;
}

/**
* Address where the rendered service.
*/
export class ServiceRendered {
    'address': SimpleAddress;
}

export class SimpleAddress {
    /**
    * Address
    */
    'line1': string;
    /**
    * Number
    */
    'line2': string;
    /**
    * District
    */
    'line3': string;
    'city': string;
    /**
    * Brazilian Zip Code
    */
    'zipcode': string;
    'state': StateEnum;
    /**
    * Use ISO 3166-1 alpha-3 codes
    */
    'country': string;
}

/**
* State Abreviation: - 'AC' - 'AL' - 'AP' - 'AM' - 'BA' - 'CE' - 'DF' - 'ES' - 'GO' - 'MA' - 'MT' - 'MS' - 'MG' - 'PA' - 'PB' - 'PR' - 'PE' - 'PI' - 'RJ' - 'RN' - 'RS' - 'RO' - 'RR' - 'SC' - 'SP' - 'SE' - 'TO' 
*/
export class StateEnum {
}

export class StateTransition {
    /**
    * - 'voided' # Send this event to a Recorded tax transaction record to mark it as voided. - 'unvoided' # Send this event to a Voided tax transaction record to mark it as recorded. - 'reconciled' # Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. - 'unreconciled' # Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state. - 'filed' # Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. - 'unfiled' # Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system. - 'filedByAvalara' # This event can only be sent by Avalara Systems. 
    */
    'type': StateTransition.TypeEnum;
    'comment': string;
}

export namespace StateTransition {
    export enum TypeEnum {
        Voided = <any> 'voided',
        Unvoided = <any> 'unvoided',
        Reconciled = <any> 'reconciled',
        Unreconciled = <any> 'unreconciled',
        Filed = <any> 'filed',
        Unfiled = <any> 'unfiled',
        FiledByAvalara = <any> 'filedByAvalara'
    }
}
/**
* summary of all taxes
*/
export class TaxByTypeSummaryForGoods {
    /**
    * sum of all lines calcbase
    */
    'calcbase': number;
    /**
    * sum of referenced tax value
    */
    'tax': number;
    'jurisdictions': Array<TaxByTypeSummaryJurisdictionForGoods>;
}

/**
* summary of all taxes
*/
export class TaxByTypeSummaryForService {
    /**
    * sum of referenced tax value
    */
    'tax': number;
    'jurisdictions': Array<TaxByTypeSummaryJurisdiction>;
}

export class TaxByTypeSummaryJurisdiction {
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': TaxByTypeSummaryJurisdiction.JurisdictionTypeEnum;
    /**
    * sum of referenced tax value by jurisdiction
    */
    'tax': number;
}

export namespace TaxByTypeSummaryJurisdiction {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class TaxByTypeSummaryJurisdictionForGoods {
    /**
    * Jurisdiction used for calctax amount
    */
    'jurisdictionName': string;
    /**
    * Type of jurisdiction - 'City' - 'State' - 'Country' 
    */
    'jurisdictionType': TaxByTypeSummaryJurisdictionForGoods.JurisdictionTypeEnum;
    /**
    * sum of referenced tax value by jurisdiction
    */
    'tax': number;
}

export namespace TaxByTypeSummaryJurisdictionForGoods {
    export enum JurisdictionTypeEnum {
        City = <any> 'City',
        State = <any> 'State',
        Country = <any> 'Country'
    }
}
export class TaxByTypeTax {
    /**
    * Tax value, negative value for withhold value
    */
    'tax': number;
}

export class TaxConf {
    /**
    * main unique identificator
    */
    'code': string;
    /**
    * Inform that the process has inventory impact.
    */
    'stockImpact': boolean;
    /**
    * Inform that the process has financial impact.
    */
    'financialImpact': boolean;
    /**
    * Inform if this process is subject to IPI taxation on output process - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'I'  # IMMUNE - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'cstIPI': TaxConf.CstIPIEnum;
    /**
    * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
    */
    'ipiLegalTaxClass': string;
    /**
    * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE - 'O' # OTHER - 'OZ'# OTHER AND ZERO VALUES 
    */
    'accruablePISTaxation': TaxConf.AccruablePISTaxationEnum;
    /**
    * Reference to a tax reason record ID.
    */
    'pisExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'pisExemptLegalReason': string;
    /**
    * Inform if this item by nature is subject to COFINS taxation or exempt - 'T'  # TAXABLE - 'Z'  # TAXABLE WITH RATE=0.00 - 'E'  # EXEMPT - 'H'  # SUSPENDED - 'N'  # NO TAXABLE     - 'O'  # OTHER - 'OZ' # OTHER AND ZERO VALUES 
    */
    'accruableCOFINSTaxation': TaxConf.AccruableCOFINSTaxationEnum;
    /**
    * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
    */
    'cofinsExemptLegalReasonCode': string;
    /**
    * When specifi reason, this field has the description
    */
    'cofinsExemptLegalReason': string;
    /**
    * Inform that the process allow IPI credit to Input process
    */
    'allowIPIcreditWhenInGoing': boolean;
    /**
    * the map key is state code
    */
    'icmsConf': Array<IcmsTaxConf>;
}

export namespace TaxConf {
    export enum CstIPIEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        I = <any> 'I',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruablePISTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
    export enum AccruableCOFINSTaxationEnum {
        T = <any> 'T',
        Z = <any> 'Z',
        E = <any> 'E',
        H = <any> 'H',
        N = <any> 'N',
        O = <any> 'O',
        OZ = <any> 'OZ'
    }
}
/**
* Tax Rate Obs: AR - \"a recolher\" (serviço). RP e PP - filtrado para alvos de lucro real ou lucro presumido (serviço) 
*/
export class TaxType {
}

export class TaxTypeRate {
    'taxType': TaxType;
    /**
    * Tax can be calculated by rate or by quantity
    */
    'taxModel': TaxTypeRate.TaxModelEnum;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'rate': number;
    /**
    * Specific tax rate ex 3.5 (3.5%)
    */
    'srvAmount': number;
    'quantityUnidBase': string;
    'specializationType': TaxTypeRate.SpecializationTypeEnum;
}

export namespace TaxTypeRate {
    export enum TaxModelEnum {
        Rate = <any> 'rate',
        Srf = <any> 'srf'
    }
    export enum SpecializationTypeEnum {
        Basic = <any> 'basic',
        Monophase = <any> 'monophase',
        TaxSubstitution = <any> 'taxSubstitution'
    }
}
export class TransactionForAbrasf {
    'header': SalesHeaderOut;
    'lines': Array<SalesLinesOut>;
    'calculatedTaxSummary': SalesCalculatedTaxSummaryForService;
    'processingInfo': ProcessingInfo;
}

export class TransactionForAbrasfList extends Array<TransactionForAbrasf> {
}

export class TransactionForGoodsIn {
    'header': HeaderForGoods;
    'lines': Array<LineForGoods>;
}

export class TransactionForGoodsOut {
    'header': HeaderForGoods;
    'lines': Array<LineForGoods>;
    'calculatedTaxSummary': CalculatedTaxSummaryForGoods;
    'processingInfo': ProcessingInfo;
}

export class TransactionForSefazGoods {
    'header': HeaderForGoods;
    'lines': Array<LineForSefazGoods>;
    'calculatedTaxSummary': CalculatedTaxSummaryForGoods;
}

export class TransactionForSefazGoodsList extends Array<TransactionForSefazGoods> {
}

export class Transport {
    /**
    * Freight model  - 0 - CIF,  - 1 - FOB,  - 2 - Thrid party, - 9 - Free shipping when 9 - Free shipping, the fields below will be ignored if present - 'transporter' - 'withholdICMSTransport' - 'volumes' - 'vehicle' 
    */
    'modFreight': Transport.ModFreightEnum;
    /**
    * Forces witholding of ICMS on transport amount (freight)
    */
    'withholdICMSTransport': boolean;
    /**
    * Packages
    */
    'volumes': Array<TransportVolumes>;
    'vehicle': VehicleTransp;
}

export namespace Transport {
    export enum ModFreightEnum {
        CIF = <any> 'CIF',
        FOB = <any> 'FOB',
        Thridparty = <any> 'Thridparty',
        FreeShipping = <any> 'FreeShipping'
    }
}
export class TransportVolumes {
    /**
    * Quantity of packages transported
    */
    'qVol': string;
    /**
    * package type
    */
    'specie': string;
    /**
    * brand
    */
    'brand': string;
    /**
    * packages numeration
    */
    'volumeNumeration': string;
    /**
    * net weight using Kg
    */
    'netWeight': number;
    /**
    * gross weight using Kg
    */
    'grossWeight': number;
    'seal': Array<string>;
}

export class ValidationError {
    'message': string;
    'errors': Array<ModelError>;
}

export class Vehicle {
    /**
    * - 1 # Sales by car dealership - 2 # Direct billing - 3 # Direct sales - 0 # Other 
    */
    'tpOp': number;
    'chassisNumber': string;
    /**
    * color code used by factory
    */
    'colorCode': string;
    /**
    * color name
    */
    'colorName': string;
    /**
    * Power using CV unid
    */
    'cvPower': string;
    /**
    * engine size in cubic centimeters
    */
    'cylinderVolumCC': string;
    /**
    * net weight
    */
    'netWeight': string;
    /**
    * gross weight
    */
    'grossWeight': string;
    /**
    * serie
    */
    'serialNumber': string;
    /**
    * - '01' # Alcohol - '02' # Gas - '03' # Diesel - '16' # Alcohol/Gas - '17' # Gas/Alcohol/GNV - '18' # Gas/Electric 
    */
    'fuelType': Vehicle.FuelTypeEnum;
    /**
    * engine number
    */
    'engineNumber': string;
    /**
    * traction capacity, tonne
    */
    'cmt': string;
    /**
    * length between axis
    */
    'lengthBetweenAxis': string;
    /**
    * model year
    */
    'modelYear': string;
    /**
    * year of factory
    */
    'manufactoryYear': string;
    /**
    * paynt type
    */
    'paintType': string;
    'vehicleRENAVAMType': string;
    'specieRENAVAMType': string;
    'modelRENAVAMCode': string;
    /**
    * - '01' # YELLOW - '02' # BLUE - '03' # BEIGE - '04' # WHITE - '05' # GRAY - '06' # GOLDEN - '07' # GRENA - '08' # ORANGE - '09' # BROWN - '10' # SILVER - '11' # BLACK - '12' # PINK - '13' # PURPLE - '14' # GREEN - '15' # RED - '16' # FANTASY 
    */
    'colorDENATRANCode': Vehicle.ColorDENATRANCodeEnum;
    /**
    * chassis condition original or modified (remarcado)
    */
    'vin': Vehicle.VinEnum;
    /**
    * - '1' # Finished(Done) - '2' # Not finished - '3' # Semi-finished 
    */
    'vehicleManufactoryStatus': Vehicle.VehicleManufactoryStatusEnum;
    /**
    * max number of sit occupants
    */
    'maxOccupantsQuantity': string;
    /**
    * Lien/restriction type - '0' # No one; - '1' # Alienação Fiduciária; - '2' # Arrendamento Mercantil; - '3' # Reserva de Domínio; - '4' # Penhor de Veículos; - '9' # Other. 
    */
    'restrictionType': Vehicle.RestrictionTypeEnum;
}

export namespace Vehicle {
    export enum FuelTypeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _16 = <any> '16',
        _17 = <any> '17',
        _18 = <any> '18'
    }
    export enum ColorDENATRANCodeEnum {
        _01 = <any> '01',
        _02 = <any> '02',
        _03 = <any> '03',
        _04 = <any> '04',
        _05 = <any> '05',
        _06 = <any> '06',
        _07 = <any> '07',
        _08 = <any> '08',
        _09 = <any> '09',
        _10 = <any> '10',
        _11 = <any> '11',
        _12 = <any> '12',
        _13 = <any> '13',
        _14 = <any> '14',
        _15 = <any> '15',
        _16 = <any> '16'
    }
    export enum VinEnum {
        R = <any> 'R',
        N = <any> 'N'
    }
    export enum VehicleManufactoryStatusEnum {
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3'
    }
    export enum RestrictionTypeEnum {
        _0 = <any> '0',
        _1 = <any> '1',
        _2 = <any> '2',
        _3 = <any> '3',
        _4 = <any> '4',
        _9 = <any> '9'
    }
}
export class VehicleID {
    'licensePlate': string;
    'stateCode': StateEnum;
    /**
    * Cargo Transport National Register, Registro Nacional de Transportador de Carga (ANTT)
    */
    'rtnc': string;
}

/**
* Identify type of vehicle used to transport the attributes, except atribute type,  follow rule allOf then only one of this atributes will be informed. 
*/
export class VehicleTransp {
    'type': VehicleTransp.TypeEnum;
    'automobile': VehicleID;
    /**
    * Trailer
    */
    'trailer': Array<VehicleID>;
    'wagon': string;
    /**
    * Ferry
    */
    'ferry': string;
}

export namespace VehicleTransp {
    export enum TypeEnum {
        Automobile = <any> 'automobile',
        Wagon = <any> 'wagon',
        Ferry = <any> 'ferry',
        Trailer = <any> 'trailer'
    }
}
export class Weapon {
    /**
    * - '0' # restrict use - '1' # public use 
    */
    'weaponRestrictionType': Weapon.WeaponRestrictionTypeEnum;
    'serieNumber': string;
    /**
    * Barrel's serial number. Número de série do cano 
    */
    'gunBarrelSerieNumber': string;
    /**
    * weapon description
    */
    'weaponDescription': string;
}

export namespace Weapon {
    export enum WeaponRestrictionTypeEnum {
        _0 = <any> '0',
        _1 = <any> '1'
    }
}
/**
* Using the placing reference in PCC for PIS (P), COFINS (C) and COFINS (C).  x = tax is not subject to withholding.  - 'xxx' - 'PCC' - 'PCx' - 'PxC' - 'Pxx' - 'xCC' - 'xxC' - 'xCx' 
*/
export class WithholdingMode {
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AGASTApiApiKeys {
}

export class AGASTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AGASTApiApiKeys, value: string) {
        this.authentications[AGASTApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create agast
     * This method operation create a AGAST 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public createAgast (authorization: string, body: Agast) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/agasts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete Agast
     * Delete Agast
     * @param authorization Bearer {auth}
     * @param code Agast Code
     */
    public deleteAgast (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get agast
     * This operation return agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param code Agast Code
     */
    public getAgast (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body: Agast;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Agast;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param text Text query
     */
    public getAgastList (authorization: string, text?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }> {
        const localVarPath = this.basePath + '/agasts';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAgastList.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update agast
     * This method operation create a agast 
     * @param authorization Bearer {auth}
     * @param code Agast Code
     * @param body Transaction Message
     */
    public updateAgast (authorization: string, code: string, body: Agast) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/agasts/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AccountApiApiKeys {
}

export class AccountApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AccountApiApiKeys, value: string) {
        this.authentications[AccountApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param body Company Code
     */
    public createAccountCompany (authorization: string, accountId: string, body: Body) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies'
            .replace('{' + 'accountId' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createAccountCompany.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAccountCompany.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAccountCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     */
    public getCompaniesList (authorization: string, accountId: string) : Promise<{ response: http.ClientResponse; body: Array<AccountCompany>;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies'
            .replace('{' + 'accountId' + '}', String(accountId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompaniesList.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getCompaniesList.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<AccountCompany>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AddressApiApiKeys {
}

export class AddressApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AddressApiApiKeys, value: string) {
        this.authentications[AddressApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * This operation return address
     * @param authorization Bearer {auth}
     * @param zipcode ZIP Code
     */
    public getZipCode (authorization: string, zipcode: string) : Promise<{ response: http.ClientResponse; body: Array<Address>;  }> {
        const localVarPath = this.basePath + '/addresses/{zipcode}'
            .replace('{' + 'zipcode' + '}', String(zipcode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getZipCode.');
        }

        // verify required parameter 'zipcode' is not null or undefined
        if (zipcode === null || zipcode === undefined) {
            throw new Error('Required parameter zipcode was null or undefined when calling getZipCode.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Address>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthApiApiKeys {
}

export class AuthApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AuthApiApiKeys, value: string) {
        this.authentications[AuthApiApiKeys[key]].apiKey = value;
    }
    /**
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Accepts \&quot;Basic + hash\&quot;, where hash is {user}:{password} base64 encoded. 
     */
    public getAuthorization (authorization: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/v2/auth';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAuthorization.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Accepts \&quot;Basic + hash\&quot;, where hash is {user}:{password} base64 encoded. 
     */
    public getAuthorization2 (authorization: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/auth';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getAuthorization2.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyApiApiKeys {
}

export class CompanyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyApiApiKeys, value: string) {
        this.authentications[CompanyApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public createCompany (authorization: string, body: Company) : Promise<{ response: http.ClientResponse; body: Company;  }> {
        const localVarPath = this.basePath + '/companies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createCompany.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Company;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete relation Account x company
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyId Company ID
     */
    public deleteAccountCompany (authorization: string, accountId: string, companyId: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/accounts/{accountId}/companies/{companyId}'
            .replace('{' + 'accountId' + '}', String(accountId))
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteAccountCompany.');
        }

        // verify required parameter 'accountId' is not null or undefined
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAccountCompany.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteAccountCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Company
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    public deleteCompany (authorization: string, companyId: string, companyId2: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCompany.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCompany.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling deleteCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param authorization Bearer {auth}
     */
    public getCompaniesList (authorization: string) : Promise<{ response: http.ClientResponse; body: Array<Company>;  }> {
        const localVarPath = this.basePath + '/companies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompaniesList.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Company>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get company information and your data configuration
     * This method operation get a company for a account 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     */
    public infoCompany (authorization: string, companyId: string) : Promise<{ response: http.ClientResponse; body: Company;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling infoCompany.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling infoCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Company;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update company information and your data configuration
     * This method operation create a company for a account 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public updateCompany (authorization: string, companyId: string, body: Company) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCompany.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCompany.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCompany.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyAGASTApiApiKeys {
}

export class CompanyAGASTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyAGASTApiApiKeys, value: string) {
        this.authentications[CompanyAGASTApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    public createCustomAgast (authorization: string, companyId: string, body: CustomAgast, text?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createCustomAgast.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomAgast.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Custom Agast
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Agast Code
     */
    public deleteCustomAgast (authorization: string, companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCustomAgast.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCustomAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries - Alannes. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Agast Code
     * @param parent Agast parent code, means that this agast is a specialization of parent agast 
     */
    public getCompanyAgast (authorization: string, companyId: string, code: string, parent?: string) : Promise<{ response: http.ClientResponse; body: CustomAgast;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyAgast.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyAgast.');
        }

        if (parent !== undefined) {
            queryParameters['parent'] = parent;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomAgast;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param agast Custom Agast Code
     * @param parent Agast Code
     */
    public getCompanyAgastList (authorization: string, companyId: string, text?: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, agast?: string, parent?: string) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyAgastList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyAgastList.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        if (parent !== undefined) {
            queryParameters['parent'] = parent;
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2001>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Agast Code
     * @param body Transaction Message
     */
    public updateCustomAgast (authorization: string, companyId: string, code: string, body: CustomAgast) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/agasts/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCustomAgast.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomAgast.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCustomAgast.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomAgast.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyFilesApiApiKeys {
}

export class CompanyFilesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyFilesApiApiKeys, value: string) {
        this.authentications[CompanyFilesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * Deletes a company file store. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    public deleteCompanyServiceCertificate (authorization: string, companyId: string, companyId2: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling deleteCompanyServiceCertificate.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Gets an existing certificate file for this company. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param peek Use this parameter to check the existence of the file without downloading it.
     */
    public getCompanyServiceCertificate (authorization: string, companyId: string, companyId2: string, peek?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling getCompanyServiceCertificate.');
        }

        if (peek !== undefined) {
            queryParameters['peek'] = peek;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * If it still not exists, uploads a new Certificate file for this company. Send the file as a base64 string. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Content
     */
    public postCompanyServiceCertificate (authorization: string, companyId: string, body: Body3) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/certificate'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling postCompanyServiceCertificate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postCompanyServiceCertificate.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Updates an existing certificate file for this company. Send the file as a base64 string. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param body Content
     */
    public updateCompanyServiceCertificate (authorization: string, companyId: string, companyId2: string, body: Body2) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/certificate'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'companyId' + '}', String(companyId2));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCompanyServiceCertificate.');
        }

        // verify required parameter 'companyId2' is not null or undefined
        if (companyId2 === null || companyId2 === undefined) {
            throw new Error('Required parameter companyId2 was null or undefined when calling updateCompanyServiceCertificate.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCompanyServiceCertificate.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyICMSApiApiKeys {
}

export class CompanyICMSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyICMSApiApiKeys, value: string) {
        this.authentications[CompanyICMSApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create custom ICMS tax for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createICMS (authorization: string, companyId: string, body: CustomIcmsConfByState) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createICMS.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createICMS.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createICMS.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete ICMS Config
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param state Brazilian State
     */
    public deleteCustomIcmsConfByState (authorization: string, companyId: string, state: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCustomIcmsConfByState.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomIcmsConfByState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling deleteCustomIcmsConfByState.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param state Brazilian State
     */
    public getCompanyICMS (authorization: string, companyId: string, state: string) : Promise<{ response: http.ClientResponse; body: CustomIcmsConfByState;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyICMS.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyICMS.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling getCompanyICMS.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomIcmsConfByState;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public getCompanyICMSList (authorization: string, companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomIcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyICMSList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyICMSList.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomIcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation update a custom ICMS tax for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param state Brazilian State
     * @param body Transaction Message
     */
    public updateCustomIcmsConfByState (authorization: string, companyId: string, state: string, body: CustomIcmsConfByState) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/icms/{state}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCustomIcmsConfByState.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomIcmsConfByState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateCustomIcmsConfByState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomIcmsConfByState.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemCPOMServiceApiApiKeys {
}

export class CompanyItemCPOMServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemCPOMServiceApiApiKeys, value: string) {
        this.authentications[CompanyItemCPOMServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     */
    public createItemCPOM (authorization: string, companyId: string, code: string, body: ItemCpom) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createItemCPOM.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling createItemCPOM.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItemCPOM.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete item CPOM
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    public deleteItemCPOM (authorization: string, companyId: string, code: string, cityCode: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteItemCPOM.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItemCPOM.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling deleteItemCPOM.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    public getCompanyCpomCity (authorization: string, companyId: string, code: string, cityCode: number) : Promise<{ response: http.ClientResponse; body: ItemCpom;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyCpomCity.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyCpomCity.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyCpomCity.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling getCompanyCpomCity.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemCpom;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public getCompanyCpomList (authorization: string, companyId: string, code: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemCpom>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyCpomList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyCpomList.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyCpomList.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemCpom>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     * @param body Transaction Message
     */
    public updateItemCPOM (authorization: string, companyId: string, code: string, cityCode: number, body: ItemCpom) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/cpom/{cityCode}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code))
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling updateItemCPOM.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemCPOM.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemGoodsApiApiKeys {
}

export class CompanyItemGoodsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemGoodsApiApiKeys, value: string) {
        this.authentications[CompanyItemGoodsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * Change the code of a given item. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    public companyItemsChangeCode (authorization: string, companyId: string, code: string, body: Body1, goods?: string, service?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/change-code'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companyItemsChangeCode.');
        }

        if (goods !== undefined) {
            queryParameters['goods'] = goods;
        }

        if (service !== undefined) {
            queryParameters['service'] = service;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    public createItem (authorization: string, companyId: string, avalaraProductType: string, body: ItemGoods) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?goods'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createItem.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling createItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItem.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Item
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    public deleteItem (authorization: string, companyId: string, code: string, avalaraProductType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling deleteItem.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    public getCompanyItemsGoods (authorization: string, companyId: string, code: string, avalaraProductType: string, agast?: string) : Promise<{ response: http.ClientResponse; body: ItemGoods;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyItemsGoods.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyItemsGoods.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyItemsGoods.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling getCompanyItemsGoods.');
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemGoods;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    public getCompanyItemsGoodsList (authorization: string, companyId: string, avalaraProductType: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, code?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemGoods>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?goods'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyItemsGoodsList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyItemsGoodsList.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling getCompanyItemsGoodsList.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemGoods>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    public updateItem (authorization: string, companyId: string, code: string, avalaraProductType: string, body: ItemGoods) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?goods'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateItem.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItem.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItem.');
        }

        // verify required parameter 'avalaraProductType' is not null or undefined
        if (avalaraProductType === null || avalaraProductType === undefined) {
            throw new Error('Required parameter avalaraProductType was null or undefined when calling updateItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItem.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyItemServiceApiApiKeys {
}

export class CompanyItemServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyItemServiceApiApiKeys, value: string) {
        this.authentications[CompanyItemServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * Change the code of a given item. 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    public companyItemsChangeCode (authorization: string, companyId: string, code: string, body: Body1, goods?: string, service?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}/change-code'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling companyItemsChangeCode.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling companyItemsChangeCode.');
        }

        if (goods !== undefined) {
            queryParameters['goods'] = goods;
        }

        if (service !== undefined) {
            queryParameters['service'] = service;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    public createItemService (authorization: string, companyId: string, body: ItemSimple, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?service'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createItemService.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createItemService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createItemService.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Item - Service
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    public deleteItemService (authorization: string, companyId: string, code: string, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteItemService.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteItemService.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteItemService.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    public getCompanyItemsService (authorization: string, companyId: string, code: string, avalaraProductType?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: ItemSimple;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyItemsService.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyItemsService.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyItemsService.');
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ItemSimple;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    public getCompanyItemsServiceList (authorization: string, companyId: string, avalaraProductType?: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string, code?: string, agast?: string) : Promise<{ response: http.ClientResponse; body: Array<ItemSimple>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items?service'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyItemsServiceList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyItemsServiceList.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (agast !== undefined) {
            queryParameters['agast'] = agast;
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ItemSimple>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    public updateItemService (authorization: string, companyId: string, code: string, body: ItemSimple, avalaraProductType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/items/{code}?service'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateItemService.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateItemService.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateItemService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateItemService.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['Avalara-Product-Type'] = avalaraProductType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyLocationApiApiKeys {
}

export class CompanyLocationApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyLocationApiApiKeys, value: string) {
        this.authentications[CompanyLocationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create new location for company
     * This method operation create a new location for company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createLocation (authorization: string, companyId: string, body: Location) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createLocation.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createLocation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createLocation.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete location
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Location Code
     */
    public deleteLocation (authorization: string, companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteLocation.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteLocation.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return location 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Location Code
     */
    public getCompanyLocation (authorization: string, companyId: string, code: string) : Promise<{ response: http.ClientResponse; body: Location;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyLocation.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyLocation.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyLocation.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Location;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return all locations 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public getCompanyLocationsList (authorization: string, companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<Location>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyLocationsList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyLocationsList.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Location>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update location for company
     * This method operation update a location for company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Location Code
     * @param body Transaction Message
     */
    public updateLocation (authorization: string, companyId: string, code: string, body: Location) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/locations/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateLocation.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateLocation.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyProcessApiApiKeys {
}

export class CompanyProcessApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyProcessApiApiKeys, value: string) {
        this.authentications[CompanyProcessApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create custom process tax for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    public createCustomProcessScenario (authorization: string, companyId: string, body: CustomProcessScenario, text?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createCustomProcessScenario.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomProcessScenario.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomProcessScenario.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Custom Process
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Process Code
     */
    public deleteCustomProcessScenario (authorization: string, companyId: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCustomProcessScenario.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomProcessScenario.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCustomProcessScenario.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom process configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Process Code
     */
    public getCompanyProcess (authorization: string, companyId: string, code: string) : Promise<{ response: http.ClientResponse; body: CustomProcessScenario;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyProcess.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyProcess.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCompanyProcess.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom process configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public getCompanyProcessList (authorization: string, companyId: string, text?: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomProcessScenario>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyProcessList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyProcessList.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomProcessScenario>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation update a custom process for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param code Process Code
     * @param body Transaction Message
     */
    public updateCustomProcessScenario (authorization: string, companyId: string, code: string, body: CustomProcessScenario) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/process/{code}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCustomProcessScenario.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomProcessScenario.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCustomProcessScenario.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomProcessScenario.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CompanyTaxRatesApiApiKeys {
}

export class CompanyTaxRatesApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: CompanyTaxRatesApiApiKeys, value: string) {
        this.authentications[CompanyTaxRatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param body Transaction Message
     */
    public createCustomTaxes (authorization: string, companyId: string, body: CustomTaxTypeRate) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createCustomTaxes.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling createCustomTaxes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCustomTaxes.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete Custom Tax
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    public deleteCustomTaxes (authorization: string, companyId: string, taxType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCustomTaxes.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling deleteCustomTaxes.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling deleteCustomTaxes.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    public getCompanyCustomTax (authorization: string, companyId: string, taxType: string) : Promise<{ response: http.ClientResponse; body: CustomTaxTypeRate;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyCustomTax.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyCustomTax.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling getCompanyCustomTax.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CustomTaxTypeRate;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * This operation return custom agast configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    public getCompanyTaxRatesList (authorization: string, companyId: string, xPaginationLimit?: number, xPaginationCurrentPage?: number, xPaginationSort?: string) : Promise<{ response: http.ClientResponse; body: Array<CustomTaxTypeRate>;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates'
            .replace('{' + 'companyId' + '}', String(companyId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCompanyTaxRatesList.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling getCompanyTaxRatesList.');
        }

        headerParams['Authorization'] = authorization;

        headerParams['X-Pagination-Limit'] = xPaginationLimit;

        headerParams['X-Pagination-Current-Page'] = xPaginationCurrentPage;

        headerParams['X-Pagination-Sort'] = xPaginationSort;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CustomTaxTypeRate>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param authorization Bearer {auth}
     * @param companyId Company ID
     * @param taxType Tax Type
     * @param body Transaction Message
     */
    public updateCustomTaxes (authorization: string, companyId: string, taxType: string, body: CustomTaxTypeRate) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/companies/{companyId}/taxrates/{taxType}'
            .replace('{' + 'companyId' + '}', String(companyId))
            .replace('{' + 'taxType' + '}', String(taxType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCustomTaxes.');
        }

        // verify required parameter 'companyId' is not null or undefined
        if (companyId === null || companyId === undefined) {
            throw new Error('Required parameter companyId was null or undefined when calling updateCustomTaxes.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling updateCustomTaxes.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCustomTaxes.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoodsCalculationsApiApiKeys {
}

export class GoodsCalculationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GoodsCalculationsApiApiKeys, value: string) {
        this.authentications[GoodsCalculationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     * @param noPersist Do not save this calculation
     */
    public calculationGood (authorization: string, body: TransactionForGoodsIn, noPersist?: string) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/calculations?goods';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationGood.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationGood.');
        }

        if (noPersist !== undefined) {
            queryParameters['noPersist'] = noPersist;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoodsTransactionsApiApiKeys {
}

export class GoodsTransactionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GoodsTransactionsApiApiKeys, value: string) {
        this.authentications[GoodsTransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionGoodsPurchase (authorization: string, body: TransactionForGoodsIn) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }> {
        const localVarPath = this.basePath + '/transactions?goods';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionGoodsPurchase.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionGoodsPurchase.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GooodsCalculationsApiApiKeys {
}

export class GooodsCalculationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: GooodsCalculationsApiApiKeys, value: string) {
        this.authentications[GooodsCalculationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve goods transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type
     * @param documentCode Document Code
     */
    public retrieveGoodsTransactionDocument (authorization: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body: TransactionForGoodsIn;  }> {
        const localVarPath = this.basePath + '/calculations/goods/{transactionType}/{documentCode}'
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveGoodsTransactionDocument.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling retrieveGoodsTransactionDocument.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling retrieveGoodsTransactionDocument.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForGoodsIn;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceContingencyApiApiKeys {
}

export class InvoiceContingencyApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceContingencyApiApiKeys, value: string) {
        this.authentications[InvoiceContingencyApiApiKeys[key]].apiKey = value;
    }
    /**
     * Invoice Drop Contingency per State
     * Drop State in Contingency
     * @param state Brazilian State
     */
    public invoiceDropContingency (state: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceDropContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invoice Set Contingency per State
     * Set State in Contingency
     * @param state Brazilian State
     * @param body Set Contingency
     */
    public invoiceSetContingency (state: string, body: Body4) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceSetContingency.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling invoiceSetContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Invoice Verify Contingency per State
     * Check if State was in Contingency
     * @param state Brazilian State
     */
    public invoiceVerifyContingency (state: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/invoices/contingency/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling invoiceVerifyContingency.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceNFCeDANFEApiApiKeys {
}

export class InvoiceNFCeDANFEApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceNFCeDANFEApiApiKeys, value: string) {
        this.authentications[InvoiceNFCeDANFEApiApiKeys[key]].apiKey = value;
    }
    /**
     * NFCe Danfe Print
     * Retrieve the Danfe in NFCe format. 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public nfcePrint (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/invoices/nfce/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling nfcePrint.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling nfcePrint.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceNFeDANFEApiApiKeys {
}

export class InvoiceNFeDANFEApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceNFeDANFEApiApiKeys, value: string) {
        this.authentications[InvoiceNFeDANFEApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve Danfe
     * Retrieve the Danfe 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public nfePrint (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/invoices/nfe/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling nfePrint.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling nfePrint.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Buffer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceSEFAZApiApiKeys {
}

export class InvoiceSEFAZApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceSEFAZApiApiKeys, value: string) {
        this.authentications[InvoiceSEFAZApiApiKeys[key]].apiKey = value;
    }
    /**
     * Cancel invoice
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    public cancelInvoice (authorization: string, key: string, body: SefazItDeleteIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling cancelInvoice.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling cancelInvoice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cancelInvoice.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Disable Range e-Invoice
     * Send disable range of NFes to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Disable Range e-Invoice
     */
    public disableRange (authorization: string, body: SefazDisableRangeIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling disableRange.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling disableRange.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Fix Letter
     * Fix Letter
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Fix Message
     */
    public fixLetter (authorization: string, key: string, body: SefazItPutIn) : Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling fixLetter.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling fixLetter.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling fixLetter.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazInvoiceBasicStatus;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public retrieveInvoice (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: SefazItGetOut;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveInvoice.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling retrieveInvoice.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazItGetOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public retrieveInvoiceLookup (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: TransactionForSefazGoodsList;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/{key}/lookup'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveInvoiceLookup.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling retrieveInvoiceLookup.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TransactionForSefazGoodsList;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Status of SEFAZ Server
     * Retrieve Status of SEFAZ Server
     * @param authorization Bearer {auth}
     */
    public retrieveStatus (authorization: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz/status';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveStatus.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send an e-Invoice
     * Send a invoice to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    public sendInvoice (authorization: string, body: TransactionForSefazGoodsList) : Promise<{ response: http.ClientResponse; body: SefazPostOut;  }> {
        const localVarPath = this.basePath + '/invoices/sefaz';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling sendInvoice.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendInvoice.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SefazPostOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceServiceApiApiKeys {
}

export class InvoiceServiceApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceServiceApiApiKeys, value: string) {
        this.authentications[InvoiceServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * Cancel e-Invoice Service
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    public cancelInvoiceService (authorization: string, key: string, body: AbrasfItDeleteIn) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/invoices/service/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling cancelInvoiceService.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling cancelInvoiceService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling cancelInvoiceService.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve e-Invoice Service
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    public retrieveInvoiceService (authorization: string, key: string) : Promise<{ response: http.ClientResponse; body: AbrasfItGetOut;  }> {
        const localVarPath = this.basePath + '/invoices/service/{key}'
            .replace('{' + 'key' + '}', String(key));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveInvoiceService.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling retrieveInvoiceService.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AbrasfItGetOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Send an e-Invoice Service
     * Send a invoice
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    public sendInvoiceService (authorization: string, body: TransactionForAbrasfList) : Promise<{ response: http.ClientResponse; body: AbrasfPostOut;  }> {
        const localVarPath = this.basePath + '/invoices/service';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling sendInvoiceService.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendInvoiceService.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: AbrasfPostOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceSettingsApiApiKeys {
}

export class InvoiceSettingsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: InvoiceSettingsApiApiKeys, value: string) {
        this.authentications[InvoiceSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Invoice Settigns
     * Get Enviroment Settigns
     */
    public invoiceSettings () : Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }> {
        const localVarPath = this.basePath + '/invoices/settings';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2004;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LegalReasonApiApiKeys {
}

export class LegalReasonApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: LegalReasonApiApiKeys, value: string) {
        this.authentications[LegalReasonApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create Legal Reason.
     * 
     * @param authorization Bearer {auth}
     * @param body 
     */
    public createReason_ (authorization: string, body: LegalReason) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createReason_.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createReason_.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Legal Reason entry.
     * 
     * @param authorization Bearer {auth}
     * @param uuid 
     */
    public deleteReason_ (authorization: string, uuid: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason/{uuid}'
            .replace('{' + 'uuid' + '}', String(uuid));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteReason_.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling deleteReason_.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get single Legal Reason.
     * 
     * @param authorization Bearer {auth}
     * @param uuid 
     */
    public getReason_ (authorization: string, uuid: string) : Promise<{ response: http.ClientResponse; body: ProcessScenario;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason/{uuid}'
            .replace('{' + 'uuid' + '}', String(uuid));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getReason_.');
        }

        // verify required parameter 'uuid' is not null or undefined
        if (uuid === null || uuid === undefined) {
            throw new Error('Required parameter uuid was null or undefined when calling getReason_.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Legal Reasons.
     * 
     * @param authorization Bearer {auth}
     * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
     */
    public listReason (authorization: string, companyId?: string) : Promise<{ response: http.ClientResponse; body: Array<LegalReason>;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling listReason.');
        }

        if (companyId !== undefined) {
            queryParameters['companyId'] = companyId;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<LegalReason>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Legal Reason.
     * 
     * @param authorization Bearer {auth}
     * @param body 
     */
    public updateReason_ (authorization: string, body: LegalReason) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/legal-reason';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateReason_.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateReason_.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceCalculationsApiApiKeys {
}

export class ServiceCalculationsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ServiceCalculationsApiApiKeys, value: string) {
        this.authentications[ServiceCalculationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     * @param noPersist Do not save this calculation
     */
    public calculationServicePayment (authorization: string, body: PaymentTransactionIn, noPersist?: string) : Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-payment';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationServicePayment.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationServicePayment.');
        }

        if (noPersist !== undefined) {
            queryParameters['noPersist'] = noPersist;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     * @param noPersist Do not save this calculation
     */
    public calculationServicePurchase (authorization: string, body: PurchaseTransactionIn, noPersist?: string) : Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-purchase';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationServicePurchase.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationServicePurchase.');
        }

        if (noPersist !== undefined) {
            queryParameters['noPersist'] = noPersist;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     * @param noPersist Do not save this calculation
     */
    public calculationServiceReceipt (authorization: string, body: ReceiptTransactionIn, noPersist?: string) : Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-receipt';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationServiceReceipt.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationServiceReceipt.');
        }

        if (noPersist !== undefined) {
            queryParameters['noPersist'] = noPersist;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     * @param noPersist Do not save this calculation
     */
    public calculationServiceSales (authorization: string, body: SalesTransactionIn, noPersist?: string) : Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }> {
        const localVarPath = this.basePath + '/calculations?service-sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling calculationServiceSales.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling calculationServiceSales.');
        }

        if (noPersist !== undefined) {
            queryParameters['noPersist'] = noPersist;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Promote a calculation to transaction
     * Promote a calculation to transaction
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public convertServiceCalculatioToTransaction (authorization: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/service/{transactionType}/{documentCode}/transactions'
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling convertServiceCalculatioToTransaction.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling convertServiceCalculatioToTransaction.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling convertServiceCalculatioToTransaction.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve goods transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type
     */
    public retrieveGoodsTransactions (authorization: string, transactionType: string) : Promise<{ response: http.ClientResponse; body: Array<TransactionForGoodsIn>;  }> {
        const localVarPath = this.basePath + '/calculations/goods/{transactionType}'
            .replace('{' + 'transactionType' + '}', String(transactionType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveGoodsTransactions.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling retrieveGoodsTransactions.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<TransactionForGoodsIn>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve service transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public retrieveServiceTransactionDocument (authorization: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/service/{transactionType}/{documentCode}'
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveServiceTransactionDocument.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling retrieveServiceTransactionDocument.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling retrieveServiceTransactionDocument.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve service transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    public retrieveServiceTransactions (authorization: string, transactionType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/calculations/service/{transactionType}'
            .replace('{' + 'transactionType' + '}', String(transactionType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveServiceTransactions.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling retrieveServiceTransactions.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServiceTransactionsApiApiKeys {
}

export class ServiceTransactionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: ServiceTransactionsApiApiKeys, value: string) {
        this.authentications[ServiceTransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve service transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    public retrieveServiceTransactions (authorization: string, transactionType: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/service/{transactionType}'
            .replace('{' + 'transactionType' + '}', String(transactionType));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling retrieveServiceTransactions.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling retrieveServiceTransactions.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve service transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    public singleServiceTransaction (authorization: string, transactionType: string, documentCode: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/service/{transactionType}/{documentCode}'
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling singleServiceTransaction.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling singleServiceTransaction.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling singleServiceTransaction.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionServicePayment (authorization: string, body: PaymentTransactionIn) : Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-payment';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionServicePayment.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionServicePayment.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionServiceReceipt (authorization: string, body: ReceiptTransactionIn) : Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-receipt';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionServiceReceipt.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionServiceReceipt.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReceiptTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionServiceSales (authorization: string, body: PurchaseTransactionIn) : Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-purchase';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionServiceSales.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionServiceSales.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PurchaseTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Transaction State Transition
     * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
     * @param authorization Bearer {auth}
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     * @param body Transaction Message
     */
    public transactionServiceStateTransaction (authorization: string, transactionType: string, documentCode: string, body: StateTransition) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/transactions/service/{transactionType}/{documentCode}/stateTransitions'
            .replace('{' + 'transactionType' + '}', String(transactionType))
            .replace('{' + 'documentCode' + '}', String(documentCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionServiceStateTransaction.');
        }

        // verify required parameter 'transactionType' is not null or undefined
        if (transactionType === null || transactionType === undefined) {
            throw new Error('Required parameter transactionType was null or undefined when calling transactionServiceStateTransaction.');
        }

        // verify required parameter 'documentCode' is not null or undefined
        if (documentCode === null || documentCode === undefined) {
            throw new Error('Required parameter documentCode was null or undefined when calling transactionServiceStateTransaction.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionServiceStateTransaction.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    public transactionServicesSales (authorization: string, body: SalesTransactionIn) : Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }> {
        const localVarPath = this.basePath + '/transactions?service-sales';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling transactionServicesSales.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling transactionServicesSales.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SalesTransactionOut;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfCFOPApiApiKeys {
}

export class TaxConfCFOPApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfCFOPApiApiKeys, value: string) {
        this.authentications[TaxConfCFOPApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a new CFOP configuration
     * 
     * @param authorization Bearer {auth}
     * @param body The pet JSON you want to post
     */
    public createCfop (authorization: string, body: CfopConf) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createCfop.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCfop.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a CFOP.
     * 
     * @param authorization Bearer {auth}
     * @param code CFOP Code
     */
    public deleteCfop (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteCfop.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteCfop.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get CFOP information.
     * This operation return CFOP configuration 
     * @param authorization Bearer {auth}
     * @param code CFOP Code
     */
    public getCfop (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body: CfopConf;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCfop.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getCfop.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CfopConf;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of CFOP.
     * This operation return CFOP configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getCfopList (authorization: string, suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<CfopConf>;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getCfopList.');
        }

        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<CfopConf>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a CFOP configuration
     * 
     * @param authorization Bearer {auth}
     * @param code CFOP Code
     * @param taxconfcfop The pet JSON you want to post
     */
    public updateCfop (authorization: string, code: string, taxconfcfop: CfopConf) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/cfop/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateCfop.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateCfop.');
        }

        // verify required parameter 'taxconfcfop' is not null or undefined
        if (taxconfcfop === null || taxconfcfop === undefined) {
            throw new Error('Required parameter taxconfcfop was null or undefined when calling updateCfop.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfcfop,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfIBPTApiApiKeys {
}

export class TaxConfIBPTApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfIBPTApiApiKeys, value: string) {
        this.authentications[TaxConfIBPTApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a new Process Type configuration
     * 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param csvIBPT CSV file
     */
    public createIbptFromCSV (authorization: string, state: string, csvIBPT: CsvIbptList) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createIbptFromCSV.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling createIbptFromCSV.');
        }

        // verify required parameter 'csvIBPT' is not null or undefined
        if (csvIBPT === null || csvIBPT === undefined) {
            throw new Error('Required parameter csvIBPT was null or undefined when calling createIbptFromCSV.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: csvIBPT,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a IBPT.
     * 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     */
    public deleteIbptFromState (authorization: string, state: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/ibpt/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteIbptFromState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling deleteIbptFromState.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfICMSApiApiKeys {
}

export class TaxConfICMSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfICMSApiApiKeys, value: string) {
        this.authentications[TaxConfICMSApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a new ICMS Configuration
     * 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param icmsConfState The pet JSON you want to post
     */
    public createIcmsconfstate (authorization: string, state: string, icmsConfState: IcmsConfByState) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createIcmsconfstate.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling createIcmsconfstate.');
        }

        // verify required parameter 'icmsConfState' is not null or undefined
        if (icmsConfState === null || icmsConfState === undefined) {
            throw new Error('Required parameter icmsConfState was null or undefined when calling createIcmsconfstate.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: icmsConfState,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a ICMS by State.
     * 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param code ICMS Code
     */
    public deleteIcmsConf (authorization: string, state: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteIcmsConf.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling deleteIcmsConf.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteIcmsConf.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get ICMS information by State.
     * This operation return configurations of icms that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param code ICMS Code
     */
    public getIcmsConfByState (authorization: string, state: string, code: string) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIcmsConfByState.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling getIcmsConfByState.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getIcmsConfByState.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param suffixcode Identify this ICMS
     * @param date When informed return valid version configuration for this date
     * @param inactive return the inactive versions too
     */
    public getIcmsList (authorization: string, state: string, suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}'
            .replace('{' + 'state' + '}', String(state));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIcmsList.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling getIcmsList.');
        }

        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param text Search for codes
     * @param state Filter for states
     */
    public getIcmsListSearch (authorization: string, text: string, state?: string) : Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }> {
        const localVarPath = this.basePath + '/taxconf/icms-search/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIcmsListSearch.');
        }

        // verify required parameter 'text' is not null or undefined
        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling getIcmsListSearch.');
        }

        if (text !== undefined) {
            queryParameters['text'] = text;
        }

        if (state !== undefined) {
            queryParameters['state'] = state;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IcmsConfByState>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a IcmsConf State,
     * 
     * @param authorization Bearer {auth}
     * @param state Brazilian State
     * @param code ICMS Code
     * @param icmsConfState The pet JSON you want to post
     */
    public updateIcmsconfstate (authorization: string, state: string, code: string, icmsConfState: IcmsConfByState) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/icms/{state}/{code}'
            .replace('{' + 'state' + '}', String(state))
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateIcmsconfstate.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling updateIcmsconfstate.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateIcmsconfstate.');
        }

        // verify required parameter 'icmsConfState' is not null or undefined
        if (icmsConfState === null || icmsConfState === undefined) {
            throw new Error('Required parameter icmsConfState was null or undefined when calling updateIcmsconfstate.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: icmsConfState,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfISSApiApiKeys {
}

export class TaxConfISSApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfISSApiApiKeys, value: string) {
        this.authentications[TaxConfISSApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a new ISS Configuration
     * 
     * @param authorization Bearer {auth}
     * @param issConfByCity The pet JSON you want to post
     */
    public createIssConfByCity (authorization: string, issConfByCity: IssConfByCity) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/iss';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createIssConfByCity.');
        }

        // verify required parameter 'issConfByCity' is not null or undefined
        if (issConfByCity === null || issConfByCity === undefined) {
            throw new Error('Required parameter issConfByCity was null or undefined when calling createIssConfByCity.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: issConfByCity,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a ISS by City Code.
     * 
     * @param authorization Bearer {auth}
     * @param cityCode City Code
     */
    public deleteIssConf (authorization: string, cityCode: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteIssConf.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling deleteIssConf.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get ISS information by City Code.
     * This operation return configurations of ISS that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param cityCode City Code
     * @param code Identificator of this configuration, it is unique for account or standard namedspace 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inctives versions too 
     */
    public getIssConfByCity (authorization: string, cityCode: number, code?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIssConfByCity.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling getIssConfByCity.');
        }

        if (code !== undefined) {
            queryParameters['code'] = code;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of ISS
     * This operation return ISS configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param suffixcode Identify this ISS 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getIssList (authorization: string, suffixcode?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }> {
        const localVarPath = this.basePath + '/taxconf/iss';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIssList.');
        }

        if (suffixcode !== undefined) {
            queryParameters['suffixcode'] = suffixcode;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<IssConfByCity>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a ISS by City Code.
     * 
     * @param authorization Bearer {auth}
     * @param cityCode City Code
     * @param issConfByCity The pet JSON you want to post
     */
    public updateIssConfByCity (authorization: string, cityCode: number, issConfByCity: IssConfByCity) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/iss/{cityCode}'
            .replace('{' + 'cityCode' + '}', String(cityCode));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateIssConfByCity.');
        }

        // verify required parameter 'cityCode' is not null or undefined
        if (cityCode === null || cityCode === undefined) {
            throw new Error('Required parameter cityCode was null or undefined when calling updateIssConfByCity.');
        }

        // verify required parameter 'issConfByCity' is not null or undefined
        if (issConfByCity === null || issConfByCity === undefined) {
            throw new Error('Required parameter issConfByCity was null or undefined when calling updateIssConfByCity.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: issConfByCity,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxConfProcessApiApiKeys {
}

export class TaxConfProcessApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: TaxConfProcessApiApiKeys, value: string) {
        this.authentications[TaxConfProcessApiApiKeys[key]].apiKey = value;
    }
    /**
     * create a new Process Type configuration
     * 
     * @param authorization Bearer {auth}
     * @param taxconfprocess The pet JSON you want to post
     */
    public createProcess (authorization: string, taxconfprocess: ProcessScenario) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/taxconf/process';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling createProcess.');
        }

        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling createProcess.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * disable a Process.
     * 
     * @param authorization Bearer {auth}
     * @param code Process Code
     */
    public deleteProcess (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling deleteProcess.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling deleteProcess.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * get Process information.
     * This operation return Process Type configuration 
     * @param authorization Bearer {auth}
     * @param code Process Code
     */
    public getProcess (authorization: string, code: string) : Promise<{ response: http.ClientResponse; body: ProcessScenario;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getProcess.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling getProcess.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ProcessScenario;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * retrive list of Process.
     * This operation return Process Type configurations that match with parameters queries 
     * @param authorization Bearer {auth}
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    public getProcessList (authorization: string, accountId?: string, date?: Date, inactive?: boolean) : Promise<{ response: http.ClientResponse; body: Array<ProcessScenario>;  }> {
        const localVarPath = this.basePath + '/taxconf/process';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getProcessList.');
        }

        if (accountId !== undefined) {
            queryParameters['accountId'] = accountId;
        }

        if (date !== undefined) {
            queryParameters['date'] = date;
        }

        if (inactive !== undefined) {
            queryParameters['inactive'] = inactive;
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ProcessScenario>;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * update a Process Type configuration
     * 
     * @param authorization Bearer {auth}
     * @param code Process Code
     * @param taxconfprocess The pet JSON you want to post
     */
    public updateProcess (authorization: string, code: string, taxconfprocess: ProcessScenario) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/taxconf/process/{code}'
            .replace('{' + 'code' + '}', String(code));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling updateProcess.');
        }

        // verify required parameter 'code' is not null or undefined
        if (code === null || code === undefined) {
            throw new Error('Required parameter code was null or undefined when calling updateProcess.');
        }

        // verify required parameter 'taxconfprocess' is not null or undefined
        if (taxconfprocess === null || taxconfprocess === undefined) {
            throw new Error('Required parameter taxconfprocess was null or undefined when calling updateProcess.');
        }

        headerParams['Authorization'] = authorization;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: taxconfprocess,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
