/**
 * BR16 - API
 * This documentation is about service accessories that will compose the product BR16, this services are essencial to maintenance and configuration of accounts
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://br16-dev-app03.br.avalara.com/v2".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccountCompany {
    "companyId": string;
    "companyCode": string;
    "companyName"?: string;
}

export interface AdditionalInformation {
    /**
     * Additional information of fiscal interest
     */
    "fiscalInfo"?: string;
    /**
     * Additional information of user interest
     */
    "complementaryInfo"?: string;
    /**
     * Referenced Process
     */
    "procRef"?: Array<AdditionalInformationProcRef>;
}

export interface AdditionalInformationProcRef {
    /**
     * Process Identifier
     */
    "nProc"?: string;
    /**
     * Process Origin - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
     */
    "indProc"?: AdditionalInformationProcRefIndProcEnum;
}

export type AdditionalInformationProcRefIndProcEnum = "0" | "1" | "2" | "3" | "9";
export interface Address {
    /**
     * Street Name
     */
    "street"?: string;
    /**
     * Neighborhood Name
     */
    "neighborhood"?: string;
    /**
     * Brazilian Zip Code
     */
    "zipcode": string;
    /**
     * City Code (IBGE)
     */
    "cityCode"?: string;
    /**
     * City Name
     */
    "cityName"?: string;
    "state"?: StateEnum;
    /**
     * Country Code
     */
    "countryCode"?: string;
    /**
     * Use ISO 3166-1 alpha-3 codes
     */
    "country"?: string;
}

export interface Agast {
    /**
     * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
     */
    "code": string;
    /**
     * Agast Description
     */
    "description"?: string;
    /**
     * harmonized code, NCM or LC 116
     */
    "hsCode"?: string;
    /**
     * hsCode Exception for IPI tax
     */
    "ex"?: number;
    /**
     * tax substitution code - Codigo especificador da Substuicao Tributaria
     */
    "cest"?: string;
    /**
     * GTIN NUMBER
     */
    "cean"?: string;
    "codeType"?: AgastCodeType;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: AgastCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * when the company is Real Profit inform if this item is cumulative or no cumulative by default
     */
    "pisCofinsTaxReporting"?: AgastPisCofinsTaxReportingEnum;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: AgastAccruablePISTaxationEnum;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: AgastAccruableCOFINSTaxationEnum;
    /**
     * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
     */
    "accruableCSLLTaxation"?: AgastAccruableCSLLTaxationEnum;
    /**
     * for service items with City Jurisdiction, inform where the ISS tax is due
     */
    "issDueatDestination"?: boolean;
    /**
     * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
     */
    "pisCofinsCreditNotAllowed"?: boolean;
    /**
     * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
     */
    "issTaxation"?: AgastIssTaxationEnum;
    /**
     * This is an array of tax object related to an agast.
     */
    "federalTaxRate"?: Array<TaxTypeRate>;
    "specialProductClass"?: AgastSpecialProductClassEnum;
    /**
     * One per State
     */
    "icmsConf"?: Array<AgastIcmsConf>;
}

export type AgastCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type AgastPisCofinsTaxReportingEnum = "cumulative" | "noCumulative";
export type AgastAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type AgastAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type AgastAccruableCSLLTaxationEnum = "T" | "E";
export type AgastIssTaxationEnum = "T" | "E" | "F" | "A" | "L" | "I";
export type AgastSpecialProductClassEnum = "OTHERS" | "COMMUNICATION" | "ENERGY" | "TRANSPORT" | "FUEL AND LUBRIFICANT" | "VEHICLE" | "ALCOHOLIC BEVERAGES" | "WEAPONS" | "AMMO" | "PERFUME" | "TOBACCO";
export interface AgastCodeType {
    /**
     * - 'NCM' - 'NBS' - 'LC116' - 'SERVICE UNREGULATED' 
     */
    "code"?: number;
    "name"?: AgastCodeTypeNameEnum;
}

export type AgastCodeTypeNameEnum = "NCM" | "NBS" | "LC116" | "SERVICE UNREGULATED";
export interface AgastExtendForSefaz {
    /**
     * harmonized code, NCM or LC 116
     */
    "hsCode"?: string;
    /**
     * hsCode Exception for IPI tax
     */
    "ex"?: number;
    /**
     * tax substitution code - Codigo especificador da Substuicao Tributaria
     */
    "cest"?: string;
    /**
     * GTIN NUMBER
     */
    "cean"?: string;
    /**
     * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
     */
    "nve"?: string;
    /**
     * Sales Unit
     */
    "unit"?: string;
    /**
     * Sales Taxable Unit
     */
    "unitTaxable"?: string;
    /**
     * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
     */
    "nFCI"?: string;
}

/**
 * See definitions IcmsConfByState
 */
export interface AgastIcmsConf {
    "code"?: string;
    "state"?: StateEnum;
}

export interface Body {
    "companyCode"?: string;
}

export interface Body1 {
    /**
     * Destination code.
     */
    "newCode": string;
}

export interface Body2 {
    "content"?: string;
}

export interface Body3 {
    "content"?: string;
}

export interface Body4 {
    "startDate"?: Date;
    "finishDate"?: Date;
}

/**
 * Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '01' # Operação Tributável com Alíquota Básica - '02' # Operação Tributável com Alíquota Diferenciada - '03' # Operação Tributável com Alíquota por Unidade de Medida de Produto - '04' # Operação Tributável Monofásica - 'Revenda a Alíquota Zero - '05' # Operação Tributável por Substituição Tributária - '06' # Operação Tributável a Alíquota Zero - '07' # Operação Isenta da Contribuição - '08' # Operação sem Incidência da Contribuição - '09' # Operação com Suspensão da Contribuição - '49' # Outras Operações de Saída - '50' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '51' # Operação com Direito a Crédito – Vinculada Exclusivamente a Receita Não Tributada no Mercado Interno - '52' # Operação com Direito a Crédito - 'Vinculada Exclusivamente a Receita de Exportação - '53' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '54' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '55' # Operação com Direito a Crédito - 'Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '56' # Operação com Direito a Crédito - 'Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '60' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '61' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita Não-Tributada no Mercado Interno - '62' # Crédito Presumido - 'Operação de Aquisição Vinculada Exclusivamente a Receita de Exportação - '63' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '64' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '65' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '66' # Crédito Presumido - 'Operação de Aquisição Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação - '67' # Crédito Presumido - 'Outras Operações - '70' # Operação de Aquisição sem Direito a Crédito - '71' # Operação de Aquisição com Isenção - '72' # Operação de Aquisição com Suspensão - '73' # Operação de Aquisição a Alíquota Zero - '74' # Operação de Aquisição sem Incidência da Contribuição - '75' # Operação de Aquisição por Substituição Tributária - '98' # Outras Operações de Entrada - '99' # Outras Operações 
 */
export interface CSTPistCofinsEnum {
}

/**
 * Source of product or merchandise, - '0' # National goods - 'except those treated in codes 3,4, 5 and 8 - '1' # Imported directly by seller, except those in code 6 - '2' # Foreign goods - 'Acquired in the internal market (inside Brazil), except those in code 7 - '3' # Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - 'Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - 'Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - 'Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # Merchandise or goods with imported content above 70% 
 */
export interface CSTTableAEnum {
}

/**
 * Use to determined how the tax is applicable and calculated. It may define and exemption, a tax base reduction, identify that a special rate is applicable (not the rate itself). - '00' # Taxed in its totality - '10' # Taxed and subject to tax substitution (ICMS ST) - '20' # Taxed with Tax Base Reduction - '30' # Exempt /Not Taxed and subject to tax Substitution (ICMS#ST) - '40' # Tax Exempt - '41' # Not Taxed - '50' # Taxes Suspended - '51' # Taxes Diferred - '60' # ICMS Tax already collected through Substituition (ICMS ST) - '70' # Taxed with Tax Base Reduction and subject to Tax Subsititution (ICMS ST) - '90' # Others 
 */
export interface CSTTableBEnum {
}

export interface CalcModelEnum {
}

export interface CalculatedTaxSummaryForGoods {
    /**
     * Count of lines
     */
    "numberOfLines"?: number;
    /**
     * sum of all line taxed discounts
     */
    "taxedDiscount"?: number;
    /**
     * sum of all line untaxed discounts
     */
    "untaxedDiscount"?: number;
    /**
     * sum of all line lineAmount attribute
     */
    "subtotal"?: number;
    /**
     * sum of all line tax attribute
     */
    "totalTax"?: number;
    /**
     * sum of all line lineAmount attribute + sum of all line tax attribute not VAT - sum of all line lineTaxedDiscount attribute
     */
    "grandTotal"?: number;
    "taxByType"?: CalculatedTaxSummaryForGoodsTaxByType;
}

export interface CalculatedTaxSummaryForGoodsTaxByType {
    "icms"?: TaxByTypeSummaryForGoods;
    "icmsSt"?: TaxByTypeSummaryForGoods;
    "icmsStSd"?: TaxByTypeSummaryForGoods;
    "icmsPartOwn"?: TaxByTypeSummaryForGoods;
    "icmsPartDest"?: TaxByTypeSummaryForGoods;
    "icmsDifaFCP"?: TaxByTypeSummaryForGoods;
    "icmsDifaDest"?: TaxByTypeSummaryForGoods;
    "icmsDifaRemet"?: TaxByTypeSummaryForGoods;
    "icmsRf"?: TaxByTypeSummaryForGoods;
    "icmsDeson"?: TaxByTypeSummaryForGoods;
    "icmsCredsn"?: TaxByTypeSummaryForGoods;
    "pis"?: TaxByTypeSummaryForGoods;
    "pisSt"?: TaxByTypeSummaryForGoods;
    "cofins"?: TaxByTypeSummaryForGoods;
    "cofinsSt"?: TaxByTypeSummaryForGoods;
    "ipi"?: TaxByTypeSummaryForGoods;
    "ipiReturned"?: TaxByTypeSummaryForGoods;
    "ii"?: TaxByTypeSummaryForGoods;
    "iof"?: TaxByTypeSummaryForGoods;
    "aproxtribState"?: TaxByTypeSummaryForGoods;
    "aproxtribFed"?: TaxByTypeSummaryForGoods;
}

export interface CfopConf {
    /**
     * main unique identificator
     */
    "code": string;
    /**
     * Inform that the process has inventory impact.
     */
    "stockImpact"?: boolean;
    /**
     * Inform that the process has financial impact.
     */
    "financialImpact"?: boolean;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: CfopConfCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: CfopConfAccruablePISTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "pisExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "pisExemptLegalReason"?: string;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: CfopConfAccruableCOFINSTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "cofinsExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "cofinsExemptLegalReason"?: string;
    /**
     * Inform that the process allow IPI credit to Input process
     */
    "allowIPIcreditWhenInGoing"?: boolean;
    /**
     * the map key is state code
     */
    "icmsConf"?: Array<IcmsTaxConf>;
    "name": string;
    "description"?: string;
    /**
     * inform if the transaction is an operation to internalizing item or value
     */
    "wayType"?: CfopConfWayTypeEnum;
    /**
     * CFOP code (tax code operation) when the transactions are within the same state.
     */
    "codInState"?: number;
    /**
     * CFOP code (tax code operation) when the transactions are to another state.
     */
    "codOtherState"?: number;
    /**
     * CFOP code (tax code operation) when the transactions are to another country.
     */
    "codOtherCountry"?: number;
    "cstICMSSameState"?: CstIcmsEnum;
    "cstICMSOtherState"?: CstIcmsEnum;
    "cstICMSOtherCountry"?: CstIcmsEnum;
    /**
     * this field is used to define right CFOP, one operation type can be specialized to item product, item merchandise or generic
     */
    "productType"?: CfopConfProductTypeEnum;
    /**
     * field used to indicate an operation to ICMS tax payer
     */
    "operationToTaxPayerOtherState"?: boolean;
    /**
     * field used to indicate an operation to items sibject to ICMS-ST
     */
    "operationWithST"?: boolean;
    /**
     * field used to indicate an operation to free zone
     */
    "operationToFreeZone"?: boolean;
    /**
     * field used to indicate an operation to some product class specifically
     */
    "specificForProductClass"?: CfopConfSpecificForProductClassEnum;
}

export type CfopConfCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type CfopConfAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CfopConfAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CfopConfWayTypeEnum = "in" | "out";
export type CfopConfProductTypeEnum = "FOR PRODUCT" | "FOR MERCHANDISE" | "NO RESTRICTION";
export type CfopConfSpecificForProductClassEnum = "OTHERS" | "COMMUNICATION" | "ENERGY" | "TRANSPORT" | "FUEL AND LUBRIFICANT" | "VEHICLE" | "ALCOHOLIC BEVERAGES" | "WEAPONS" | "AMMO" | "PERFUM" | "TOBACCO";
export interface Company {
    /**
     * string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "code": string;
    /**
     * Official Company name (Razão Social)
     */
    "officialName": string;
    /**
     * Company name (DBA - Nome de Fantasia),  Used to identify branches/subsidiaries with same name
     */
    "name": string;
    "entityType": EntityType;
    /**
     * Company has participation of state-owned capital (it will be considerated like a government entity)
     */
    "subjectToSRF1234"?: boolean;
    "federalTaxRegime": FederalTaxRegime;
    /**
     * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
     */
    "pisSubjectTo"?: CompanyPisSubjectToEnum;
    /**
     * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
     */
    "cofinsSubjectTo"?: CompanyCofinsSubjectToEnum;
    /**
     * this flag informs if this company is subject to this tax the default value for this property is TAXABLE, when set to TAXABLE it doesn't mean that all transaction will be TAXABLE. The system will analise other rules to identify exemptions/exceptions when set to NOT TAXABLE or EXEMPT, the system will not analise other rules. 
     */
    "csllSubjectTo"?: CompanyCsllSubjectToEnum;
    /**
     * When th company is REAL PROFIT usually it operates under a Non-Cumulative PIS/COFINS regime But exist some services that are always Cumulative regime. If the company has all receipts from Non-Cumulative services this flag will be set to True. This flag informs special conditions to credit of PIS/COFINS when this company is out of Free zone and  purchases from Free Zone Company Quando uma empresa fora da Zona Franca adquire uma produto ou serviço de uma empresa situada na Zona Franca de Manaus, o crédito de PIS E COFINS segue estas aliquotas diferenciadas. Fundamentação, art. 5º da Instrução Normativa SRF nº 546/2005; art. 3º, § 12 da Lei nº 10.637/2002; art. 3º, § 17 da Lei nº 10.833/2003; art. 4º da Lei nº 11.307/2006. DESTINATÁRIO ALÍQUOTAS PIS COFINS a) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure a Contribuição para o PIS/PASEP no regime de não-cumulatividade débito 0,65% 3% crédito 1% 4,6% c) Venda efetuada a pessoa jurídica estabelecida fora da Zona Franca de Manaus, que apure o imposto de renda com base no lucro real e que tenha sua receita, total ou parcialmente, excluída do regime de incidência não-cumulativa da Contribuição para o PIS/PASEP débito 1,3% 6% crédito 1,65% 7,6% 
     */
    "receiptsAreFullNoCumulativePisCofins"?: boolean;
    /**
     * On purchase transaction, to force withholding INSS this Flag can be set to True
     */
    "inssWithholdSubjectTo"?: boolean;
    /**
     * On purchase transaction, to force withhold ISS this Flag can be set to True
     */
    "issWithholdSubjectTo"?: boolean;
    /**
     * On purchase transaction, if this flag is FALSE, the system will not withhold IRRF. if this flag is TRUE the system will analise other rules to define if will have witholding 
     */
    "irrfWithholdSubjectTo"?: boolean;
    /**
     * Actual ICMS Rate for this company (if the company is Tax Regime Simplified). Aliquota de ICMS da companhia caso Optante do Simples 
     */
    "icmsRateForSimplestaxregime"?: number;
    /**
     * ICMS Exempt when Tax Regime is Simplified because total gross revenue is bellow amount defined by state (see PARANÁ State) Isenção do ICMS no Simples Nacional para faixa de receita bruta 
     */
    "isExemptByGrossRevenueForSimplestaxregime"?: boolean;
    "configuration"?: CompanyConfiguration;
    "mailServer"?: CompanyMailServer;
    /**
     * Person or company authorized to downloadNFe
     */
    "authorizedToDownloadNFe"?: Array<CompanyAuthorizedToDownloadNFe>;
}

export type CompanyPisSubjectToEnum = "TAXABLE" | "NOT TAXABLE" | "EXEMPT";
export type CompanyCofinsSubjectToEnum = "TAXABLE" | "NOT TAXABLE" | "EXEMPT";
export type CompanyCsllSubjectToEnum = "TAXABLE" | "NOT TAXABLE" | "EXEMPT";
export interface CompanyAuthorizedToDownloadNFe {
    /**
     * Federal tax id, CNPJ or CPF
     */
    "federalTaxId"?: string;
}

export interface CompanyConfiguration {
    /**
     * digital certificate A1 model, p12, encoded by base64
     */
    "certificate"?: string;
    /**
     * certificate password
     */
    "certificatepwd"?: string;
    /**
     * expiration date of this certificate
     */
    "certificateexpiration"?: Date;
    /**
     * company logo image encoded by base64
     */
    "logo"?: string;
    /**
     * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; 
     */
    "tpImpNFe"?: CompanyConfigurationTpImpNFeEnum;
    /**
     * how the document will be printed - '0' # without DANFE; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
     */
    "tpImpNFCe"?: CompanyConfigurationTpImpNFCeEnum;
}

export type CompanyConfigurationTpImpNFeEnum = "0" | "1" | "2";
export type CompanyConfigurationTpImpNFCeEnum = "0" | "4" | "5";
export interface CompanyMailServer {
    /**
     * User for login on email server
     */
    "user"?: string;
    /**
     * Password to login on email server
     */
    "password"?: string;
    /**
     * smtp address to email server
     */
    "smtpAddress"?: string;
    /**
     * port
     */
    "port"?: number;
    /**
     * email address to identify the sender e-mail, to send a XML and DANFE
     */
    "emailFrom"?: string;
    /**
     * protocol SSL or TLS
     */
    "protocol"?: CompanyMailServerProtocolEnum;
    /**
     * Message to add to email body
     */
    "templatemessageToEmail"?: string;
}

export type CompanyMailServerProtocolEnum = "ssl" | "tls";
/**
 * On sales process inform the CST that the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
 */
export interface CstIcmsEnum {
}

export interface CustomAgast {
    /**
     * Agast Code. AGAST (Avalara Goods and Services Types) are preset products with default tax definitions available to be used as provided or copied to create an specific comapany item.
     */
    "code": string;
    /**
     * Agast Description
     */
    "description"?: string;
    /**
     * harmonized code, NCM or LC 116
     */
    "hsCode"?: string;
    /**
     * hsCode Exception for IPI tax
     */
    "ex"?: number;
    /**
     * tax substitution code - Codigo especificador da Substuicao Tributaria
     */
    "cest"?: string;
    /**
     * GTIN NUMBER
     */
    "cean"?: string;
    "codeType"?: AgastCodeType;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: CustomAgastCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento tributário) When the process has CST IPI 52 or 54, it is mandatory to inform a Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * when the company is Real Profit inform if this item is cumulative or no cumulative by default
     */
    "pisCofinsTaxReporting"?: CustomAgastPisCofinsTaxReportingEnum;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: CustomAgastAccruablePISTaxationEnum;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: CustomAgastAccruableCOFINSTaxationEnum;
    /**
     * Inform if this item by nature is subject to CSLL taxation or exempt - 'T' # TAXABLE - 'E' # EXEMPT 
     */
    "accruableCSLLTaxation"?: CustomAgastAccruableCSLLTaxationEnum;
    /**
     * for service items with City Jurisdiction, inform where the ISS tax is due
     */
    "issDueatDestination"?: boolean;
    /**
     * on Real Profit Purchase transaction, inform if this item allows tax credits when it is non-cumulative
     */
    "pisCofinsCreditNotAllowed"?: boolean;
    /**
     * - 'T' # TAXABLE - TRIBUTÁVEL INCLUSIVE PARA EXPORTAÇÃO' - 'E' # TAXABLE WITH EXEMPTION FOR EXPORTS - ISENTO PARA SERVIÇOS PRESTADOS AO EXTERIOR (DEFAULT) - 'F' # EXEMPT - 'A' # SUSPENDED FOR ADMINISTRATIVE REASON - 'L' # SUSPENDED FOR LEGAL DECISION - 'I' # IMMUNE 
     */
    "issTaxation"?: CustomAgastIssTaxationEnum;
    /**
     * This is an array of tax object related to an agast.
     */
    "federalTaxRate"?: Array<TaxTypeRate>;
    "specialProductClass"?: CustomAgastSpecialProductClassEnum;
    /**
     * One per State
     */
    "icmsConf"?: Array<AgastIcmsConf>;
    /**
     * Company ID
     */
    "companyId": string;
}

export type CustomAgastCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type CustomAgastPisCofinsTaxReportingEnum = "cumulative" | "noCumulative";
export type CustomAgastAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CustomAgastAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CustomAgastAccruableCSLLTaxationEnum = "T" | "E";
export type CustomAgastIssTaxationEnum = "T" | "E" | "F" | "A" | "L" | "I";
export type CustomAgastSpecialProductClassEnum = "OTHERS" | "COMMUNICATION" | "ENERGY" | "TRANSPORT" | "FUEL AND LUBRIFICANT" | "VEHICLE" | "ALCOHOLIC BEVERAGES" | "WEAPONS" | "AMMO" | "PERFUME" | "TOBACCO";
export interface CustomIcmsConfByState {
    /**
     * Identify the IcmsConfState in namespace
     */
    "code": string;
    "state": StateEnum;
    /**
     * name for this configuration
     */
    "name"?: string;
    /**
     * date when this configuration values starts
     */
    "startDate"?: Date;
    /**
     * date when this configuration values expire
     */
    "expirationDate"?: Date;
    /**
     * set this configuration to Inactive
     */
    "inactive"?: boolean;
    /**
     * inform that the item linked to this configuration is subject to ICMS ST on this state
     */
    "subjectToST"?: boolean;
    /**
     * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
     */
    "icmsCST"?: CustomIcmsConfByStateIcmsCSTEnum;
    /**
     * how this ICMS will be calculed for itens linked to this configuration
     */
    "calcMode"?: CustomIcmsConfByStateCalcModeEnum;
    /**
     * discount if the item is subject to monophase PIS/COFINS for transactions inside state
     */
    "discountRateForMonoPhase"?: number;
    /**
     * ICMS rate
     */
    "rate"?: number;
    /**
     * ICMS rate
     */
    "icmsBaseDiscount"?: number;
    /**
     * SRP or MMSRP amount base for this icms configuration
     */
    "msrp"?: number;
    /**
     * ICMS mva rate to define calc base
     */
    "mvaRate"?: number;
    /**
     * unit used to SRP amount value
     */
    "msrpUnit"?: string;
    /**
     * Code for the ICM legal reason, this message will be placed on invoice.
     */
    "icmsLegalReason"?: string;
    /**
     * Fundo de Combate à pobreza / Fund Against Poverty
     */
    "fcpRate"?: number;
    "icmsSTConf"?: IcmsConfByStateIcmsSTConf;
    /**
     * the map key is state code
     */
    "icmsInterStateConf"?: Array<IcmsConfInterState>;
    /**
     * Company ID
     */
    "companyId": string;
}

export type CustomIcmsConfByStateIcmsCSTEnum = "00" | "20" | "40" | "41" | "50";
export type CustomIcmsConfByStateCalcModeEnum = "BYMVARATE" | "SRP" | "MMSRP" | "OPERATIONAMOUNT";
export interface CustomProcessScenario {
    /**
     * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
     */
    "code": string;
    /**
     * Inform that the process has inventory impact.
     */
    "stockImpact"?: boolean;
    /**
     * Inform that the process has financial impact.
     */
    "financialImpact"?: boolean;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: CustomProcessScenarioCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: CustomProcessScenarioAccruablePISTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "pisExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "pisExemptLegalReason"?: string;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: CustomProcessScenarioAccruableCOFINSTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "cofinsExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "cofinsExemptLegalReason"?: string;
    /**
     * Inform that the process allow IPI credit to Input process
     */
    "allowIPIcreditWhenInGoing"?: boolean;
    /**
     * the map key is state code
     */
    "icmsConf"?: Array<IcmsTaxConf>;
    /**
     * Process name to Identify this configuration
     */
    "name": string;
    "type"?: CustomProcessScenarioTypeEnum;
    /**
     * inform if the transaction is an operation to internalizing (receive) item or value
     */
    "wayType"?: CustomProcessScenarioWayTypeEnum;
    "goal"?: CustomProcessScenarioGoalEnum;
    /**
     * inform that the configuration process overwrites the cfop configuration.
     */
    "overWriteCFOP"?: boolean;
    "cfops"?: Array<CfopConf>;
    /**
     * Company ID
     */
    "companyId": string;
}

export type CustomProcessScenarioCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type CustomProcessScenarioAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CustomProcessScenarioAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type CustomProcessScenarioTypeEnum = "SALES" | "PURCHASE" | "SALES_RETURN" | "PURCHASE_RETURN" | "TRANSFER_RETURN" | "SHIPPING" | "SHIPPING_RETURN" | "TRANSFER" | "RECEIPT_AJUSTE" | "TRANSFER_AJUSTE";
export type CustomProcessScenarioWayTypeEnum = "in" | "out";
export type CustomProcessScenarioGoalEnum = "Normal" | "Complementary" | "Voided" | "Replacement" | "Return" | "Adjustment";
export interface CustomTaxTypeRate {
    "taxType": TaxType;
    /**
     * Tax can be calculated by rate or by quantity
     */
    "taxModel": CustomTaxTypeRateTaxModelEnum;
    /**
     * Specific tax rate ex 3.5 (3.5%)
     */
    "rate"?: number;
    /**
     * Specific tax rate ex 3.5 (3.5%)
     */
    "srvAmount"?: number;
    "quantityUnidBase"?: string;
    "specializationType"?: CustomTaxTypeRateSpecializationTypeEnum;
    /**
     * UUID Reference to an item in the LegalReason store. 
     */
    "exemptionReasonCode"?: string;
    /**
     * Optional textual reason description, to be used when reason codes are generic (i.e. reason code 999 = Other). 
     */
    "customExemptionReasonDescription"?: string;
    "withholding"?: TaxTypeRateWithholding;
    /**
     * Company ID
     */
    "companyId": string;
}

export type CustomTaxTypeRateTaxModelEnum = "rate" | "srf";
export type CustomTaxTypeRateSpecializationTypeEnum = "basic" | "monophase" | "taxSubstitution";
/**
 * This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. These locations may be overridden within each line item. The key for each location in the dictionary is the location 'purpose'. Valid locations purposes are 'ShipFrom', 'ShipTo', 'POS', 'POM', 'POO', 'BillingLocation', 'CallPlaced', 'CallReceived', 'ServiceRendered', 'POA' and 'FirstUse'. There can only be one location of a given purpose in the dictionary.
 */
export interface DefaultLocations {
    "entity"?: EntityLocation;
    "company"?: EntityLocation;
    "transporter"?: EntityLocation;
    "deliveryLocation"?: EntityLocation;
    "pickupLocation"?: EntityLocation;
}

export interface DetailsCalculatedTax {
    /**
     * This string captures the applicable location type. Location used for calc. Buyer or Seller
     */
    "locationType"?: string;
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction
     */
    "jurisdictionType"?: DetailsCalculatedTaxJurisdictionTypeEnum;
    /**
     * Tax identificator
     */
    "taxType"?: DetailsCalculatedTaxTaxTypeEnum;
    /**
     * Name of configuration rate
     */
    "rateType"?: string;
    /**
     * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
     */
    "scenario"?: string;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax, calc base
     */
    "subtotalTaxable"?: number;
    /**
     * This decimal captures the tax rate for this tax.3.00 (3%)
     */
    "rate"?: number;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax
     */
    "tax"?: number;
    /**
     * This string is required if is exempt
     */
    "exemptionCode"?: string;
    /**
     * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
     */
    "significantLocations"?: Array<string>;
    /**
     * This string with type of rule
     */
    "taxRuleType"?: DetailsCalculatedTaxTaxRuleTypeEnum;
}

export type DetailsCalculatedTaxJurisdictionTypeEnum = "city" | "state" | "country";
export type DetailsCalculatedTaxTaxTypeEnum = "icms" | "icmsSt" | "icmsStSd" | "icmsPartOwn" | "icmsPartDest" | "icmsDifaFCP" | "icmsDifaDest" | "icmsDifaRemet" | "icmsRf" | "icmsDeson" | "icmsCredsn" | "pis" | "pisSt" | "cofins" | "cofinsSt" | "ipi" | "ipiReturned" | "ii" | "iof" | "aproxtribState" | "aproxtribFed" | "aproxtrib";
export type DetailsCalculatedTaxTaxRuleTypeEnum = "SELLER" | "BUYER" | "TRANSACTION" | "ITEM" | "TAX";
export interface DetailsCalculatedTaxItem {
    /**
     * This string captures the applicable location type. Location used for calc. Buyer or Seller
     */
    "locationType"?: string;
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction
     */
    "jurisdictionType"?: DetailsCalculatedTaxItemJurisdictionTypeEnum;
    /**
     * Tax identificator
     */
    "taxType"?: DetailsCalculatedTaxItemTaxTypeEnum;
    /**
     * Name of configuration rate
     */
    "rateType"?: string;
    /**
     * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
     */
    "scenario"?: string;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax, calc base
     */
    "subtotalTaxable"?: number;
    /**
     * This decimal captures the tax rate for this tax.3.00 (3%)
     */
    "rate"?: number;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax
     */
    "tax"?: number;
    /**
     * This string is required if is exempt
     */
    "exemptionCode"?: string;
    /**
     * This element captures the list of locations that contributed to the tax determination. for Service is Buyer and Seller Address
     */
    "significantLocations"?: Array<string>;
    /**
     * This string with type of rule
     */
    "taxRuleType"?: DetailsCalculatedTaxItemTaxRuleTypeEnum;
    "source"?: number;
    "cstB"?: string;
    "modBC"?: string;
    "cst"?: string;
}

export type DetailsCalculatedTaxItemJurisdictionTypeEnum = "city" | "state" | "country";
export type DetailsCalculatedTaxItemTaxTypeEnum = "icms" | "icmsSt" | "icmsStSd" | "icmsPartOwn" | "icmsPartDest" | "icmsDifaFCP" | "icmsDifaDest" | "icmsDifaRemet" | "icmsRf" | "icmsDeson" | "icmsCredsn" | "pis" | "pisSt" | "cofins" | "cofinsSt" | "ipi" | "ipiReturned" | "ii" | "iof" | "aproxtribState" | "aproxtribFed" | "aproxtrib";
export type DetailsCalculatedTaxItemTaxRuleTypeEnum = "SELLER" | "BUYER" | "TRANSACTION" | "ITEM" | "TAX";
export interface Entity {
    /**
     * Entity name, official name (Razão Social)
     */
    "name"?: string;
    /**
     * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
     */
    "role"?: EntityRoleEnum;
    "type": EntityType;
    /**
     * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
     */
    "federalTaxId": string;
    /**
     * City Tax ID
     */
    "cityTaxId"?: string;
    /**
     * State Tax ID
     */
    "stateTaxId"?: string;
    /**
     * Suframa ID
     */
    "suframa"?: string;
    /**
     * Entity Phone
     */
    "phone"?: string;
    "taxRegime"?: EntityTaxRegimeEnum;
    /**
     * Entity Email
     */
    "email"?: string;
    /**
     * Companies subject to follow same rules of Government entities (Instrução Normativa: SRF1234)
     */
    "subjectToSRF1234"?: boolean;
}

export type EntityRoleEnum = "transporter" | "sender" | "dispatcher" | "receiver" | "addressee" | "other";
export type EntityTaxRegimeEnum = "realProfit" | "estimatedProfit" | "simplified" | "simplifiedOverGrossthreshold" | "simplifiedEntrepreneur" | "notApplicable" | "individual";
export interface EntityForGoods {
    /**
     * Entity name, official name (Razão Social)
     */
    "name"?: string;
    /**
     * - 'transporter' - 'sender' # REMETENTE - 'dispatcher' # EXPEDITOR - 'receiver' # RECEIVER - 'addressee' # DESTINATÁRIO - 'other' # OUTRO 
     */
    "role"?: EntityForGoodsRoleEnum;
    "type": EntityType;
    /**
     * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
     */
    "federalTaxId": string;
    /**
     * City Tax ID
     */
    "cityTaxId"?: string;
    /**
     * State Tax ID
     */
    "stateTaxId"?: string;
    /**
     * Suframa ID
     */
    "suframa"?: string;
    /**
     * Entity Phone
     */
    "phone"?: string;
    "taxRegime"?: EntityForGoodsTaxRegimeEnum;
    /**
     * Entity Email
     */
    "email"?: string;
    /**
     * Companies subject to follow same rules of Government entities (Instrução Normativa: SRF1234)
     */
    "subjectToSRF1234"?: boolean;
    /**
     * Inform if the entity is ICMS tax payer.
     */
    "icmsTaxPayer"?: boolean;
}

export type EntityForGoodsRoleEnum = "transporter" | "sender" | "dispatcher" | "receiver" | "addressee" | "other";
export type EntityForGoodsTaxRegimeEnum = "realProfit" | "estimatedProfit" | "simplified" | "simplifiedOverGrossthreshold" | "simplifiedEntrepreneur" | "notApplicable" | "individual";
export interface EntityInformerForGoods {
    "type"?: EntityType;
    "taxRegime"?: FederalTaxRegime;
    "federalTaxRegime"?: EntityInformerForGoodsFederalTaxRegime;
    "cityCode"?: string;
    "address"?: Address;
    "details"?: any;
    "icmsTaxPayer"?: boolean;
}

export interface EntityInformerForGoodsFederalTaxRegime {
    "code"?: string;
    "name"?: string;
    "abbr"?: string;
}

export interface EntityLocation {
    /**
     * Street Name
     */
    "street"?: string;
    /**
     * Neighborhood Name
     */
    "neighborhood"?: string;
    /**
     * Brazilian Zip Code
     */
    "zipcode": string;
    /**
     * City Code (IBGE)
     */
    "cityCode"?: string;
    /**
     * City Name
     */
    "cityName"?: string;
    "state"?: StateEnum;
    /**
     * Country Code
     */
    "countryCode"?: string;
    /**
     * Use ISO 3166-1 alpha-3 codes
     */
    "country"?: string;
}

/**
 * Entity Type (business, individual, federal government, state government, city government foreign)
 */
export interface EntityType {
}

/**
 * Export information
 */
export interface ExportInfo {
    /**
     * shipping state
     */
    "shippingState": StateEnum;
    /**
     * shipping place
     */
    "place": string;
    /**
     * description of shipping place
     */
    "placeDescription"?: string;
}

/**
 * - Federal tax regime - realProfit - REAL PROFIT LUCRO REAL - estimatedProfit - ESTIMATED PROFIT / LUCRO PRESUMIDO - simplified - SIMPLIFIED - OPTANTE TO SIMPLES - simplifiedOverGrossthreshold - OPTANTE DO SIMPLES COM LIMITE DE GROSS REVENUE - simplifiedEntrepreneur - SIMPLIFIED ENTREPRENEUR / MEI MICRO EMPREENDEDOR INDIVIDUAL  - notApplicable - Not Applicable 1  - individual - INDIVIDUAL / INDIVIDUO 
 */
export interface FederalTaxRegime {
}

export interface Fuel {
    "prodANPCode": string;
    /**
     * percentage of natural gas (GLP)
     */
    "perMixGN"?: number;
    "authorizationCodeCODIF"?: string;
    /**
     * This decimal 12 integers and 0 to 4 decimals Quantidade de combustível faturada à temperatura ambiente. Informar quando a quantidade faturada informada no campo qCom (I10) tiver sido ajustada para uma temperatura diferente da ambiente. 
     */
    "quantityOnRoomTemperature"?: number;
    /**
     * state where fuel was used
     */
    "stateCodeOfUndUser": StateEnum;
    "cide"?: FuelCide;
    "pumpNumber"?: FuelPumpNumber;
}

export interface FuelCide {
    /**
     * percentage of natural gas (GLP), this decimal 12 integers and 0 to 4 decimals
     */
    "baseCalcCIDE": number;
    /**
     * percentage of natural gas (GLP), this decimal 11 integers and 0 to 4 decimals - R$
     */
    "rateCIDE": number;
    /**
     * percentage of natural gas (GLP), this decimal 13 integers and 2 decimals - R$
     */
    "valueCIDE": number;
}

export interface FuelPumpNumber {
    /**
     * Identification number of nozzle used in the dispensing process.   Numero de identificação do Bico utilizado no abastecimento 
     */
    "nozzleNumberFuelSupply": string;
    /**
     * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
     */
    "fuelPumpNumber": string;
    /**
     * Identification number of the Pump connect to the used nozzle.   Numero de identificação da bomba ao qual o bico está interligado 
     */
    "fuelTankNumber": string;
    /**
     * Valor do Encerrante no ínicio do abastecimento.  Reading of auto-counter (encerrante) at the start of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
     */
    "startValueOfPumpNumber": number;
    /**
     * Valor do Encerrante no final do abastecimento.  Reading of auto-counter (encerrante) at the end of the refueling/dispensing. This decimal 12 integers and 3 decimals - R$ 
     */
    "endValueOfPumpNumber": number;
}

export interface HeaderBaseInfo {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": HeaderBaseInfoTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code / transactions must be in Brazilian Reais \"BRL\"
     */
    "currency": HeaderBaseInfoCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
}

export type HeaderBaseInfoTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type HeaderBaseInfoCurrencyEnum = "BRL";
export interface HeaderForGoods {
    "messageType"?: HeaderForGoodsMessageTypeEnum;
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    "participants"?: HeaderForGoodsParticipants;
    /**
     * This is the public NF id. With this number is possible get invoice information directly from government.
     */
    "nfAccessKey"?: string;
    /**
     * qr code printed on DANFE;
     */
    "nfceQrCode"?: string;
    /**
     * This string indicates the type of transaction for which tax should be calculated.
     */
    "transactionType": HeaderForGoodsTransactionTypeEnum;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - '01' # Nota Fiscal 1/1A - '1B' # Nota Fiscal Avulsa - '02' # Nota Fiscal de Venda a-Consumidor - '2D' # Cupom Fiscal - '2E' # Cupom Fiscal-Bilhete de Passagem - '04' # Nota Fiscal de Produtor - '06' # Nota Fiscal/Conta de Energia Elétrica - '07' # Nota Fiscal de Serviço de Transporte - '08' # Conhecimento de Transporte Rodoviário de-Cargas - '8B' # Conhecimento de Transporte de-Cargas Avulso - '09' # Conhecimento de Transporte Aquaviário de-Cargas - '10' # Conhecimento Aéreo - '11' # Conhecimento de Transporte Ferroviário de-Cargas - '13' # Bilhete de Passagem Rodoviário - '14' # Bilhete de Passagem Aquaviário - '15' # Bilhete de Passagem e-Nota de-Bagagem - '16' # Bilhete de Passagem Ferroviário - '18' # Resumo de Movimento Diário - '21' # Nota Fiscal de Serviço de-Comunicação - '22' # Nota Fiscal de Serviço de Telecomunicação - '26' # Conhecimento de Transporte Multimodal de-Cargas - '27' # Nota Fiscal De Transporte Ferroviário De-Carga - '28' # Nota Fiscal/Conta de Fornecimento de Gás-Canalizado - '29' # Nota Fiscal/Conta de Fornecimento de Água-Canalizada - '55' # Nota Fiscal Eletrônica (NF-e) - '57' # Conhecimento de Transporte Eletrônico (CT-e) - '59' # Cupom Fiscal Eletrônico (CF-e-SAT) - '60' # Cupom Fiscal Eletrônico (CF-e-ECF) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
     */
    "transactionModel": HeaderForGoodsTransactionModelEnum;
    /**
     * Natureza da Opreração - 'Describe kind of this transaction, summary
     */
    "transactionClass"?: string;
    "eDocCreatorType": HeaderForGoodsEDocCreatorTypeEnum;
    /**
     * This Flag is used only when eDocCreatorType is other and the return show Taxes using eDocCreator perspective or self perspective.
     */
    "eDocCreatorPerspective"?: boolean;
    /**
     * This string is a code maintained by the client application and recorded in CUP to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
     */
    "entityCode": string;
    /**
     * currency code
     */
    "currency": HeaderForGoodsCurrencyEnum;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
    /**
     * This string is the transaction date in ISO 8601 format, create transaction date
     */
    "transactionDate": string;
    /**
     * This string is the transaction date in ISO 8601 format, when products were shipped, can be empty or absent
     */
    "shippingDate"?: string;
    "additionalInfo"?: AdditionalInformation;
    /**
     * how the document will be printed - '0' # without DANFE; - '1' # DANFe Letter; - '2' # DANFe Landscape; - '3' # DANFe Simplified; - '4' # DANFe NFC-e; - '5' # DANFe NFC-e e-mail 
     */
    "tpImp"?: HeaderForGoodsTpImpEnum;
    /**
     * This indicator inform transaction target place, when is AUTOMATIC the company address and entity address are analyzed to identify type of transaction target place 1- same state; 2 - interstate; 3-with exterior. Exist some cases where is necessary force this situation like when buyer from another state buy something in loco, the address are from different states, but transaction no.  Identificador de Local de destino da operação, na opção AUTOMATIC endereços da Companhia e da entidade destino são analisados para saber se é uma operação dentro do mesmo estado, interestadual ou com o exterior. Há situações onde é necessário forçar este indicador como por exemplo  Quando uma pessoa com endereço em outro estado, compra uma mercadoria de forma presencial, é uma operação interna apesar dos endereços dos envolvidos estarem em estados distintos. - 0 # AUTOMATIC - DEFAULT - 1 # Interna; - 2 # Interestadual; - 3 # Exterior) 
     */
    "idDest"?: number;
    /**
     * Presence indicator - '0' # Not applicable - '1' # Presential; - '2' # Remote, internet; - '3' # Remote, phone; - '4' # NFC-e home delivery; - '9' # Remote, others 
     */
    "indPres"?: HeaderForGoodsIndPresEnum;
    /**
     * Invoice number, sequential unique by invoice serial (Número da nota fiscal)
     */
    "invoiceNumber": number;
    /**
     * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
     */
    "invoiceSerial": number;
    "defaultLocations"?: DefaultLocations;
    /**
     * Shipment
     */
    "transport"?: Transport;
    /**
     * Transactions or other invoices referenced
     */
    "nfRef"?: Array<NRef>;
    "payment": Payment;
    "purchaseInfo"?: PurchaseInfo;
    "export"?: ExportInfo;
}

export type HeaderForGoodsMessageTypeEnum = "goods";
export type HeaderForGoodsTransactionTypeEnum = "Sales" | "Purchase" | "SalesReturn" | "PurchaseReturn" | "TransferReturn" | "Shipping" | "ShippingReturn" | "Transfer" | "ReceiptAdjustment" | "TransferAdjustment";
export type HeaderForGoodsTransactionModelEnum = "01" | "1B" | "02" | "2D" | "2E" | "04" | "06" | "07" | "08" | "8B" | "09" | "10" | "11" | "13" | "14" | "15" | "16" | "18" | "21" | "22" | "26" | "27" | "28" | "29" | "55" | "57" | "59" | "60" | "65";
export type HeaderForGoodsEDocCreatorTypeEnum = "self" | "other";
export type HeaderForGoodsCurrencyEnum = "BRL";
export type HeaderForGoodsTpImpEnum = "0" | "1" | "2" | "3" | "4" | "5";
export type HeaderForGoodsIndPresEnum = "0" | "1" | "2" | "3" | "4" | "9";
/**
 * List of transaction participants, Seller, Buyer, Carrier
 */
export interface HeaderForGoodsParticipants {
    "entity"?: EntityForGoods;
    "transporter"?: EntityForGoods;
}

export interface IbptConf {
    /**
     * IBPT Code
     */
    "code"?: string;
    "description"?: string;
    "list"?: Array<IpbtConfItem>;
}

export interface IcmsConfByState {
    /**
     * Identify the IcmsConfState in namespace
     */
    "code": string;
    "state": StateEnum;
    /**
     * name for this configuration
     */
    "name"?: string;
    /**
     * date when this configuration values starts
     */
    "startDate"?: Date;
    /**
     * date when this configuration values expire
     */
    "expirationDate"?: Date;
    /**
     * set this configuration to Inactive
     */
    "inactive"?: boolean;
    /**
     * inform that the item linked to this configuration is subject to ICMS ST on this state
     */
    "subjectToST"?: boolean;
    /**
     * On sales process inform the CST hat the item linked to this configuration is subject to for the own ICMS - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
     */
    "icmsCST"?: IcmsConfByStateIcmsCSTEnum;
    /**
     * how this ICMS will be calculed for itens linked to this configuration
     */
    "calcMode"?: IcmsConfByStateCalcModeEnum;
    /**
     * discount if the item is subject to monophase PIS/COFINS for transactions inside state
     */
    "discountRateForMonoPhase"?: number;
    /**
     * ICMS rate
     */
    "rate"?: number;
    /**
     * ICMS rate
     */
    "icmsBaseDiscount"?: number;
    /**
     * SRP or MMSRP amount base for this icms configuration
     */
    "msrp"?: number;
    /**
     * ICMS mva rate to define calc base
     */
    "mvaRate"?: number;
    /**
     * unit used to SRP amount value
     */
    "msrpUnit"?: string;
    /**
     * Code for the ICM legal reason, this message will be placed on invoice.
     */
    "icmsLegalReason"?: string;
    /**
     * Fundo de Combate à pobreza / Fund Against Poverty
     */
    "fcpRate"?: number;
    "icmsSTConf"?: IcmsConfByStateIcmsSTConf;
    /**
     * the map key is state code
     */
    "icmsInterStateConf"?: Array<IcmsConfInterState>;
}

export type IcmsConfByStateIcmsCSTEnum = "00" | "20" | "40" | "41" | "50";
export type IcmsConfByStateCalcModeEnum = "BYMVARATE" | "SRP" | "MMSRP" | "OPERATIONAMOUNT";
export interface IcmsConfByStateIcmsSTConf {
    /**
     * inform that substituted is tax regime Simplified the operation MVA will be reduced
     */
    "hasReductionOfMVAForSimples"?: boolean;
    /**
     * mva reduction when substituted is tax regime Simplified.
     */
    "reductionOfMVAForSimples"?: number;
    /**
     * how this ICMS-ST will be calculed for itens linked to this configuration
     */
    "calcMode"?: IcmsConfByStateIcmsSTConfCalcModeEnum;
    /**
     * ICMS-ST mva rate to define calc base
     */
    "mvaRate"?: number;
    /**
     * ICMS rate - Redução da BC ICMS ST (%)
     */
    "icmsStBaseDiscount"?: number;
    /**
     * SRP or MSRP amount base for this ICMS-ST configuration
     */
    "srp"?: number;
    /**
     * unit used to srv amount value
     */
    "srpUnit"?: string;
}

export type IcmsConfByStateIcmsSTConfCalcModeEnum = "BYMVARATE" | "SRP" | "MSRP";
export interface IcmsConfInterState {
    "state"?: StateEnum;
    /**
     * how this ICMS will be calculed for itens linked to this configuration
     */
    "calcMode"?: IcmsConfInterStateCalcModeEnum;
    /**
     * discount if the item is subject to monophase PIS/COFINS when operation interstate
     */
    "discountRateForMonoPhase"?: number;
    /**
     * ICMS rate
     */
    "rate"?: number;
    /**
     * FCP rate (Fundo de Combate à Probreza / Fund Against Poverty
     */
    "fcpRate"?: number;
    /**
     * ICMS rate
     */
    "icmsBaseDiscount"?: number;
    /**
     * SRP or MMSRP amount base for this icms configuration
     */
    "msrp"?: number;
    /**
     * ICMS MVA rate to define calc base
     */
    "mvaRate"?: number;
    /**
     * unit used to SRP amount value
     */
    "msrpUnit"?: string;
    /**
     * Code for the ICM legal reason, this message will be placed on invoice.
     */
    "icmsLegalReason"?: string;
    "icmsSTConf"?: IcmsConfInterStateIcmsSTConf;
}

export type IcmsConfInterStateCalcModeEnum = "BYMVARATE" | "SRP" | "MMSRP" | "OPERATIONAMOUNT";
export interface IcmsConfInterStateIcmsSTConf {
    "protocolType"?: IcmsConfInterStateIcmsSTConfProtocolTypeEnum;
    /**
     * inform that substituted is tax regime Simplified the operation MVA will be reduced
     */
    "hasReductionOfMVAForSimples"?: boolean;
    /**
     * MVA reduction when substituted is tax regime Simplified.
     */
    "reductionOfMVAForSimples"?: number;
    /**
     * how this ICMS-ST will be calculed for itens linked to this configuration
     */
    "calcMode"?: IcmsConfInterStateIcmsSTConfCalcModeEnum;
    /**
     * ICMS rate - Redução da BC ICMS ST (%)
     */
    "icmsStBaseDiscount"?: number;
    /**
     * ICMS-ST MVA rate to define calc base
     */
    "mvaRate"?: number;
    /**
     * SRP or MSRP amount base for this ICMS-ST configuration
     */
    "srp"?: number;
    /**
     * unit used to SRP amount value
     */
    "srpUnit"?: string;
}

export type IcmsConfInterStateIcmsSTConfProtocolTypeEnum = "COVENANT" | "PROTOCOL" | "NOTHING";
export type IcmsConfInterStateIcmsSTConfCalcModeEnum = "BYMVARATE" | "SRP" | "MSRP";
export interface IcmsTaxConf {
    "state": StateEnum;
    /**
     * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
     */
    "icmsCST"?: IcmsTaxConfIcmsCSTEnum;
    /**
     * Message to add to NF when this configuration is used
     */
    "messageCode"?: string;
    /**
     * the mapping key is state code / A chave do mapeamento é o código do Estado.
     */
    "relationShip"?: Array<IcmsTaxConfBase>;
}

export type IcmsTaxConfIcmsCSTEnum = "00" | "20" | "40" | "41" | "50";
export interface IcmsTaxConfBase {
    "state": StateEnum;
    /**
     * On sales process inform the CST hat the item linked to this configuration is subject to - '00' # TAXABLE - '20' # TAXABLE WITH BASE DISCOUNT - '40' # EXEMPT - '41' # NOT TAXABLE - '50' # SUSPENDED 
     */
    "icmsCST"?: IcmsTaxConfBaseIcmsCSTEnum;
    /**
     * Message to add to NF when this configuration is used
     */
    "messageCode"?: string;
}

export type IcmsTaxConfBaseIcmsCSTEnum = "00" | "20" | "40" | "41" | "50";
/**
 * Internal Type used to references all taxes.
 */
export interface InformerForGoods {
    "header"?: HeaderForGoods;
    "line"?: LineForGoods;
    "company"?: EntityInformerForGoods;
    "entity"?: EntityInformerForGoods;
    "emitter"?: EntityInformerForGoods;
    "receiver"?: EntityInformerForGoods;
    "transporter"?: EntityInformerForGoods;
    "csts"?: InformerForGoodsCsts;
    "amount"?: number;
    "discount"?: number;
    "quantity"?: number;
    "unitPrice"?: number;
    "freightAmount"?: number;
    "insuranceAmount"?: number;
    "otherCostAmount"?: number;
    "exemptValue"?: number;
}

export interface InformerForGoodsCsts {
    /**
     * CST-B
     */
    "icms"?: string;
    /**
     * CST-IPI
     */
    "ipi"?: string;
    /**
     * CST PIS/COFINS
     */
    "pisCofins"?: string;
}

export interface InlineResponse200 {
    "token"?: string;
    "expired"?: Date;
}

export interface InlineResponse2001 {
    /**
     * Item description
     */
    "description"?: string;
    /**
     * uuid
     */
    "id"?: string;
    /**
     * Custom item code
     */
    "code"?: string;
}

export interface InlineResponse2002 {
    "companyId"?: string;
}

export interface InlineResponse2003 {
    "contingency"?: boolean;
    "startDate"?: Date;
    "finishDate"?: Date;
}

export interface InlineResponse2004 {
    /**
     * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação                 
     */
    "environment"?: InlineResponse2004EnvironmentEnum;
}

export type InlineResponse2004EnvironmentEnum = "1" | "2";
export interface InlineResponse201 {
    "id"?: number;
}

export interface InstallmentComplete {
    /**
     * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
     */
    "documentNumber": string;
    /**
     * installment Due Date
     */
    "date": Date;
    /**
     * Intallment amount, fraction of  ∑(lineAmount - lineTaxedDiscount)
     */
    "grossValue": number;
    /**
     * net amount due for this installment, grossValue - ∑ (withhold amounts)
     */
    "netValue"?: number;
    /**
     * Inform if this payment is subject to Pis, Cofins or CSLL
     */
    "withholdingMode"?: WithholdingMode;
    /**
     * calculated PIS-RF tax for this payment
     */
    "withholdingPIS"?: number;
    /**
     * calculated COFINS-RF tax for this payment
     */
    "withholdingCOFINS"?: number;
    /**
     * calculated CSLL-RF tax for this payment
     */
    "withholdingCSLL"?: number;
}

export interface IpbtConfItem {
    "state"?: StateEnum;
    "federalTax"?: number;
    "importTax"?: number;
    "stateTax"?: number;
    "cityTax"?: number;
    "source"?: string;
}

export interface IssConfByCity {
    /**
     * City Code (IBGE)
     */
    "cityCode": number;
    "name"?: string;
    "state"?: StateEnum;
    "issWhDestOtherCities"?: boolean;
    "issWhDestSameCity"?: boolean;
    "issWhOriginUnregSeller"?: boolean;
    "serviceList"?: Array<IssConfServiceList>;
}

export interface IssConfServiceList {
    "agast"?: string;
    "cityServiceCode"?: string;
    "taxRate"?: IssConfServiceListTaxRate;
}

export interface IssConfServiceListTaxRate {
    "iSS"?: ServiceItemTaxRate;
    "iSSRF"?: ServiceItemTaxRate;
    "iSSE"?: ServiceItemTaxRate;
    "iSSI"?: ServiceItemTaxRate;
    "ibpt"?: IssConfServiceListTaxRateIbpt;
}

export interface IssConfServiceListTaxRateIbpt {
    "nationalFedTax"?: number;
    "cityTax"?: number;
}

export interface ItemCpom {
    /**
     * Company ID
     */
    "companyId": string;
    /**
     * IBGE city code
     */
    "cityCode": string;
    /**
     * ERP Code
     */
    "itemCode": string;
    /**
     * Code in City
     */
    "code": string;
}

export interface ItemGoods {
    /**
     * Company ID
     */
    "companyId": string;
    /**
     * ERP Code
     */
    "code": string;
    /**
     * Agast Code
     */
    "agast": string;
    /**
     * Item Description
     */
    "description"?: string;
    /**
     * Seal Code for ipi tax control (código do selo para controle de IPI)
     */
    "sealCode": string;
    /**
     * Importation content form number (Número de controle da FCI - Ficha de Conteúdo de Importação)
     */
    "nFCI"?: string;
    /**
     * this field inform that this merchandise or product is ICMS Substitute Must be used when the item is for resale and the company will assume the role of ICMS Substitute (wholesaler, retailer, distributor). Example: when Importing some product the company does not pay IcmsSt at the time of customs clearance but when selling sale the item. Deverá ser utilizado quando a empresa que irá vender a mercadoria sujeita ao ICMS ST for o SUBSTITUTO TRIBUTÁRIO (Distribuidor, atacadista e varejista), como por exemplo das mercadorias IMPORTADAS, neste sentido, a empresa não irá pagar o ICMS ST no desembaraço aduaneiro e irá recolher quando for vender as mesmas. 
     */
    "isIcmsStSubstitute"?: boolean;
    /**
     * - '0' # National goods - except those treated in codes 3,4, 5 and 8 - '1' # Foreign goods - Imported directly by seller, except those in code 6 - '2' # Foreign goods - Acquired in the internal market (inside Brazil), except those in code 7 - '3' # National goods - Merchandise or goods with imported content above 40% and with less than or equal to 70% - '4' # National goods from production following 'standard basic processes' as stablished by legislation (standard basic processes are devised to separate simple assembly from manufaturing processes) - '5' # National goods - Merchandise or goods with imported content equal or below 40% - '6' # Foreign goods - Directly imported by Seller, without a National Equivalent as listed by Comex and natural gas - '7' # Foreign goods - Acquired inside Brazil, without a National Equivalent  as listed by Comex and natural gas - '8' # National goods - Merchandise or goods with imported content above 70% 
     */
    "source"?: ItemGoodsSourceEnum;
    "productType"?: ItemGoodsProductTypeEnum;
    /**
     * Item is merchandise but will be considered product
     */
    "manufacturerEquivalent"?: boolean;
    /**
     * Inform that this item will have rights to aprropriate IPI credit
     */
    "appropriateIPIcreditWhenInGoing"?: boolean;
    /**
     * Subject to appropriate PIS/COFINS credit, when NO CUMULATIVE
     */
    "usuallyAppropriatePISCOFINSCredit"?: boolean;
    /**
     * The credit PIS/COFINS is subject to purchase form companies, but exist some exceptions, when the credit will be a estimated amount
     */
    "isPisCofinsEstimatedCredit"?: boolean;
    /**
     * - '01' # Vinculada Exclusivamente a Receita Tributada no Mercado Interno - '02' # Exclusivamente a Receita Não Tributada no Mercado Interno - '03' # Exclusivamente a Receita de Exportação - '04' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno - '05' # Vinculada a Receitas Tributadas no Mercado Interno e de Exportação - '06' # Vinculada a Receitas Não-Tributadas no Mercado Interno e de Exportação - '07' # Vinculada a Receitas Tributadas e Não-Tributadas no Mercado Interno, e de Exportação 
     */
    "piscofinsRevenueType"?: ItemGoodsPiscofinsRevenueTypeEnum;
    /**
     * Discount allowed on icms base when PIS/COFINS are Monophase
     */
    "icmsBaseDiscountForMonoPhaseSocialContr"?: number;
    /**
     * tax substitution code - Codigo especificador da Substuicao Tributaria
     */
    "cest"?: string;
    /**
     * GTIN NUMBER
     */
    "cean"?: string;
    /**
     * Nomenclatura de Valor aduaneio e Estatístico - NCM extension code
     */
    "nve"?: string;
    "salesUnit"?: string;
    /**
     * factor to convert sales quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "salesUnitIPIfactor"?: number;
    /**
     * factor to convert sales quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "salesUnitIcmsfactor"?: number;
    /**
     * factor to convert sales quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "salesUnitIcmsStfactor"?: number;
    /**
     * factor to convert sales quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "salesUnitPisCofinsfactor"?: number;
    "purchaseUnit"?: string;
    /**
     * factor to convert purchase quantity to IPI taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "purchaseUnitIPIfactor"?: number;
    /**
     * factor to convert purchase quantity to ICMS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "purchaseUnitIcmsfactor"?: number;
    /**
     * factor to convert purchase quantity to ICMS-ST taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "purchaseUnitIcmsStfactor"?: number;
    /**
     * factor to convert purchase quantity to PIS/COFINS taxable quantity when it is by SRF Statutory Retail Price (Pauta)
     */
    "purchaseUnitPisCofinsfactor"?: number;
    /**
     * When the product is new, and will be retail, firt time that it exit it is subject to IPI
     */
    "firstUse"?: boolean;
}

export type ItemGoodsSourceEnum = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8";
export type ItemGoodsProductTypeEnum = "FOR PRODUCT" | "FOR MERCHANDISE" | "NO RESTRICTION" | "SERVICE" | "FEEDSTOCK" | "FIXED ASSETS";
export type ItemGoodsPiscofinsRevenueTypeEnum = "01" | "02" | "03" | "04" | "05" | "06" | "07";
export interface ItemSimple {
    /**
     * Company ID
     */
    "companyId": string;
    /**
     * ERP Code
     */
    "code": string;
    /**
     * Agast Code
     */
    "agast": string;
    /**
     * Item Description
     */
    "description"?: string;
}

/**
 * Legal Reason (Fundamentação Legal): - 'name' - 'description' - 'scope' 
 */
export interface LegalReason {
    /**
     * Internal ID
     */
    "id"?: string;
    /**
     * Message scope. May be one of these. general - This message is not linked to any entity (agast/process/cfop) and will be applied to any item in a transacition. (Esta mensagem tem escopo geral, nao está relacionadas diretamente qualquer objeto.); linkedTo - This message is linked to an entity, and its processing will only occur when the context involves it. (Esta mensagens estão relacionadas diretamente a algum objeto como um AGAST por exemplo, um Processo ou uma CFOP.); 
     */
    "scope": LegalReasonScopeEnum;
    /**
     * Set this message as no longer valid
     */
    "disable"?: boolean;
    /**
     * Legal reason textual description;
     */
    "description": string;
    /**
     * Short name to this message
     */
    "name": string;
    /**
     * this field inform the official code number
     */
    "legalCode"?: string;
    /**
     * Optional. Show this message when used in Invoice (NFe, NFCe, others...). Where to show this.
     */
    "showInInvoice"?: LegalReasonShowInInvoiceEnum;
    /**
     * Referenced Process
     */
    "referencedProcesses"?: Array<LegalReasonReferencedProcesses>;
    "taxScope"?: LegalReasonTaxScope;
}

export type LegalReasonScopeEnum = "general" | "linkedTo";
export type LegalReasonShowInInvoiceEnum = "complementaryInfoMessage" | "fiscalInfoMessage" | "itemInfoMessage";
export interface LegalReasonReferencedProcesses {
    /**
     * Process Identifier (NFe <nProc> tag)
     */
    "nProc"?: string;
    /**
     * Process Origin (NFe <indProc> tag) - '0' # SEFAZ; - '1' # Justiça Federal; - '2' # Justiça Estadual; - '3' # Secex/RFB; - '9' # Outros 
     */
    "indProc"?: LegalReasonReferencedProcessesIndProcEnum;
}

export type LegalReasonReferencedProcessesIndProcEnum = "0" | "1" | "2" | "3" | "9";
/**
 * Filter this message application to specified tax cases. - taxtype - jurisdictionType 
 */
export interface LegalReasonTaxScope {
    /**
     * This is the Tax Type to apply legal messages. - 'NONE' - 'INSS' - 'IRRF' - 'IRPJ' - 'PIS' - 'COFINS' - 'CSLL' - 'IPI' - 'ICMS' - 'II' - 'IOF' - 'ISS' - 'APROXTOTALTAX' 
     */
    "taxType": LegalReasonTaxScopeTaxTypeEnum;
    /**
     * These are the specific tax types to which a message may be applied - 'icms' - 'icmsSt' - 'icmsStSd' - 'icmsPartOwn' - 'icmsPartDest' - 'icmsDifaFCP' - 'icmsDifaDest' - 'icmsDifaRemet' - 'icmsRf' - 'icmsDeson' - 'icmsCredsn' - 'pis' - 'pisSt' - 'cofins' - 'cofinsSt' - 'ipi' - 'ipiReturned' - 'ii' - 'iof' 
     */
    "specializedTaxType"?: LegalReasonTaxScopeSpecializedTaxTypeEnum;
    /**
     * Types of jurisdiction - 'NONE' - 'City' - 'State' - 'Country' 
     */
    "jurisdictionType": LegalReasonTaxScopeJurisdictionTypeEnum;
    /**
     * Code to identify the Jurisdiction
     */
    "jurisdictionIbgeCode"?: string;
}

export type LegalReasonTaxScopeTaxTypeEnum = "NONE" | "INSS" | "IRRF" | "IRPJ" | "PIS" | "COFINS" | "CSLL" | "IPI" | "ICMS" | "II" | "IOF" | "ISS" | "APROXTOTALTAX";
export type LegalReasonTaxScopeSpecializedTaxTypeEnum = "icms" | "icmsSt" | "icmsStSd" | "icmsPartOwn" | "icmsPartDest" | "icmsDifaFCP" | "icmsDifaDest" | "icmsDifaRemet" | "icmsRf" | "icmsDeson" | "icmsCredsn" | "pis" | "pisSt" | "cofins" | "cofinsSt" | "ipi" | "ipiReturned" | "ii" | "iof";
export type LegalReasonTaxScopeJurisdictionTypeEnum = "NONE" | "City" | "State" | "Country";
export interface LineForGoods {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode": number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * AGAST CODE for itemCode
     */
    "avalaraGoodsAndServicesType"?: string;
    /**
     * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems": number;
    /**
     * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
     */
    "returnedPercentageAmount"?: number;
    /**
     * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
     */
    "lineUnitPrice"?: number;
    /**
     * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
     */
    "lineAmount": number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription": string;
    /**
     * Discount conditional, This decimal 13 integers and 0 to 2 decimals
     */
    "lineTaxedDiscount"?: number;
    /**
     * discount unconditional, This decimal 13 integers and 0 to 2 decimals
     */
    "lineUntaxedDiscount"?: number;
    /**
     * This is a enumeration folowing table
     */
    "useType": LineForGoodsUseTypeEnum;
    /**
     * Reference to process configurantion of this transaction, See ProcessScenario definition
     */
    "processScenario": string;
    /**
     * Fiscal Operation Code of transport service
     */
    "cfop"?: number;
    /**
     * return if this transaction has stock impact for this process or CFOP
     */
    "hasStockImpact"?: boolean;
    /**
     * return if this transaction has finantial impact for this process or CFOP
     */
    "hasFinantialImpact"?: boolean;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "freightAmount"?: number;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "insuranceAmount"?: number;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "otherCostAmount"?: number;
    /**
     * The item value will compose the invoice total value.
     */
    "indTotType"?: boolean;
    /**
     * order number, information used for B2B control process
     */
    "orderNumber"?: string;
    /**
     * number of the item from order number, information used for B2B control process
     */
    "orderItemNumber"?: string;
    /**
     * Gloal Unique identifier (Importation form)
     */
    "fciNumber"?: string;
    /**
     * RECOPI number
     */
    "recopiNumber"?: string;
    /**
     * additional information about product (referenced standard, complementary info, etc)
     */
    "infAdProd"?: string;
    "vehicle"?: Vehicle;
    "medicine"?: Medicine;
    "weapon"?: Weapon;
    "fuel"?: Fuel;
    /**
     * Inform that for this item the Entity referenced is ICMS Substitute
     */
    "entityIsIcmsSubstitute"?: boolean;
    /**
     * Inform that this item has ICMS withheld for transport value service.
     */
    "isTransportIcmsWithheld"?: boolean;
    "icmsTaxRelief"?: LineForGoodsIcmsTaxRelief;
    /**
     * Exportation detail
     */
    "export"?: Array<LineForGoodsExport>;
    /**
     * Import declaration
     */
    "di"?: Array<LineForGoodsDi>;
    "calculatedTax"?: LineForGoodsCalculatedTax;
}

export type LineForGoodsUseTypeEnum = "use or consumption" | "resale" | "agricultural production" | "production" | "use or consumption on business establishment" | "use or consumption on transporter service establishment" | "use or consumption on communication service establishment" | "use or consumption on demand by contract" | "use or consumption on energy supplier establishment" | "use or consumption of fuel transaction type exportation" | "fixed assets" | "resale export" | "resale icms exempt" | "resale buyer under the same icmsSt tax rule" | "transport of goods that don't need invoice (nf)";
export interface LineForGoodsAdi {
    /**
     * aditional sequence number (1 to 100)
     */
    "addNumber": number;
    /**
     * sequential item number for this adi, sequence number (1 to 999)
     */
    "sequentialNumber": number;
    /**
     * Manufatorer erp internal code
     */
    "manufacturerCode": string;
    /**
     * This decimal 13 integers and 2 decimals, aditional adi discount
     */
    "adiDiscount"?: number;
    /**
     * Drawback number
     */
    "drawbackNumber"?: string;
}

export interface LineForGoodsCalculatedTax {
    "taxByType"?: LineForGoodsCalculatedTaxTaxByType;
    "tax"?: number;
    "details"?: Array<DetailsCalculatedTaxItem>;
}

export interface LineForGoodsCalculatedTaxTaxByType {
    "icms"?: TaxByTypeTax;
    "icmsSt"?: TaxByTypeTax;
    "icmsStSd"?: TaxByTypeTax;
    "icmsPartOwn"?: TaxByTypeTax;
    "icmsPartDest"?: TaxByTypeTax;
    "icmsDifaFCP"?: TaxByTypeTax;
    "icmsDifaDest"?: TaxByTypeTax;
    "icmsDifaRemet"?: TaxByTypeTax;
    "icmsRf"?: TaxByTypeTax;
    "icmsDeson"?: TaxByTypeTax;
    "icmsCredsn"?: TaxByTypeTax;
    "pis"?: TaxByTypeTax;
    "pisSt"?: TaxByTypeTax;
    "cofins"?: TaxByTypeTax;
    "cofinsSt"?: TaxByTypeTax;
    "ipi"?: TaxByTypeTax;
    "ipiReturned"?: TaxByTypeTax;
    "ii"?: TaxByTypeTax;
    "iof"?: TaxByTypeTax;
    "aproxtribState"?: TaxByTypeTax;
    "aproxtribFed"?: TaxByTypeTax;
}

export interface LineForGoodsDi {
    /**
     * customs value, valor aduaneiro (II Block of NFe)
     */
    "customsValue"?: number;
    /**
     * Import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
     */
    "diNumber": string;
    /**
     * Register date of import declaration number, DI/DSI/DA/DRI-E (DI/DSI/DA/DRI-E)
     */
    "registerDateDI": Date;
    /**
     * Clerance Site Local do desembaraço aduaneiro 
     */
    "clearanceSite": string;
    /**
     * Clerance Site State Estado onde ocorrreu o desembaraço aduaneiro 
     */
    "clearanceState": StateEnum;
    /**
     * Clerance date
     */
    "clearanceDate"?: Date;
    /**
     * - '1' # Maritima - '2' # Fluvial - '3' # Lacustre - '4' # Aerea - '5' # Postal - '6' # Ferroviaria - '7' # Rodoviaria - '8' # Conduto - '9' # Meios Proprios - '10' # Entrada/Saida Ficta 
     */
    "transportDIType": LineForGoodsDiTransportDITypeEnum;
    /**
     * Aditional amount to freight to renew merchant marine, This decimal 13 integers and 2 decimals [Valor Adicional ao frete para renovação de marinha mercante] 
     */
    "afrmmValue"?: number;
    /**
     * - '1' # On One's Own [1-por conta propria] - '2' # On Behalf And Order [2-por conta e ordem] - '3' # Order [3-encomenda] 
     */
    "intermediateType": LineForGoodsDiIntermediateTypeEnum;
    /**
     * Buyer federal tax id CNPJ do comprador ou encomendante 
     */
    "buyerFederalTaxID"?: string;
    /**
     * Buyer sate Estado do comprador ou encomendante 
     */
    "buyerState"?: StateEnum;
    /**
     * Exporter code
     */
    "exporterCode"?: string;
    /**
     * aditional import declaration
     */
    "adi": Array<LineForGoodsAdi>;
}

export type LineForGoodsDiTransportDITypeEnum = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10";
export type LineForGoodsDiIntermediateTypeEnum = "1" | "2" | "3";
export interface LineForGoodsExport {
    "drawbackNumber"?: string;
    "indExport"?: LineForGoodsIndExport;
}

export interface LineForGoodsIcmsTaxRelief {
    /**
     * When item transaction subject to desoneration, this is the reason code - 1 # Táxi; - 3 # Produtor Agropecuário; - 4 # Frotista/Locadora; - 5 # Diplomático/Consular; - 6 # Utilitários e Motocicletas da Amazônia Ocidental e Áreas de Livre Comércio (Resolução 714/88 e 790/94 – CONTRAN e suas alterações); - 7 # SUFRAMA; - 8 # Venda a órgão Público; - 9 # Outros - 10 # Deficiente Condutor - 11 # Deficiente não condutor - 12 # Fomento agropecuário - 16 # Olimpíadas Rio 2016 
     */
    "icmsTaxReliefReasonCode": number;
    /**
     * ICMS Tax base rate discount  (desconto na base do ICMS referetne a desoneração)
     */
    "icmsReliefTaxRate"?: number;
    /**
     * Amount for Icms Relief (desoneração)
     */
    "icmsReliefTaxAmount"?: number;
}

/**
 * indirect exportation
 */
export interface LineForGoodsIndExport {
    /**
     * Exportation register number
     */
    "registerNumber": string;
    /**
     * invoice access key received to export
     */
    "accessKey": string;
    /**
     * This decimal 11 integers and 0 to 4 decimals, quantity exported in real
     */
    "quantity": number;
}

export interface LineForSefazGoods {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode": number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * AGAST CODE for itemCode
     */
    "avalaraGoodsAndServicesType"?: string;
    /**
     * This decimal 11 integers and 1 to 4 decimals captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems": number;
    /**
     * when is return operation this field inform the percentage of returned itens. This decimal max 3 integers and 2 decimals, v >=0.00 and v <= 100.00
     */
    "returnedPercentageAmount"?: number;
    /**
     * This decimal 11 integers and 1 to 10 decimals captures the unit price of this line.
     */
    "lineUnitPrice"?: number;
    /**
     * In its simplest form lineAmount = (item price * numberOfItems). If taxIncluded is 'true', lineAmount = (item price * numberOfItems + tax).
     */
    "lineAmount": number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription": string;
    /**
     * Discount conditional, This decimal 13 integers and 0 to 2 decimals
     */
    "lineTaxedDiscount"?: number;
    /**
     * discount unconditional, This decimal 13 integers and 0 to 2 decimals
     */
    "lineUntaxedDiscount"?: number;
    /**
     * This is a enumeration folowing table
     */
    "useType": LineForSefazGoodsUseTypeEnum;
    /**
     * Reference to process configurantion of this transaction, See ProcessScenario definition
     */
    "processScenario": string;
    /**
     * Fiscal Operation Code of transport service
     */
    "cfop"?: number;
    /**
     * return if this transaction has stock impact for this process or CFOP
     */
    "hasStockImpact"?: boolean;
    /**
     * return if this transaction has finantial impact for this process or CFOP
     */
    "hasFinantialImpact"?: boolean;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "freightAmount"?: number;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "insuranceAmount"?: number;
    /**
     * This decimal 13 integers and 0 to 2 decimals
     */
    "otherCostAmount"?: number;
    /**
     * The item value will compose the invoice total value.
     */
    "indTotType"?: boolean;
    /**
     * order number, information used for B2B control process
     */
    "orderNumber"?: string;
    /**
     * number of the item from order number, information used for B2B control process
     */
    "orderItemNumber"?: string;
    /**
     * Gloal Unique identifier (Importation form)
     */
    "fciNumber"?: string;
    /**
     * RECOPI number
     */
    "recopiNumber"?: string;
    /**
     * additional information about product (referenced standard, complementary info, etc)
     */
    "infAdProd"?: string;
    "vehicle"?: Vehicle;
    "medicine"?: Medicine;
    "weapon"?: Weapon;
    "fuel"?: Fuel;
    /**
     * Inform that for this item the Entity referenced is ICMS Substitute
     */
    "entityIsIcmsSubstitute"?: boolean;
    /**
     * Inform that this item has ICMS withheld for transport value service.
     */
    "isTransportIcmsWithheld"?: boolean;
    "icmsTaxRelief"?: LineForGoodsIcmsTaxRelief;
    /**
     * Exportation detail
     */
    "export"?: Array<LineForGoodsExport>;
    /**
     * Import declaration
     */
    "di"?: Array<LineForGoodsDi>;
    "calculatedTax"?: LineForGoodsCalculatedTax;
    "extend"?: AgastExtendForSefaz;
}

export type LineForSefazGoodsUseTypeEnum = "use or consumption" | "resale" | "agricultural production" | "production" | "use or consumption on business establishment" | "use or consumption on transporter service establishment" | "use or consumption on communication service establishment" | "use or consumption on demand by contract" | "use or consumption on energy supplier establishment" | "use or consumption of fuel transaction type exportation" | "fixed assets" | "resale export" | "resale icms exempt" | "resale buyer under the same icmsSt tax rule" | "transport of goods that don't need invoice (nf)";
export interface Location {
    /**
     * Street Name
     */
    "street"?: string;
    /**
     * Neighborhood Name
     */
    "neighborhood"?: string;
    /**
     * Brazilian Zip Code
     */
    "zipcode": string;
    /**
     * City Code (IBGE)
     */
    "cityCode"?: string;
    /**
     * City Name
     */
    "cityName"?: string;
    "state"?: StateEnum;
    /**
     * Country Code
     */
    "countryCode"?: string;
    /**
     * Use ISO 3166-1 alpha-3 codes
     */
    "country"?: string;
    /**
     * House number
     */
    "number"?: string;
    /**
     * Any other information about the address (Room, Suite, Floor, etc)).
     */
    "complement"?: string;
    /**
     * Phone number
     */
    "phone"?: string;
    /**
     * Company ID
     */
    "companyId": string;
    /**
     * this property identify the location, it is unique for this company
     */
    "code": string;
    /**
     * this property identify the location, it is unique for this company
     */
    "type": LocationTypeEnum;
    /**
     * Email
     */
    "email"?: string;
    /**
     * Federal tax id, CNPJ or CPF
     */
    "federalTaxId"?: string;
    /**
     * state tax id for this location
     */
    "stateTaxId"?: string;
    "secondaryStateTaxId"?: Array<LocationSecondaryStateTaxId>;
    /**
     * City Tax ID
     */
    "cityTaxId"?: string;
    "suframa"?: string;
    /**
     * Main location activity
     */
    "mainActivity"?: LocationMainActivityEnum;
    /**
     * - 'edi' # City hall has web service and the integration is automatic - 'xml' # Create RPS specific to City, bat does not have webservice integration - 'rps' # Create a generic RPS, NF is by hands 
     */
    "nfseProcessModel"?: LocationNfseProcessModelEnum;
}

export type LocationTypeEnum = "ShipFrom" | "ShipTo" | "ServiceRendered";
export type LocationMainActivityEnum = "commerce" | "industry" | "service";
export type LocationNfseProcessModelEnum = "edi" | "xml" | "rps";
export interface LocationSecondaryStateTaxId {
    "stateTaxId"?: string;
    "state"?: StateEnum;
}

export interface Medicine {
    "loteNumber": string;
    /**
     * This is a decimal type with 11 digits including 3 decimal positions.
     */
    "loteQuantity": number;
    "manufactotyDate": Date;
    "expirationDate": Date;
    /**
     * This is a decimal type with 15 digits including 2 decimal positions.  Max value to end user.
     */
    "maxValueToEndUser": number;
}

export interface Message {
    "message"?: string;
}

export interface ModelError {
    "code"?: number;
    "message": string;
    "field"?: string;
    "value"?: string;
    "in"?: ModelErrorModelInEnum;
}

export type ModelErrorModelInEnum = "params" | "body" | "query";
/**
 * Referenced Invoices The invoice can be one of this types, - 'refNFe - Eletronic Invoice' - 'refCTE - Transport Invoice' - 'refECF - Reatail Cupom' - 'refNF  - Invoice model 1 or 1A' - 'refFarmerNF - farmer invoice' 
 */
export interface NRef {
    "type"?: NRefTypeEnum;
    "refNFe"?: string;
    "refCTe"?: string;
    "refECF"?: NRefRefECF;
    "refNF"?: NRefRefNF;
    "refFarmerNF"?: NRefRefFarmerNF;
}

export type NRefTypeEnum = "refNFe" | "refCTE" | "refECF" | "refNF" | "refFarmerNF";
export interface NRefRefECF {
    /**
     * ECF Sequential number that generated Cupom attached to NFe informar o número de ordem seqüencial do ECF que emitiu o Cupom Fiscal vinculado à NF-e 
     */
    "nECF": string;
    /**
     * Operational counter number attached to NFe Informar o Número do Contador de Ordem de Operação - COO vinculado à NF-e 
     */
    "nCOO": string;
    /**
     * Fiscal document model - '2B' # coupon tax not ECF - '2C' # PDV coupon tax - '2D' # ECF coupon tax 
     */
    "modECF": NRefRefECFModECFEnum;
}

export type NRefRefECFModECFEnum = "2B" | "2C" | "2D";
export interface NRefRefFarmerNF {
    /**
     * State code of fiscal Document creator, farmer
     */
    "stateCd": StateEnum;
    /**
     * year and month of fiscal document creation
     */
    "yymm": string;
    /**
     * fiscal document creator farmer federalTaxId
     */
    "federalTaxId": string;
    /**
     * fiscal document creator, farmer stateTaxId
     */
    "stateTaxId": string;
    /**
     * Document Fiscal model - '04' # FARMER DOCUMENT - '01' # DETACHED DOCUMENT - AVULSO 
     */
    "model": NRefRefFarmerNFModelEnum;
    /**
     * fiscal document serie
     */
    "serie": string;
    /**
     * fiscal document number
     */
    "number": string;
}

export type NRefRefFarmerNFModelEnum = "04" | "01";
export interface NRefRefNF {
    /**
     * State code of fiscal Document creator
     */
    "stateCd": StateEnum;
    /**
     * year and month of fiscal document creation
     */
    "yymm": string;
    /**
     * fiscal document creator federalTaxId
     */
    "federalTaxId": string;
    /**
     * fiscal document serie
     */
    "serie": string;
    /**
     * fiscal document number
     */
    "number": string;
}

export interface PayRecCalculatedTaxSummaryForService {
    /**
     * Count of lines
     */
    "numberOfLines"?: number;
    /**
     * Sum of grossvalues
     */
    "subtotal"?: number;
    /**
     * Sum of all withholding values
     */
    "totalTax"?: number;
    /**
     * Sum all NetValues
     */
    "grandTotal"?: number;
    "pccWithholdingModes"?: Array<PccWithholdingMode>;
    "taxByType"?: PayRecCalculatedTaxSummaryForServiceTaxByType;
}

/**
 * Object with summary of all taxes returned by engine
 */
export interface PayRecCalculatedTaxSummaryForServiceTaxByType {
    "issRf"?: TaxByTypeSummaryForService;
    "pisRf"?: TaxByTypeSummaryForService;
    "cofinsRf"?: TaxByTypeSummaryForService;
    "csllRf"?: TaxByTypeSummaryForService;
    "irrf"?: TaxByTypeSummaryForService;
    "inssRf"?: TaxByTypeSummaryForService;
}

export interface PayRecHeader {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": PayRecHeaderTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code. 'BRL' for Brazilian Reais.
     */
    "currency": PayRecHeaderCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
     */
    "vendorCode": string;
    /**
     * - 'CALCULATE' - 'ASIS' When ASIS, the transaction is stored without executing tax determination (no Calculation). 
     */
    "paymentMode": PayRecHeaderPaymentModeEnum;
}

export type PayRecHeaderTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type PayRecHeaderCurrencyEnum = "BRL";
export type PayRecHeaderPaymentModeEnum = "CALCULATE" | "ASIS";
export interface PayRecLinesIn {
    /**
     * Installment number in this document
     */
    "lineCode"?: number;
    "lineType"?: PayRecLinesInLineTypeEnum;
    /**
     * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
     */
    "itemCode": string;
    /**
     * Free description about this payment
     */
    "itemDescription"?: string;
    /**
     * Installment number, when paid AS IS
     */
    "itemDocNumber"?: string;
    /**
     * Penalty, usually because paid after due date
     */
    "lineUntaxedPenality"?: number;
    /**
     * unconditional discounts
     */
    "lineUntaxedDiscount"?: number;
}

export type PayRecLinesInLineTypeEnum = "installment";
export interface PayRecLinesOut {
    /**
     * Installment number in this document
     */
    "lineCode"?: number;
    "lineType"?: PayRecLinesOutLineTypeEnum;
    /**
     * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
     */
    "itemCode": string;
    /**
     * Free description about this payment
     */
    "itemDescription"?: string;
    /**
     * Installment number, when paid AS IS
     */
    "itemDocNumber"?: string;
    /**
     * Penalty, usually because paid after due date
     */
    "lineUntaxedPenality"?: number;
    /**
     * unconditional discounts
     */
    "lineUntaxedDiscount"?: number;
    /**
     * GrossAmount of this installment line
     */
    "lineAmount"?: number;
    /**
     * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
     */
    "lineNetValue"?: number;
    /**
     * x is because not subject of this tax independent of Threshold
     */
    "withholdingMode"?: WithholdingMode;
    "calculatedTax"?: PaymentCalculatedTax;
}

export type PayRecLinesOutLineTypeEnum = "installment";
export interface Payment {
    /**
     * Installment terms - 0 # cash - 1 # on terms - 2 # other 
     */
    "installmentsTerms"?: number;
    "bill"?: PaymentBill;
    "installment"?: Array<PaymentInstallment>;
    "paymentMode"?: Array<PaymentPaymentMode>;
}

/**
 * Bill information
 */
export interface PaymentBill {
    /**
     * Bill identifier
     */
    "nFat"?: string;
    /**
     * Orignal value
     */
    "vOrig"?: number;
    /**
     * Discount
     */
    "vDiscount"?: number;
    /**
     * Net value
     */
    "vNet"?: number;
}

/**
 * Structure with value for each tax withhold value of this line
 */
export interface PaymentCalculatedTax {
    "taxByType"?: PaymentTaxByType;
    /**
     * Sum of tax type not VAT (Value Added Tax)
     */
    "tax"?: number;
}

export interface PaymentInstallment {
    /**
     * Instalment number identifier
     */
    "documentNumber"?: string;
    /**
     * Installment expiration date
     */
    "date"?: Date;
    /**
     * Installment value
     */
    "grossValue": number;
}

export interface PaymentLinesIn {
    /**
     * Installment number in this document
     */
    "lineCode"?: number;
    "lineType"?: PaymentLinesInLineTypeEnum;
    /**
     * Bill transaction code This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc.
     */
    "itemCode": string;
    /**
     * Free description about this payment
     */
    "itemDescription"?: string;
    /**
     * Installment number, when paid AS IS
     */
    "itemDocNumber"?: string;
    /**
     * Penalty, usually because paid after due date
     */
    "lineUntaxedPenality"?: number;
    /**
     * unconditional discounts
     */
    "lineUntaxedDiscount"?: number;
    /**
     * Net value, the net Value is Gross value plus penalty minus sum of discount and withhold taxes
     */
    "lineNetValue"?: number;
}

export type PaymentLinesInLineTypeEnum = "installment";
export interface PaymentPaymentMode {
    /**
     * Payment mode - '01' # Dinheiro - '02' # Cheque - '03' # Cartão de Crédito - '04' # Cartão de Débito - '05' # Crédito Loja - '10' # Vale Alimentação - '11' # Vale Refeição - '12' # Vale Presente - '13' # Vale Combustível - '99' # Outros 
     */
    "mode": PaymentPaymentModeModeEnum;
    /**
     * payment value
     */
    "value": number;
    /**
     * - '1' # Payment integrated with system, - '2' # Payment not integrated with system 
     */
    "cardTpIntegration"?: PaymentPaymentModeCardTpIntegrationEnum;
    /**
     * Federal tax id of accrediting card (credenciadora do cartão)
     */
    "cardCNPJ"?: string;
    /**
     * card brand - '01' # Visa - '02' # Mastercard - '03' # American Express - '04' # Sorocred - '99' # Other 
     */
    "cardBrand"?: PaymentPaymentModeCardBrandEnum;
    /**
     * transaction authorization number
     */
    "cardAuthorization"?: string;
}

export type PaymentPaymentModeModeEnum = "01" | "02" | "03" | "04" | "05" | "10" | "11" | "12" | "13" | "99";
export type PaymentPaymentModeCardTpIntegrationEnum = "1" | "2";
export type PaymentPaymentModeCardBrandEnum = "01" | "02" | "03" | "04" | "99";
/**
 * Object with summary of all taxes returned by engine
 */
export interface PaymentTaxByType {
    "irrf"?: TaxByTypeTax;
    "inssRf"?: TaxByTypeTax;
    "issRf"?: TaxByTypeTax;
    "pisRf"?: TaxByTypeTax;
    "cofinsRf"?: TaxByTypeTax;
    "csllRf"?: TaxByTypeTax;
}

/**
 * 0 – cash pagamento à vista 1 – on terms, pagamento à prazo; 
 */
export interface PaymentTerms {
}

export interface PaymentTransactionIn {
    "header"?: PayRecHeader;
    "lines"?: Array<PaymentLinesIn>;
}

export interface PaymentTransactionOut {
    "header"?: PayRecHeader;
    "lines"?: Array<PayRecLinesOut>;
    "calculatedTaxSummary"?: PayRecCalculatedTaxSummaryForService;
    "processingInfo"?: ProcessingInfo;
}

export interface PccWithholdingMode {
    /**
     * Inform if this group of tax are calculated considering the threashold by PCC or Individualy (each tax separately)
     */
    "type"?: PccWithholdingModeTypeEnum;
    /**
     * this attribute occurs only for CSRF type, When CRSF mode, this is sum of pisRf, CofinsRf and CsllRf
     */
    "totalTax"?: number;
    "pisRf"?: TaxByTypeTax;
    "cofinsRf"?: TaxByTypeTax;
    "csllRf"?: TaxByTypeTax;
}

export type PccWithholdingModeTypeEnum = "CSRF" | "individual";
/**
 * Address where the service is rendered.
 */
export interface PointOfOrderOrigin {
    "address"?: SimpleAddress;
}

export interface ProcessScenario {
    /**
     * Process code to Identify this configuration, its is unique by Accounty Id or when standard, its has priority when the code match with the standard code.
     */
    "code": string;
    /**
     * Inform that the process has inventory impact.
     */
    "stockImpact"?: boolean;
    /**
     * Inform that the process has financial impact.
     */
    "financialImpact"?: boolean;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: ProcessScenarioCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: ProcessScenarioAccruablePISTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "pisExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "pisExemptLegalReason"?: string;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: ProcessScenarioAccruableCOFINSTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "cofinsExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "cofinsExemptLegalReason"?: string;
    /**
     * Inform that the process allow IPI credit to Input process
     */
    "allowIPIcreditWhenInGoing"?: boolean;
    /**
     * the map key is state code
     */
    "icmsConf"?: Array<IcmsTaxConf>;
    /**
     * Process name to Identify this configuration
     */
    "name": string;
    "type"?: ProcessScenarioTypeEnum;
    /**
     * inform if the transaction is an operation to internalizing (receive) item or value
     */
    "wayType"?: ProcessScenarioWayTypeEnum;
    "goal"?: ProcessScenarioGoalEnum;
    /**
     * inform that the configuration process overwrites the cfop configuration.
     */
    "overWriteCFOP"?: boolean;
    "cfops"?: Array<CfopConf>;
}

export type ProcessScenarioCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type ProcessScenarioAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type ProcessScenarioAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type ProcessScenarioTypeEnum = "SALES" | "PURCHASE" | "SALES_RETURN" | "PURCHASE_RETURN" | "TRANSFER_RETURN" | "SHIPPING" | "SHIPPING_RETURN" | "TRANSFER" | "RECEIPT_AJUSTE" | "TRANSFER_AJUSTE";
export type ProcessScenarioWayTypeEnum = "in" | "out";
export type ProcessScenarioGoalEnum = "Normal" | "Complementary" | "Voided" | "Replacement" | "Return" | "Adjustment";
export interface ProcessingInfo {
    "versionId"?: string;
    "duration"?: number;
}

export interface PurchaseCalculatedTax {
    "taxByType"?: PurchaseTaxByType;
    /**
     * Sum of tax type not VAT (Value Added Tax)
     */
    "tax"?: number;
    "details"?: Array<PurchaseTaxByTypeDetail>;
}

export interface PurchaseCalculatedTaxSummaryForService {
    /**
     * Count of lines
     */
    "numberOfLines"?: number;
    /**
     * sum of all line tax attribute
     */
    "subtotal"?: number;
    /**
     * sum of all line lineAmount attribute
     */
    "totalTax"?: number;
    /**
     * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
     */
    "grandTotal"?: number;
    "taxByType"?: PurchaseCalculatedTaxSummaryForServiceTaxByType;
}

/**
 * Object with summary of all taxes returned by engine
 */
export interface PurchaseCalculatedTaxSummaryForServiceTaxByType {
    "issRf"?: TaxByTypeSummaryForService;
    "pisRf"?: TaxByTypeSummaryForService;
    "cofinsRf"?: TaxByTypeSummaryForService;
    "csllRf"?: TaxByTypeSummaryForService;
    "irrf"?: TaxByTypeSummaryForService;
    "inssRf"?: TaxByTypeSummaryForService;
    "inssAr"?: TaxByTypeSummaryForService;
    "pis"?: TaxByTypeSummaryForService;
    "cofins"?: TaxByTypeSummaryForService;
}

/**
 * This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
 */
export interface PurchaseDefaultLocations {
    "pointOfOrderOrigin"?: PointOfOrderOrigin;
}

export interface PurchaseEntity {
    /**
     * Legal Name of Service buyer.
     */
    "name"?: string;
    "type"?: EntityType;
    /**
     * Entity Email
     */
    "email"?: string;
    /**
     * CNPJ/CPF of Sales Buyer. If CPF, pattern is '[0-9]{11}' if CNPJ, pattern is '[0-9]{14}'
     */
    "cnpjcpf"?: string;
    /**
     * City Tax ID
     */
    "cityTaxId"?: string;
    /**
     * State Tax ID
     */
    "stateTaxId"?: string;
    /**
     * Suframa ID
     */
    "suframa"?: string;
    /**
     * Entity Phone
     */
    "phone"?: string;
    "taxRegime"?: FederalTaxRegime;
    /**
     * Some cities require PURCHASE.Buyers to withhold ISS (City Tax) from PURCHASE.Sellers stablished in different cities. In case the PURCHASE.Seller has acquired a Tax Registration in this destination city, by providing this information in the service invoice, this withholding obligation is lifted.
     */
    "hasCpom"?: boolean;
    /**
     * These are the federal taxes attributes that determine whether withholding of taxes should take place. In special cases where the PURCHASE.Seller is exempt of one or more of these taxes the withholding follows the same rules. The Business type may also dictate these rules as well.
     */
    "subjectWithholdingIrrf"?: boolean;
    /**
     * The INSS contribution is capped at a maximum limit (amount of actual retired payment available in the country).  Individuals sellers subject to INSS withholding can provide the amount already tax by other transactions (with the same buyer or different ones) to deduct to the tax basis. This amount is to be provided to the Seller in a form of a signed document.
     */
    "inssPreviousContrib"?: number;
    /**
     * The INSS contribution is applicable only to the labor amount in a service contract.  There are several items that may be deducted from the service invoice total to arrive at the INSS taxable amount. This amount is to be provided to the Seller in the body of the Invoice or calculated during the transaction input.
     */
    "inssBasisDiscount"?: number;
    /**
     * When Seller is Simples regime, the seller needs send RF rate.
     */
    "issRfRate"?: number;
}

export interface PurchaseHeaderIn {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": PurchaseHeaderInTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code / transactions must be in Brazilian Reais \"BRL\"
     */
    "currency": PurchaseHeaderInCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
     */
    "vendorCode": string;
    /**
     * The number of Purchase Order
     */
    "purchaseOrderNumber"?: string;
    "entity"?: PurchaseEntity;
    "payment"?: PurchaseHeaderInPayment;
    "taxesConfig"?: PurchaseTaxesConfig;
    "defaultLocations"?: PurchaseDefaultLocations;
}

export type PurchaseHeaderInTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type PurchaseHeaderInCurrencyEnum = "BRL";
export interface PurchaseHeaderInPayment {
    "terms"?: PaymentTerms;
    /**
     * installments
     */
    "installments"?: Array<PurchaseInstallmentIn>;
}

export interface PurchaseHeaderOut {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": PurchaseHeaderOutTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code / transactions must be in Brazilian Reais \"BRL\"
     */
    "currency": PurchaseHeaderOutCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of an Account.
     */
    "vendorCode": string;
    /**
     * The number of Purchase Order
     */
    "purchaseOrderNumber"?: string;
    "entity"?: PurchaseEntity;
    "payment"?: PurchaseHeaderOutPayment;
    "taxesConfig"?: PurchaseTaxesConfig;
    "defaultLocations"?: PurchaseDefaultLocations;
}

export type PurchaseHeaderOutTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type PurchaseHeaderOutCurrencyEnum = "BRL";
export interface PurchaseHeaderOutPayment {
    "terms"?: PaymentTerms;
    "withholdingMode"?: WithholdingMode;
    /**
     * installments
     */
    "installments"?: Array<InstallmentComplete>;
}

export interface PurchaseInfo {
    /**
     * Invoice info for government purchase orders Informação da Nota de Empenho de compras públicas 
     */
    "governmentOrder"?: string;
    /**
     * Order info Informação do pedido 
     */
    "orderNumber"?: string;
    /**
     * Agreement info Informação do contrato 
     */
    "contractNumber"?: string;
}

export interface PurchaseInstallmentIn {
    /**
     * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
     */
    "documentNumber": string;
    /**
     * installment, Due Date
     */
    "date": Date;
    /**
     * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
     */
    "grossValue": number;
}

export interface PurchaseLinesIn {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode"?: number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems"?: number;
    /**
     * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
     */
    "lineAmount"?: number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription"?: string;
    /**
     * Conditional discount
     */
    "lineTaxedDiscount"?: number;
    /**
     * Unconditional discount
     */
    "lineUntaxedDiscount"?: number;
    /**
     * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
     */
    "useType"?: PurchaseLinesInUseTypeEnum;
    "taxDeductions"?: SalesLinesOutTaxDeductions;
}

export type PurchaseLinesInUseTypeEnum = "resale" | "production" | "use or consumption" | "fixed assets";
export interface PurchaseLinesOut {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode"?: number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems"?: number;
    /**
     * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
     */
    "lineAmount"?: number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription"?: string;
    /**
     * Conditional discount
     */
    "lineTaxedDiscount"?: number;
    /**
     * Unconditional discount
     */
    "lineUntaxedDiscount"?: number;
    /**
     * Type of entity use associated with this line - 'resale' - 'production' - 'use or consumption' - 'fixed assets' 
     */
    "useType"?: PurchaseLinesOutUseTypeEnum;
    "taxDeductions"?: SalesLinesOutTaxDeductions;
    /**
     * AGAST CODE for itemCode
     */
    "avalaraGoodsAndServicesType"?: string;
    /**
     * This decimal captures the value of lineAmount - lineTaxedDiscount - sum of withholding.
     */
    "lineNetValue"?: number;
    "calculatedTax"?: PurchaseCalculatedTax;
}

export type PurchaseLinesOutUseTypeEnum = "resale" | "production" | "use or consumption" | "fixed assets";
/**
 * Object with summary of all taxes returned by engine
 */
export interface PurchaseTaxByType {
    "issRf"?: TaxByTypeTax;
    "pisRf"?: TaxByTypeTax;
    "cofinsRf"?: TaxByTypeTax;
    "csllRf"?: TaxByTypeTax;
    "irrf"?: TaxByTypeTax;
    "inssRf"?: TaxByTypeTax;
    "inssAr"?: TaxByTypeTax;
    "pis"?: TaxByTypeTax;
    "cofins"?: TaxByTypeTax;
}

export interface PurchaseTaxByTypeDetail {
    /**
     * This string captures the applicable location type. Location used for calc. Buyer or Seller
     */
    "locationType"?: string;
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction - 'city' - 'state' - 'country' 
     */
    "jurisdictionType"?: PurchaseTaxByTypeDetailJurisdictionTypeEnum;
    /**
     * Tax identificator - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inssAr' - 'inssRf' - 'issRf' 
     */
    "taxType"?: PurchaseTaxByTypeDetailTaxTypeEnum;
    /**
     * Name of configuration rate
     */
    "rateType"?: string;
    /**
     * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
     */
    "scenario"?: string;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax, calc base
     */
    "subtotalTaxable"?: number;
    /**
     * This decimal captures how much of the lineAmount was non-taxed. This is simply the line amount minus the taxable.
     */
    "subtotalExempt"?: number;
    /**
     * This decimal captures the tax rate for this tax.3.00 (3%)
     */
    "rate"?: number;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax
     */
    "tax"?: number;
    /**
     * This string is required if is exempt
     */
    "exemptionCode"?: string;
    /**
     * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
     */
    "significantLocations"?: Array<string>;
    /**
     * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
     */
    "taxRuleType"?: PurchaseTaxByTypeDetailTaxRuleTypeEnum;
}

export type PurchaseTaxByTypeDetailJurisdictionTypeEnum = "city" | "state" | "country";
export type PurchaseTaxByTypeDetailTaxTypeEnum = "pis" | "pisRf" | "cofins" | "cofinsRf" | "csll" | "csllRf" | "irrf" | "inssAr" | "inssRf" | "issRf";
export type PurchaseTaxByTypeDetailTaxRuleTypeEnum = "SELLER" | "BUYER" | "TRANSACTION" | "ITEM" | "TAX";
export interface PurchaseTaxesConfig {
    /**
     * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
     */
    "entityAccruableCOFINSTaxation"?: PurchaseTaxesConfigEntityAccruableCOFINSTaxationEnum;
    /**
     * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.   This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
     */
    "entityAccruableCSLLTaxation"?: PurchaseTaxesConfigEntityAccruableCSLLTaxationEnum;
    /**
     * ATTENTION SELLER POINT OF VIEW. There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. T TAXABLE, N NOT TAXABLE, Z TAXABLE WITH RATE=0.00, E EXEMPT, H SUSPENDED, S SPECIFIC RATE - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
     */
    "entityAccruablePISTaxation"?: PurchaseTaxesConfigEntityAccruablePISTaxationEnum;
    /**
     * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
     */
    "accruableCOFINSExempCodeTaxation"?: string;
    /**
     * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption. When not Taxable of Seller point of view this field has the reason code.
     */
    "accruablePISExempCodeTaxation"?: string;
    /**
     * When Code is 999 the user system need send the custom reason to Exemption
     */
    "accruablePISExemptReasonTaxation"?: string;
    /**
     * When Code is 999 the user system need send the custom reason to Exemption
     */
    "accruableCOFINSExemptReasonTaxation"?: string;
    /**
     * CSLL no withholding Custom Reason
     */
    "accruableCSLLExemptReasonTaxation"?: string;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingPIS"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingCOFINS"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingCSLL"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingIRRF"?: boolean;
    /**
     * COFINS no withholding Custom Reason
     */
    "withholdCOFINSExemptReasonTaxation"?: string;
    /**
     * CSLL no withholding Custom Reason
     */
    "withholdCSLLExemptReasonTaxation"?: string;
    /**
     * PIS no withholding Custom Reason
     */
    "withholdPISExemptReasonTaxation"?: string;
}

export type PurchaseTaxesConfigEntityAccruableCOFINSTaxationEnum = "T" | "N" | "Z" | "E" | "H" | "S";
export type PurchaseTaxesConfigEntityAccruableCSLLTaxationEnum = "T" | "E";
export type PurchaseTaxesConfigEntityAccruablePISTaxationEnum = "T" | "N" | "Z" | "E" | "H" | "S";
export interface PurchaseTransactionIn {
    "header": PurchaseHeaderIn;
    "lines": Array<PurchaseLinesIn>;
}

export interface PurchaseTransactionOut {
    "header": PurchaseHeaderOut;
    "lines": Array<PurchaseLinesOut>;
    "calculatedTaxSummary": PurchaseCalculatedTaxSummaryForService;
    "processingInfo": ProcessingInfo;
}

export interface ReceiptTransactionIn {
    "header": PayRecHeader;
    "lines": Array<PaymentLinesIn>;
}

export interface ReceiptTransactionOut {
    "header": PayRecHeader;
    "lines": Array<PayRecLinesOut>;
    "calculatedTaxSummary": PayRecCalculatedTaxSummaryForService;
    "processingInfo": ProcessingInfo;
}

export interface SalesCalculatedTax {
    "taxByType"?: SalesTaxByType;
    /**
     * Sum of tax type not VAT (Value Added Tax)
     */
    "tax"?: number;
    "details"?: Array<SalesTaxByTypeDetail>;
}

export interface SalesCalculatedTaxSummaryForService {
    /**
     * Count of lines
     */
    "numberOfLines"?: number;
    /**
     * sum of all line tax attribute
     */
    "subtotal"?: number;
    /**
     * sum of all line lineAmount attribute
     */
    "totalTax"?: number;
    /**
     * sum of all line lineAmount attribute - sum of all line tax attribute - sum of all line lineTaxedDiscount attribute
     */
    "grandTotal"?: number;
    "taxByType"?: SalesCalculatedTaxSummaryForServiceTaxByType;
}

/**
 * Object with summary of all taxes returned by engine
 */
export interface SalesCalculatedTaxSummaryForServiceTaxByType {
    "pisRf"?: TaxByTypeSummaryForService;
    "cofinsRf"?: TaxByTypeSummaryForService;
    "csllRf"?: TaxByTypeSummaryForService;
    "irrf"?: TaxByTypeSummaryForService;
    "inssRf"?: TaxByTypeSummaryForService;
    "pis"?: TaxByTypeSummaryForService;
    "cofins"?: TaxByTypeSummaryForService;
    "csll"?: TaxByTypeSummaryForService;
    "issRf"?: TaxByTypeSummaryForService;
    "iss"?: TaxByTypeSummaryForService;
    "aproxtribCity"?: TaxByTypeSummaryForService;
    "aproxtribFed"?: TaxByTypeSummaryForService;
    "irpj"?: TaxByTypeSummaryForService;
    "inss"?: TaxByTypeSummaryForService;
}

/**
 * This element contains a dictionary of locations such as the origin and destination addresses to be associated with this transaction. There can only be one location of a given purpose in the dictionary.
 */
export interface SalesDefaultLocations {
    "serviceRendered"?: ServiceRendered;
}

export interface SalesEntity {
    /**
     * SERVICE BUYER NAME OFFICIAL
     */
    "name"?: string;
    "type": EntityType;
    /**
     * Entity Email
     */
    "email"?: string;
    /**
     * CNPJ/CPF of Sales Buyer, if CPF pattern is '[0-9]{11}' if CNPJ pattern is '[0-9]{14}'
     */
    "cnpjcpf"?: string;
    /**
     * City Tax ID
     */
    "cityTaxId"?: string;
    /**
     * State Tax ID
     */
    "stateTaxId"?: string;
    /**
     * Suframa ID
     */
    "suframa"?: string;
    /**
     * Entity Phone
     */
    "phone"?: string;
    "taxRegime": FederalTaxRegime;
    /**
     * Entity Special Tax Regime  - 'MEM' # Microempresa municipal - 'EST' # Estimativa - 'SPR' # Sociedade de profissionais - 'COP' # Cooperativa - 'MEI' # Microempresário Individual (MEI) - 'MPP' # Microempresário e Empresa de Pequeno Porte (ME EPP) 
     */
    "specialTaxRegime"?: SalesEntitySpecialTaxRegimeEnum;
    /**
     * Companies subject to rule follow same rule of Government
     */
    "subjectToSRF1234"?: boolean;
    /**
     * If Withholding ISS is required, independently the rules applied.
     */
    "requiredWithholdingISS"?: boolean;
    /**
     * technical note. Anota\\u00e7\\u00e3o de Responsabilidade T\\u00e9cnica-ART, estabelece que todos os contratos referentes à  execu\\u00e7\\u00e3o de servi\\u00e7os ou obras de Engenharia, Agronomia, Geologia, Geografia ou Meteorologia dever\\u00e3o ser objeto de anota\\u00e7\\u00e3o no Conselho Regional de Engenharia e Agronomia
     */
    "art"?: string;
    /**
     * PROCESS NUMBER TO ISS SUSPENDED FOR ADMINISTRATIVE PROCESS
     */
    "adminProcess"?: string;
    /**
     * Business code. Código da obra OBRA
     */
    "buildCode"?: string;
}

export type SalesEntitySpecialTaxRegimeEnum = "MEM" | "EST" | "SPR" | "COP" | "MEI" | "MPP";
export interface SalesHeaderIn {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": SalesHeaderInTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code / transactions must be in Brazilian Reais \"BRL\"
     */
    "currency": SalesHeaderInCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
    /**
     * This string is a code maintained by the client application and recorded in Customer Portal to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
     */
    "customerCode": string;
    /**
     * The number of Purchase Order
     */
    "purchaseOrderNumber"?: string;
    /**
     * Provisional receipt services, sequencial number maintained by the client application, unique by serie
     */
    "rpsNumber"?: number;
    /**
     * set name identifier for rps number sequency.
     */
    "rpsSerie"?: string;
    /**
     * Service discrimination, free description about service
     */
    "discriminationIn"?: string;
    "entity"?: SalesEntity;
    "payment"?: SalesHeaderInPayment;
    "taxesConfig"?: SalesTaxesConfig;
    "defaultLocations"?: SalesDefaultLocations;
}

export type SalesHeaderInTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type SalesHeaderInCurrencyEnum = "BRL";
export interface SalesHeaderInPayment {
    "terms"?: PaymentTerms;
    /**
     * installments
     */
    "installments"?: Array<SalesInstallmentIn>;
}

export interface SalesHeaderOut {
    /**
     * This string is a UUID issued by Avalara to identify the Avalara account that owns the company identified by the companyCode on the next line.
     */
    "accountId": string;
    /**
     * This string is a code maintained by the client application to uniquely identify the company for which this transaction is being recorded. It is unique within the context of an Account. It will be limited to 60 characters when creating a Company
     */
    "companyCode": string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - 'Sale' - 'Purchase' - 'Payment' - 'Receipt' 
     */
    "transactionType": SalesHeaderOutTransactionTypeEnum;
    /**
     * This string is a code maintained by the client application to uniquely identify a document in the client's systems. It will typically be an invoice number, sales order, receipt number, returned merchandise authorization number, etc. When has this field, the transaction will be stored
     */
    "documentCode"?: string;
    /**
     * currency code / transactions must be in Brazilian Reais \"BRL\"
     */
    "currency": SalesHeaderOutCurrencyEnum;
    /**
     * This string is the transaction date in ISO 8601 format (which may be different from the date the tax calculation is performed)
     */
    "transactionDate": Date;
    /**
     * accrual date, This string is the date, in ISO 8601 format, on which tax is to be calculated for this transaction (normally tax is calculated on the date the transaction is performed as captured in the transactionDate field). This is useful for layaways and other deferred transactions.
     */
    "taxCalculationDate"?: Date;
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation": string;
    /**
     * This string is a code maintained by the client application and recorded in Customer Portal to uniquely identify the party with whom the company (identified by companyCode) is transacting. It is unique within the context of a Company.
     */
    "customerCode": string;
    /**
     * The number of Purchase Order
     */
    "purchaseOrderNumber"?: string;
    /**
     * Provisional receipt services, sequencial number maintained by the client application, unique by serie
     */
    "rpsNumber"?: number;
    /**
     * set name identifier for rps number sequency.
     */
    "rpsSerie"?: string;
    /**
     * Service discrimination, free description about service
     */
    "discriminationIn"?: string;
    "entity"?: SalesEntity;
    "payment"?: SalesHeaderOutPayment;
    "taxesConfig"?: SalesTaxesConfig;
    "defaultLocations"?: SalesDefaultLocations;
    /**
     * Invoice discrimination, it is discriminationIn plus automatic messages
     */
    "discriminationOut"?: string;
    /**
     * RPS XML or NFSe XML generated, when the client system doesn't have EDI with government then BR16 return RPS when transaction is created.
     */
    "xml"?: string;
    /**
     * Service sales usually has a EDI integration with government to get Final document or Authorization. This is external process and the integration status is followed by this property. - 'STORED' - 'WAITING APPROVAL' - 'AUTHORIZED' - 'AUTHORIZED with NOTE' - 'ERROR' - 'CANCELED REPLACED' - 'CANCELED' - 'CANCELLATION REQUESTED' 
     */
    "ediSyncState"?: SalesHeaderOutEdiSyncStateEnum;
}

export type SalesHeaderOutTransactionTypeEnum = "Sale" | "Purchase" | "Payment" | "Receipt";
export type SalesHeaderOutCurrencyEnum = "BRL";
export type SalesHeaderOutEdiSyncStateEnum = "STORED" | "WAITING APPROVAL" | "AUTHORIZED" | "AUTHORIZED with NOTE" | "ERROR" | "CANCELED REPLACED" | "CANCELED" | "CANCELLATION REQUESTED";
export interface SalesHeaderOutPayment {
    "terms"?: PaymentTerms;
    /**
     * To avoid having to verify multiple attributes from a Invoice at the time of funds collection which subject to Tax Withholding, this attribute will allow a referenced Invoice to be quickly checked for withholdings during the cash transaction. This is an SALES.Transaction attribute to be consisted in the Tax Engine that can be used during the receivable process. The values are enumeration where each letter identify if that tax has been withheld PCC,xxx, PCx, PxC ...
     */
    "withholdingMode"?: WithholdingMode;
    /**
     * installments
     */
    "installments"?: Array<InstallmentComplete>;
}

export interface SalesInstallmentIn {
    /**
     * DOCNUMBER, ID OF THIS DOCUMENT FOR THIS transaction
     */
    "documentNumber": string;
    /**
     * installment Due Date
     */
    "date": Date;
    /**
     * Intallment value, fraction of  ∑(lineAmount - lineTaxedDiscount)
     */
    "grossValue": number;
}

export interface SalesLinesIn {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode"?: number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems"?: number;
    /**
     * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
     */
    "lineAmount"?: number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription"?: string;
    /**
     * Conditional discount
     */
    "lineTaxedDiscount"?: number;
    /**
     * Unconditional discount
     */
    "lineUntaxedDiscount"?: number;
    "taxDeductions"?: SalesLinesInTaxDeductions;
}

export interface SalesLinesInTaxDeductions {
    /**
     * Deduction amount not taxable by ISS . Example constructions materials included in a service invoice
     */
    "iss"?: number;
}

export interface SalesLinesOut {
    /**
     * This string is a unique identifier for this line in the transaction
     */
    "lineCode"?: number;
    /**
     * This string is a code maintained by the client application to uniquely identify a product or service. It will likely be a SKU and is required for SST states.
     */
    "itemCode": string;
    /**
     * This decimal captures the number of individual items or units represented by this line. Digits after the decimal point are optional. This should always be positive. Quantity, default 1
     */
    "numberOfItems"?: number;
    /**
     * This decimal captures the total cost of this line. In its simplest form lineAmount = (item price * numberOfItems).
     */
    "lineAmount"?: number;
    /**
     * This string captures the description of the item represented by this line, will be used LC 116
     */
    "itemDescription"?: string;
    /**
     * Conditional discount
     */
    "lineTaxedDiscount"?: number;
    /**
     * Unconditional discount
     */
    "lineUntaxedDiscount"?: number;
    "taxDeductions"?: SalesLinesOutTaxDeductions;
    /**
     * AGAST CODE for itemCode
     */
    "avalaraGoodsAndServicesType"?: string;
    /**
     * This decimal captures the total cost of this line. In its simplest form lineNetValue = (lineAmount - discountTaxable - sum of whithholdings).
     */
    "lineNetValue"?: number;
    /**
     * - '01' # ORIGIN MODE - '02' # ORIGIN MODE BUT EXEMPT - '03' # ORIGIN MODE BUT IMMUNE - '04' # ORIGIN MODE BUT SUSPENDED FOR LEGAL REASON - '05' # ORIGIN MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '21' # DESTINATION MODE - '22' # DESTINATION MODE BUT EXEMPT - '23' # DESTINATION MODE BUT IMMUNE - '24' # DESTINATION MODE BUT SUSPENDED - '25' # DESTINATION MODE BUT SUSPENDED - '40' # FOREIGN IMMUNE MODE 
     */
    "cst"?: SalesLinesOutCstEnum;
    /**
     * - '61' # WITHHOLD NORMAL MODE - '62' # WITHHOLD NORMAL MODE BUT EXEMPT - '63' # WITHHOLD NORMAL MODE BUT IMMUNE - '64' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR LEGAL REASON - '65' # WITHHOLD NORMAL MODE BUT SUSPENDED FOR ADMINISTRATIVE REASON - '66' # WITHHOLD FORCED MODE - '67' # WITHHOLD FORCED MODE BUT EXEMPT - '68' # WITHHOLD FORCED MODE BUT IMMUNE - '69' # WITHHOLD FORCED MODE BUT SUSPENDED FOR LEGAL REASON - '70' # WITHHOLD FORCED MODE BUT SUSPENDED FOR ADMINISTRATIVE PROCESS - '71' # NO WITHHOLD MODE - '72' # NO WITHHOLD FOREIGN MODE 
     */
    "cstRf"?: SalesLinesOutCstRfEnum;
    "calculatedTax"?: SalesCalculatedTax;
}

export type SalesLinesOutCstEnum = "01" | "02" | "03" | "04" | "05" | "21" | "22" | "23" | "24" | "25" | "40";
export type SalesLinesOutCstRfEnum = "61" | "62" | "63" | "64" | "65" | "66" | "67" | "68" | "69" | "70" | "71" | "72";
export interface SalesLinesOutTaxDeductions {
    /**
     * Deduction amount not ISS taxable. Example Building material
     */
    "iss"?: number;
}

/**
 * Object with summary of all taxes returned by engine
 */
export interface SalesTaxByType {
    "pisRf"?: TaxByTypeTax;
    "cofinsRf"?: TaxByTypeTax;
    "csllRf"?: TaxByTypeTax;
    "irrf"?: TaxByTypeTax;
    "inssRf"?: TaxByTypeTax;
    "pis"?: TaxByTypeTax;
    "cofins"?: TaxByTypeTax;
    "csll"?: TaxByTypeTax;
    "issRf"?: TaxByTypeTax;
    "iss"?: TaxByTypeTax;
    "aproxtribCity"?: TaxByTypeTax;
    "aproxtribFed"?: TaxByTypeTax;
    "irpj"?: TaxByTypeTax;
    "inss"?: TaxByTypeTax;
}

export interface SalesTaxByTypeDetail {
    /**
     * This string captures the applicable location type. Location used for calc. Buyer or Seller
     */
    "locationType"?: string;
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction - 'city' - 'state' - 'country' 
     */
    "jurisdictionType"?: SalesTaxByTypeDetailJurisdictionTypeEnum;
    /**
     * Tax identificator - 'aproxtribCity' - 'aproxtribFed' - 'pis' - 'pisRf' - 'cofins' - 'cofinsRf' - 'csll' - 'csllRf' - 'irrf' - 'inss' - 'inssRf' - 'iss' - 'issRf' - 'irpj' 
     */
    "taxType"?: SalesTaxByTypeDetailTaxTypeEnum;
    /**
     * Name of configuration rate
     */
    "rateType"?: string;
    /**
     * This string captures the transaction scenario used to calculate the tax for this tax type. Scenarios are specific to the tax type. This field provides information about how the tax engine interpreted the transaction information that was passed in.
     */
    "scenario"?: string;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax, calc base
     */
    "subtotalTaxable"?: number;
    /**
     * This decimal captures how much of the lineAmount was non-taxed. This is simply the line amount minus the taxable.
     */
    "subtotalExempt"?: number;
    /**
     * This decimal captures the tax rate for this tax.3.00 (3%)
     */
    "rate"?: number;
    /**
     * This decimal captures how much of the lineAmount was taxable by this tax
     */
    "tax"?: number;
    /**
     * This string is required if is exempt
     */
    "exemptionCode"?: string;
    /**
     * This element captures the list of locations that contributed to the tax determination. for BR16 Service is Buyer and Seller Address
     */
    "significantLocations"?: Array<string>;
    /**
     * This string with type of rule - 'SELLER' - 'BUYER' - 'TRANSACTION' - 'ITEM' - 'TAX' 
     */
    "taxRuleType"?: SalesTaxByTypeDetailTaxRuleTypeEnum;
}

export type SalesTaxByTypeDetailJurisdictionTypeEnum = "city" | "state" | "country";
export type SalesTaxByTypeDetailTaxTypeEnum = "aproxtribCity" | "aproxtribFed" | "pis" | "pisRf" | "cofins" | "cofinsRf" | "csll" | "csllRf" | "irrf" | "inss" | "inssRf" | "iss" | "issRf" | "irpj";
export type SalesTaxByTypeDetailTaxRuleTypeEnum = "SELLER" | "BUYER" | "TRANSACTION" | "ITEM" | "TAX";
export interface SalesTaxesConfig {
    /**
     * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings. - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
     */
    "accruableCOFINSTaxation"?: SalesTaxesConfigAccruableCOFINSTaxationEnum;
    /**
     * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be CSLL exempt.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - T TAXABLE - E EXEMPT 
     */
    "accruableCSLLTaxation"?: SalesTaxesConfigAccruableCSLLTaxationEnum;
    /**
     * There are cases where both Seller, Buyer and items are taxable but a special situation still exists that forces the transaction to be exempt specially for PIS and COFINS.  This attribute will allow users to identify such scenarios and trigger the exemption in spite of all other settings.  - 'T' # TAXABLE - 'N' # NOT TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'S' # SPECIFIC RATE 
     */
    "accruablePISTaxation"?: SalesTaxesConfigAccruablePISTaxationEnum;
    /**
     * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
     */
    "accruableCOFINSExempCodeTaxation"?: string;
    /**
     * This is a code available by Receita Federal for reason of the exemption, When Code is 999 the User system need send the custom reason to Exemption
     */
    "accruablePISExempCodeTaxation"?: string;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingCOFINS"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingCSLL"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingIRRF"?: boolean;
    /**
     * Support Buyer Tax Liability identifier for Federal Withholding Taxes. Each buyer may be subject/liable to withhold the following taxes independent to one another. The seller must be able to inform which Tax impacts the transaction based on a direct equivalency in the service item accrual. i.e. (The service item must be taxed by a given tax and the buyer must liable for the same tax withholding in order for the transaction to be taxable). To differentiate from the accrued taxes under the same acronyms the withholding taxes are followed by WH (this is a convention created for the sake of understanding and communicating the requirements. If false spite of all other settings.
     */
    "withholdingPIS"?: boolean;
    /**
     * When property withholdingIRRF is false is mandatory inform the reason
     */
    "withholdIRRFExemptReasonTaxation"?: string;
}

export type SalesTaxesConfigAccruableCOFINSTaxationEnum = "T" | "N" | "Z" | "E" | "H" | "S";
export type SalesTaxesConfigAccruableCSLLTaxationEnum = "T" | "E";
export type SalesTaxesConfigAccruablePISTaxationEnum = "T" | "N" | "Z" | "E" | "H" | "S";
export interface SalesTransactionIn {
    "header": SalesHeaderIn;
    "lines": Array<SalesLinesIn>;
}

export interface SalesTransactionOut {
    "header": SalesHeaderOut;
    "lines": Array<SalesLinesOut>;
    "calculatedTaxSummary": SalesCalculatedTaxSummaryForService;
    "processingInfo": ProcessingInfo;
}

export interface SefazDisableRangeIn {
    /**
     * This string contains a previously configured company code which may also have codes needed for tax return purposes. These codes are maintained through the customer portal. Main company address identity
     */
    "companyLocation"?: string;
    /**
     * This string indicates the type of transaction for which tax should be calculated. - '55' # Nota Fiscal Eletrônica (NF-e) - '65' # Nota Fiscal Eletrônica ao-Consumidor Final (NFC-e) 
     */
    "transactionModel"?: SefazDisableRangeInTransactionModelEnum;
    /**
     * Invoice number, sequential unique by invoice serial (Número da nota fiscal) 
     */
    "invoiceSerial"?: number;
    "year"?: number;
    "message"?: string;
    /**
     * First number of disable range.
     */
    "invoiceNumberInit"?: number;
    /**
     * Last number of disable range.
     */
    "invoiceNumberEnd"?: number;
}

export type SefazDisableRangeInTransactionModelEnum = "55" | "65";
export interface SefazInvoiceBasicStatus {
    "code"?: string;
    "desc"?: string;
}

export interface SefazInvoiceStatus {
    "code"?: string;
    "desc"?: string;
    "protocol"?: string;
    "rec"?: string;
    "date"?: Date;
    /**
     * - '1' # Ambiente de Produção - '2' # Ambiente de Homologação 
     */
    "environment"?: SefazInvoiceStatusEnvironmentEnum;
    "appVersion"?: string;
}

export type SefazInvoiceStatusEnvironmentEnum = "1" | "2";
export interface SefazItDeleteIn {
    "message"?: string;
}

export interface SefazItGetOut {
    /**
     * Invoice Access Key
     */
    "key"?: string;
    /**
     * XML Signed
     */
    "xml"?: string;
    "status"?: SefazInvoiceStatus;
}

export interface SefazItPutIn {
    "code"?: string;
    "text"?: string;
}

export interface SefazPostOut {
    "key"?: string;
    "documentCode"?: string;
    "status"?: SefazInvoiceStatus;
}

export interface ServiceItemTaxRate {
    "taxType"?: string;
    "rateType"?: string;
    "rate"?: number;
    "isExempt"?: boolean;
    "discount"?: number;
    "zone1"?: number;
    "zone2"?: number;
    "period"?: ServiceItemTaxRatePeriod;
    "reason"?: string;
    "message"?: string;
}

export interface ServiceItemTaxRatePeriod {
    "startDate"?: Date;
    "expirationDate"?: Date;
}

/**
 * Address where the rendered service.
 */
export interface ServiceRendered {
    "address"?: SimpleAddress;
}

export interface SimpleAddress {
    /**
     * Address
     */
    "line1": string;
    /**
     * Number
     */
    "line2": string;
    /**
     * District
     */
    "line3": string;
    "city"?: string;
    /**
     * Brazilian Zip Code
     */
    "zipcode": string;
    "state"?: StateEnum;
    /**
     * Use ISO 3166-1 alpha-3 codes
     */
    "country": string;
}

/**
 * State Abreviation: - 'AC' - 'AL' - 'AP' - 'AM' - 'BA' - 'CE' - 'DF' - 'ES' - 'GO' - 'MA' - 'MT' - 'MS' - 'MG' - 'PA' - 'PB' - 'PR' - 'PE' - 'PI' - 'RJ' - 'RN' - 'RS' - 'RO' - 'RR' - 'SC' - 'SP' - 'SE' - 'TO' 
 */
export interface StateEnum {
}

export interface StateTransition {
    /**
     * - 'voided' - 'unvoided' - 'reconciled' - 'unreconciled' - 'filed' - 'unfiled' - 'filedByAvalara' 
     */
    "type": StateTransitionTypeEnum;
    "comment"?: string;
}

export type StateTransitionTypeEnum = "voided" | "unvoided" | "reconciled" | "unreconciled" | "filed" | "unfiled" | "filedByAvalara";
/**
 * summary of all taxes
 */
export interface TaxByTypeSummaryForGoods {
    /**
     * sum of all lines calcbase
     */
    "calcbase"?: number;
    /**
     * sum of referenced tax value
     */
    "tax"?: number;
    "jurisdictions"?: Array<TaxByTypeSummaryJurisdictionForGoods>;
}

/**
 * summary of all taxes
 */
export interface TaxByTypeSummaryForService {
    /**
     * sum of referenced tax value
     */
    "tax"?: number;
    "jurisdictions"?: Array<TaxByTypeSummaryJurisdiction>;
}

export interface TaxByTypeSummaryJurisdiction {
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction - 'City' - 'State' - 'Country' 
     */
    "jurisdictionType"?: TaxByTypeSummaryJurisdictionJurisdictionTypeEnum;
    /**
     * sum of referenced tax value by jurisdiction
     */
    "tax"?: number;
}

export type TaxByTypeSummaryJurisdictionJurisdictionTypeEnum = "City" | "State" | "Country";
export interface TaxByTypeSummaryJurisdictionForGoods {
    /**
     * Jurisdiction used for calctax amount
     */
    "jurisdictionName"?: string;
    /**
     * Type of jurisdiction
     */
    "jurisdictionType"?: TaxByTypeSummaryJurisdictionForGoodsJurisdictionTypeEnum;
    /**
     * sum of referenced tax value by jurisdiction
     */
    "tax"?: number;
}

export type TaxByTypeSummaryJurisdictionForGoodsJurisdictionTypeEnum = "City" | "State" | "Country";
export interface TaxByTypeTax {
    /**
     * Tax value, negative value for withhold value
     */
    "tax": number;
}

export interface TaxConf {
    /**
     * main unique identificator
     */
    "code": string;
    /**
     * Inform that the process has inventory impact.
     */
    "stockImpact"?: boolean;
    /**
     * Inform that the process has financial impact.
     */
    "financialImpact"?: boolean;
    /**
     * Inform if this process is subject to IPI taxation on output process - '50' # Saída Tributada - '51' # Saída Tributável com Alíquota Zero - '52' # Saída Isenta - '53' # Saída Não-Tributada - '54' # Saída Imune 
     */
    "cstIPI"?: TaxConfCstIPIEnum;
    /**
     * Legal tax classificação for IPI (enquadramento) When the processo has CST IPI 52 or 54, is mandatory inform Reason Code, see Anexo XIV - Código de Enquadramento Legal do IPI from  http://www.nfe.fazenda.gov.br/portal/exibirArquivo.aspx?conteudo=mCnJajU4BKU= 
     */
    "ipiLegalTaxClass"?: string;
    /**
     * Inform if this item by nature is subject to PIS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruablePISTaxation"?: TaxConfAccruablePISTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "pisExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "pisExemptLegalReason"?: string;
    /**
     * Inform if this item by nature is subject to COFINS taxation or exempt - 'T' # TAXABLE - 'Z' # TAXABLE WITH RATE=0.00 - 'E' # EXEMPT - 'H' # SUSPENDED - 'N' # NO TAXABLE 
     */
    "accruableCOFINSTaxation"?: TaxConfAccruableCOFINSTaxationEnum;
    /**
     * When exempt, taxable with zero, suspended, not taxable, this field holds the official code number
     */
    "cofinsExemptLegalReasonCode"?: string;
    /**
     * When specifi reason, this field has the description
     */
    "cofinsExemptLegalReason"?: string;
    /**
     * Inform that the process allow IPI credit to Input process
     */
    "allowIPIcreditWhenInGoing"?: boolean;
    /**
     * the map key is state code
     */
    "icmsConf"?: Array<IcmsTaxConf>;
}

export type TaxConfCstIPIEnum = "50" | "51" | "52" | "53" | "54";
export type TaxConfAccruablePISTaxationEnum = "T" | "Z" | "E" | "H" | "N";
export type TaxConfAccruableCOFINSTaxationEnum = "T" | "Z" | "E" | "H" | "N";
/**
 * Tax Rate
 */
export interface TaxType {
}

export interface TaxTypeRate {
    "taxType": TaxType;
    /**
     * Tax can be calculated by rate or by quantity
     */
    "taxModel": TaxTypeRateTaxModelEnum;
    /**
     * Specific tax rate ex 3.5 (3.5%)
     */
    "rate"?: number;
    /**
     * Specific tax rate ex 3.5 (3.5%)
     */
    "srvAmount"?: number;
    "quantityUnidBase"?: string;
    "specializationType"?: TaxTypeRateSpecializationTypeEnum;
    /**
     * UUID Reference to an item in the LegalReason store. 
     */
    "exemptionReasonCode"?: string;
    /**
     * Optional textual reason description, to be used when reason codes are generic (i.e. reason code 999 = Other). 
     */
    "customExemptionReasonDescription"?: string;
    "withholding"?: TaxTypeRateWithholding;
}

export type TaxTypeRateTaxModelEnum = "rate" | "srf";
export type TaxTypeRateSpecializationTypeEnum = "basic" | "monophase" | "taxSubstitution";
/**
 * Assign an empty object for simple withholding, null (no key) for no withholding. Detailed behaviors for specific targets may be set by using the available optional keys. 
 */
export interface TaxTypeRateWithholding {
    "all"?: WithholdDef;
    "business"?: WithholdDef;
    "federalGovernment"?: WithholdDef;
    "stateGovernment"?: WithholdDef;
    "cityGovernment"?: WithholdDef;
}

export interface TransactionForGoodsIn {
    "header"?: HeaderForGoods;
    "lines"?: Array<LineForGoods>;
}

export interface TransactionForGoodsOut {
    "header"?: HeaderForGoods;
    "lines"?: Array<LineForGoods>;
    "calculatedTaxSummary"?: CalculatedTaxSummaryForGoods;
    "processingInfo"?: ProcessingInfo;
}

export interface TransactionForSefazGoods {
    "header"?: HeaderForGoods;
    "lines"?: Array<LineForSefazGoods>;
    "calculatedTaxSummary"?: CalculatedTaxSummaryForGoods;
}

export interface TransactionForSefazGoodsList extends Array<TransactionForSefazGoods> {
}

export interface Transport {
    /**
     * Freight model  - 0 - CIF,  - 1 - FOB,  - 2 - Thrid party, - 9 - Free shipping when 9 - Free shipping, the fields below will be ignored if present - 'transporter' - 'withholdICMSTransport' - 'volumes' - 'vehicle' 
     */
    "modFreight": TransportModFreightEnum;
    /**
     * Forces witholding of ICMS on transport amount (freight)
     */
    "withholdICMSTransport"?: boolean;
    /**
     * Packages
     */
    "volumes"?: Array<TransportVolumes>;
    "vehicle"?: VehicleTransp;
}

export type TransportModFreightEnum = "CIF" | "FOB" | "Thridparty" | "FreeShipping";
export interface TransportVolumes {
    /**
     * Quantity of packages transported
     */
    "qVol"?: string;
    /**
     * package type
     */
    "specie"?: string;
    /**
     * brand
     */
    "brand"?: string;
    /**
     * packages numeration
     */
    "volumeNumeration"?: string;
    /**
     * net weight using Kg
     */
    "netWeight"?: number;
    /**
     * gross weight using Kg
     */
    "grossWeight"?: number;
    "seal"?: Array<string>;
}

export interface ValidationError {
    "message"?: string;
    "errors"?: Array<ModelError>;
}

export interface Vehicle {
    /**
     * - 1 # Sales by car dealership - 2 # Direct billing - 3 # Direct sales - 0 # Other 
     */
    "tpOp": number;
    "chassisNumber": string;
    /**
     * color code used by factory
     */
    "colorCode": string;
    /**
     * color name
     */
    "colorName": string;
    /**
     * Power using CV unid
     */
    "cvPower": string;
    /**
     * engine size in cubic centimeters
     */
    "cylinderVolumCC": string;
    /**
     * net weight
     */
    "netWeight": string;
    /**
     * gross weight
     */
    "grossWeight": string;
    /**
     * serie
     */
    "serialNumber": string;
    /**
     * - '01' # Alcohol - '02' # Gas - '03' # Diesel - '16' # Alcohol/Gas - '17' # Gas/Alcohol/GNV - '18' # Gas/Electric 
     */
    "fuelType": VehicleFuelTypeEnum;
    /**
     * engine number
     */
    "engineNumber": string;
    /**
     * traction capacity, tonne
     */
    "cmt": string;
    /**
     * length between axis
     */
    "lengthBetweenAxis": string;
    /**
     * model year
     */
    "modelYear": string;
    /**
     * year of factory
     */
    "manufactoryYear": string;
    /**
     * paynt type
     */
    "paintType": string;
    "vehicleRENAVAMType": string;
    "specieRENAVAMType": string;
    "modelRENAVAMCode": string;
    /**
     * - '01' # YELLOW - '02' # BLUE - '03' # BEIGE - '04' # WHITE - '05' # GRAY - '06' # GOLDEN - '07' # GRENA - '08' # ORANGE - '09' # BROWN - '10' # SILVER - '11' # BLACK - '12' # PINK - '13' # PURPLE - '14' # GREEN - '15' # RED - '16' # FANTASY 
     */
    "colorDENATRANCode": VehicleColorDENATRANCodeEnum;
    /**
     * chassis condition original or modified (remarcado)
     */
    "vin": VehicleVinEnum;
    /**
     * - '1' # Finished(Done) - '2' # Not finished - '3' # Semi-finished 
     */
    "vehicleManufactoryStatus": VehicleVehicleManufactoryStatusEnum;
    /**
     * max number of sit occupants
     */
    "maxOccupantsQuantity": string;
    /**
     * Lien/restriction type - '0' # No one; - '1' # Alienação Fiduciária; - '2' # Arrendamento Mercantil; - '3' # Reserva de Domínio; - '4' # Penhor de Veículos; - '9' # Other. 
     */
    "restrictionType": VehicleRestrictionTypeEnum;
}

export type VehicleFuelTypeEnum = "01" | "02" | "03" | "16" | "17" | "18";
export type VehicleColorDENATRANCodeEnum = "01" | "02" | "03" | "04" | "05" | "06" | "07" | "08" | "09" | "10" | "11" | "12" | "13" | "14" | "15" | "16";
export type VehicleVinEnum = "R" | "N";
export type VehicleVehicleManufactoryStatusEnum = "1" | "2" | "3";
export type VehicleRestrictionTypeEnum = "0" | "1" | "2" | "3" | "4" | "9";
export interface VehicleID {
    "licensePlate": string;
    "stateCode": StateEnum;
    /**
     * Cargo Transport National Register, Registro Nacional de Transportador de Carga (ANTT)
     */
    "rtnc"?: string;
}

/**
 * Identify type of vehicle used to transport the attributes, except atribute type,  follow rule allOf then only one of this atributes will be informed. 
 */
export interface VehicleTransp {
    "type"?: VehicleTranspTypeEnum;
    "automobile"?: VehicleID;
    /**
     * Trailer
     */
    "trailer"?: Array<VehicleID>;
    "wagon"?: string;
    /**
     * Ferry
     */
    "ferry"?: string;
}

export type VehicleTranspTypeEnum = "automobile" | "wagon" | "ferry" | "trailer";
export interface Weapon {
    /**
     * - '0' # restrict use - '1' # public use 
     */
    "weaponRestrictionType": WeaponWeaponRestrictionTypeEnum;
    "serieNumber": string;
    /**
     * Barrel's serial number. Número de série do cano 
     */
    "gunBarrelSerieNumber": string;
    /**
     * weapon description
     */
    "weaponDescription": string;
}

export type WeaponWeaponRestrictionTypeEnum = "0" | "1";
export interface WithholdDef {
    /**
     * UUID Reference to an item in the LegalReason store.
     */
    "exemptionReasonCode"?: string;
    "customExemptionReasonDescription"?: string;
}

/**
 * Using the placing reference in PCC for PIS (P), COFINS (C) and COFINS (C).  x = tax is not subject to withholding.  - 'xxx' - 'PCC' - 'PCx' - 'PxC' - 'Pxx' - 'xCC' - 'xxC' - 'xCx' 
 */
export interface WithholdingMode {
}



/**
 * AGASTApi - fetch parameter creator
 */
export const AGASTApiFetchParamCreator = {
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param code Agast Code
     */
    agastsCodeGet(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling agastsCodeGet");
        }
        const baseUrl = `/agasts/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create agast
     * This method operation create a AGAST 
     * @param body Transaction Message
     */
    createAgast(params: {  "body": Agast; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createAgast");
        }
        const baseUrl = `/agasts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param code Agast Code
     */
    deleteAgast(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteAgast");
        }
        const baseUrl = `/agasts/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param text Text query
     */
    getAgastList(params: {  "text"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/agasts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "text": params["text"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update agast
     * This method operation create a agast 
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateAgast(params: {  "code": string; "body": Agast; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateAgast");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateAgast");
        }
        const baseUrl = `/agasts/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AGASTApi - functional programming interface
 */
export const AGASTApiFp = {
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param code Agast Code
     */
    agastsCodeGet(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Agast> {
        const fetchArgs = AGASTApiFetchParamCreator.agastsCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create agast
     * This method operation create a AGAST 
     * @param body Transaction Message
     */
    createAgast(params: { "body": Agast;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = AGASTApiFetchParamCreator.createAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param code Agast Code
     */
    deleteAgast(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AGASTApiFetchParamCreator.deleteAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param text Text query
     */
    getAgastList(params: { "text"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
        const fetchArgs = AGASTApiFetchParamCreator.getAgastList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update agast
     * This method operation create a agast 
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateAgast(params: { "code": string; "body": Agast;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AGASTApiFetchParamCreator.updateAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AGASTApi - object-oriented interface
 */
export class AGASTApi extends BaseAPI {
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param code Agast Code
     */
    agastsCodeGet(params: {  "code": string; }, options?: any) {
        return AGASTApiFp.agastsCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create agast
     * This method operation create a AGAST 
     * @param body Transaction Message
     */
    createAgast(params: {  "body": Agast; }, options?: any) {
        return AGASTApiFp.createAgast(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param code Agast Code
     */
    deleteAgast(params: {  "code": string; }, options?: any) {
        return AGASTApiFp.deleteAgast(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return agast configurations that match with parameters queries 
     * @param text Text query
     */
    getAgastList(params: {  "text"?: string; }, options?: any) {
        return AGASTApiFp.getAgastList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update agast
     * This method operation create a agast 
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateAgast(params: {  "code": string; "body": Agast; }, options?: any) {
        return AGASTApiFp.updateAgast(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AGASTApi - factory interface
 */
export const AGASTApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return agast configurations that match with parameters queries 
         * @param code Agast Code
         */
        agastsCodeGet(params: {  "code": string; }, options?: any) {
            return AGASTApiFp.agastsCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * Create agast
         * This method operation create a AGAST 
         * @param body Transaction Message
         */
        createAgast(params: {  "body": Agast; }, options?: any) {
            return AGASTApiFp.createAgast(params, options)(fetch, basePath);
        },
        /** 
         * @param code Agast Code
         */
        deleteAgast(params: {  "code": string; }, options?: any) {
            return AGASTApiFp.deleteAgast(params, options)(fetch, basePath);
        },
        /** 
         * This operation return agast configurations that match with parameters queries 
         * @param text Text query
         */
        getAgastList(params: {  "text"?: string; }, options?: any) {
            return AGASTApiFp.getAgastList(params, options)(fetch, basePath);
        },
        /** 
         * Update agast
         * This method operation create a agast 
         * @param code Agast Code
         * @param body Transaction Message
         */
        updateAgast(params: {  "code": string; "body": Agast; }, options?: any) {
            return AGASTApiFp.updateAgast(params, options)(fetch, basePath);
        },
    };
};


/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param accountId Account ID
     */
    accountsAccountIdCompaniesGet(params: {  "accountId": string; }, options?: any): FetchArgs {
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling accountsAccountIdCompaniesGet");
        }
        const baseUrl = `/accounts/{accountId}/companies`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param accountId Account ID
     * @param body Company Code
     */
    createAccountCompany(params: {  "accountId": string; "body": Body; }, options?: any): FetchArgs {
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling createAccountCompany");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createAccountCompany");
        }
        const baseUrl = `/accounts/{accountId}/companies`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param accountId Account ID
     */
    accountsAccountIdCompaniesGet(params: { "accountId": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<AccountCompany>> {
        const fetchArgs = AccountApiFetchParamCreator.accountsAccountIdCompaniesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param accountId Account ID
     * @param body Company Code
     */
    createAccountCompany(params: { "accountId": string; "body": Body;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = AccountApiFetchParamCreator.createAccountCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     * @param accountId Account ID
     */
    accountsAccountIdCompaniesGet(params: {  "accountId": string; }, options?: any) {
        return AccountApiFp.accountsAccountIdCompaniesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param accountId Account ID
     * @param body Company Code
     */
    createAccountCompany(params: {  "accountId": string; "body": Body; }, options?: any) {
        return AccountApiFp.createAccountCompany(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve Companies by account
         * Retrieve list companies of one account
         * @param accountId Account ID
         */
        accountsAccountIdCompaniesGet(params: {  "accountId": string; }, options?: any) {
            return AccountApiFp.accountsAccountIdCompaniesGet(params, options)(fetch, basePath);
        },
        /** 
         * Create company and your data configuration
         * This method operation create a company for a account 
         * @param accountId Account ID
         * @param body Company Code
         */
        createAccountCompany(params: {  "accountId": string; "body": Body; }, options?: any) {
            return AccountApiFp.createAccountCompany(params, options)(fetch, basePath);
        },
    };
};


/**
 * AddressApi - fetch parameter creator
 */
export const AddressApiFetchParamCreator = {
    /** 
     * This operation return address
     * @param zipcode ZIP Code
     */
    getZipCode(params: {  "zipcode": string; }, options?: any): FetchArgs {
        // verify required parameter "zipcode" is set
        if (params["zipcode"] == null) {
            throw new Error("Missing required parameter zipcode when calling getZipCode");
        }
        const baseUrl = `/addresses/{zipcode}`
            .replace(`{${"zipcode"}}`, `${ params["zipcode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AddressApi - functional programming interface
 */
export const AddressApiFp = {
    /** 
     * This operation return address
     * @param zipcode ZIP Code
     */
    getZipCode(params: { "zipcode": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<Address>> {
        const fetchArgs = AddressApiFetchParamCreator.getZipCode(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AddressApi - object-oriented interface
 */
export class AddressApi extends BaseAPI {
    /** 
     * This operation return address
     * @param zipcode ZIP Code
     */
    getZipCode(params: {  "zipcode": string; }, options?: any) {
        return AddressApiFp.getZipCode(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AddressApi - factory interface
 */
export const AddressApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return address
         * @param zipcode ZIP Code
         */
        getZipCode(params: {  "zipcode": string; }, options?: any) {
            return AddressApiFp.getZipCode(params, options)(fetch, basePath);
        },
    };
};


/**
 * AuthApi - fetch parameter creator
 */
export const AuthApiFetchParamCreator = {
    /** 
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Authorization: Basic VGVzdDoxMjM&#x3D; 
     */
    authPost(params: {  "authorization": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling authPost");
        }
        const baseUrl = `/auth`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = {
    /** 
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Authorization: Basic VGVzdDoxMjM&#x3D; 
     */
    authPost(params: { "authorization": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = AuthApiFetchParamCreator.authPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /** 
     * authorization
     * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
     * @param authorization Authorization: Basic VGVzdDoxMjM&#x3D; 
     */
    authPost(params: {  "authorization": string; }, options?: any) {
        return AuthApiFp.authPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * authorization
         * Authorization: Basic VGVzdDoxMjM&#x3D;  Generate Base64:  - auth &#x3D; \&quot;{user}:{password}\&quot;  - base &#x3D; base64(auth)  - header[\&quot;Authorization\&quot;] &#x3D; \&quot;Basic \&quot; + base 
         * @param authorization Authorization: Basic VGVzdDoxMjM&#x3D; 
         */
        authPost(params: {  "authorization": string; }, options?: any) {
            return AuthApiFp.authPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyApi - fetch parameter creator
 */
export const CompanyApiFetchParamCreator = {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     */
    companiesGet(options?: any): FetchArgs {
        const baseUrl = `/companies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param body Transaction Message
     */
    createCompany(params: {  "body": Company; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createCompany");
        }
        const baseUrl = `/companies`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param accountId Account ID
     * @param companyId Company ID
     */
    deleteAccountCompany(params: {  "accountId": string; "companyId": string; }, options?: any): FetchArgs {
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling deleteAccountCompany");
        }
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteAccountCompany");
        }
        const baseUrl = `/accounts/{accountId}/companies/{companyId}`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    deleteCompany(params: {  "companyId": string; "companyId2": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteCompany");
        }
        // verify required parameter "companyId2" is set
        if (params["companyId2"] == null) {
            throw new Error("Missing required parameter companyId2 when calling deleteCompany");
        }
        const baseUrl = `/companies/{companyId}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"companyId"}}`, `${ params["companyId2"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get company information and your data configuration
     * This method operation get a company for a account 
     * @param companyId Company ID
     */
    infoCompany(params: {  "companyId": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling infoCompany");
        }
        const baseUrl = `/companies/{companyId}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update company information and your data configuration
     * This method operation create a company for a account 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    updateCompany(params: {  "companyId": string; "body": Company; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateCompany");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateCompany");
        }
        const baseUrl = `/companies/{companyId}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyApi - functional programming interface
 */
export const CompanyApiFp = {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     */
    companiesGet(options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<Company>> {
        const fetchArgs = CompanyApiFetchParamCreator.companiesGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param body Transaction Message
     */
    createCompany(params: { "body": Company;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.createCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param accountId Account ID
     * @param companyId Company ID
     */
    deleteAccountCompany(params: { "accountId": string; "companyId": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.deleteAccountCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    deleteCompany(params: { "companyId": string; "companyId2": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.deleteCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get company information and your data configuration
     * This method operation get a company for a account 
     * @param companyId Company ID
     */
    infoCompany(params: { "companyId": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Company> {
        const fetchArgs = CompanyApiFetchParamCreator.infoCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update company information and your data configuration
     * This method operation create a company for a account 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    updateCompany(params: { "companyId": string; "body": Company;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyApiFetchParamCreator.updateCompany(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyApi - object-oriented interface
 */
export class CompanyApi extends BaseAPI {
    /** 
     * Retrieve Companies by account
     * Retrieve list companies of one account
     */
    companiesGet(options?: any) {
        return CompanyApiFp.companiesGet(options)(this.fetch, this.basePath);
    }
    /** 
     * Create company and your data configuration
     * This method operation create a company for a account 
     * @param body Transaction Message
     */
    createCompany(params: {  "body": Company; }, options?: any) {
        return CompanyApiFp.createCompany(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param accountId Account ID
     * @param companyId Company ID
     */
    deleteAccountCompany(params: {  "accountId": string; "companyId": string; }, options?: any) {
        return CompanyApiFp.deleteAccountCompany(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    deleteCompany(params: {  "companyId": string; "companyId2": string; }, options?: any) {
        return CompanyApiFp.deleteCompany(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get company information and your data configuration
     * This method operation get a company for a account 
     * @param companyId Company ID
     */
    infoCompany(params: {  "companyId": string; }, options?: any) {
        return CompanyApiFp.infoCompany(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update company information and your data configuration
     * This method operation create a company for a account 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    updateCompany(params: {  "companyId": string; "body": Company; }, options?: any) {
        return CompanyApiFp.updateCompany(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyApi - factory interface
 */
export const CompanyApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve Companies by account
         * Retrieve list companies of one account
         */
        companiesGet(options?: any) {
            return CompanyApiFp.companiesGet(options)(fetch, basePath);
        },
        /** 
         * Create company and your data configuration
         * This method operation create a company for a account 
         * @param body Transaction Message
         */
        createCompany(params: {  "body": Company; }, options?: any) {
            return CompanyApiFp.createCompany(params, options)(fetch, basePath);
        },
        /** 
         * @param accountId Account ID
         * @param companyId Company ID
         */
        deleteAccountCompany(params: {  "accountId": string; "companyId": string; }, options?: any) {
            return CompanyApiFp.deleteAccountCompany(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param companyId2 Company ID
         */
        deleteCompany(params: {  "companyId": string; "companyId2": string; }, options?: any) {
            return CompanyApiFp.deleteCompany(params, options)(fetch, basePath);
        },
        /** 
         * Get company information and your data configuration
         * This method operation get a company for a account 
         * @param companyId Company ID
         */
        infoCompany(params: {  "companyId": string; }, options?: any) {
            return CompanyApiFp.infoCompany(params, options)(fetch, basePath);
        },
        /** 
         * Update company information and your data configuration
         * This method operation create a company for a account 
         * @param companyId Company ID
         * @param body Transaction Message
         */
        updateCompany(params: {  "companyId": string; "body": Company; }, options?: any) {
            return CompanyApiFp.updateCompany(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyAGASTApi - fetch parameter creator
 */
export const CompanyAGASTApiFetchParamCreator = {
    /** 
     * This operation return custom agast configurations that match with parameters queries - Alannes. 
     * @param companyId Company ID
     * @param code Agast Code
     * @param parent Agast parent code, means that this agast is a specialization of parent agast 
     */
    companiesCompanyIdAgastsCodeGet(params: {  "companyId": string; "code": string; "parent"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdAgastsCodeGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdAgastsCodeGet");
        }
        const baseUrl = `/companies/{companyId}/agasts/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "parent": params["parent"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param agast Custom Agast Code
     * @param parent Agast Code
     */
    companiesCompanyIdAgastsGet(params: {  "companyId": string; "text"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "agast"?: string; "parent"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdAgastsGet");
        }
        const baseUrl = `/companies/{companyId}/agasts`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "text": params["text"],
            "agast": params["agast"],
            "parent": params["parent"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    createCustomAgast(params: {  "companyId": string; "body": CustomAgast; "text"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createCustomAgast");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createCustomAgast");
        }
        const baseUrl = `/companies/{companyId}/agasts`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "text": params["text"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Agast Code
     */
    deleteAgast(params: {  "companyId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteAgast");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteAgast");
        }
        const baseUrl = `/companies/{companyId}/agasts/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateCustomAgast(params: {  "companyId": string; "code": string; "body": CustomAgast; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateCustomAgast");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCustomAgast");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateCustomAgast");
        }
        const baseUrl = `/companies/{companyId}/agasts/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyAGASTApi - functional programming interface
 */
export const CompanyAGASTApiFp = {
    /** 
     * This operation return custom agast configurations that match with parameters queries - Alannes. 
     * @param companyId Company ID
     * @param code Agast Code
     * @param parent Agast parent code, means that this agast is a specialization of parent agast 
     */
    companiesCompanyIdAgastsCodeGet(params: { "companyId": string; "code": string; "parent"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<CustomAgast> {
        const fetchArgs = CompanyAGASTApiFetchParamCreator.companiesCompanyIdAgastsCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param agast Custom Agast Code
     * @param parent Agast Code
     */
    companiesCompanyIdAgastsGet(params: { "companyId": string; "text"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "agast"?: string; "parent"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2001>> {
        const fetchArgs = CompanyAGASTApiFetchParamCreator.companiesCompanyIdAgastsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    createCustomAgast(params: { "companyId": string; "body": CustomAgast; "text"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyAGASTApiFetchParamCreator.createCustomAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Agast Code
     */
    deleteAgast(params: { "companyId": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyAGASTApiFetchParamCreator.deleteAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateCustomAgast(params: { "companyId": string; "code": string; "body": CustomAgast;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyAGASTApiFetchParamCreator.updateCustomAgast(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyAGASTApi - object-oriented interface
 */
export class CompanyAGASTApi extends BaseAPI {
    /** 
     * This operation return custom agast configurations that match with parameters queries - Alannes. 
     * @param companyId Company ID
     * @param code Agast Code
     * @param parent Agast parent code, means that this agast is a specialization of parent agast 
     */
    companiesCompanyIdAgastsCodeGet(params: {  "companyId": string; "code": string; "parent"?: string; }, options?: any) {
        return CompanyAGASTApiFp.companiesCompanyIdAgastsCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param text Text query
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param agast Custom Agast Code
     * @param parent Agast Code
     */
    companiesCompanyIdAgastsGet(params: {  "companyId": string; "text"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "agast"?: string; "parent"?: string; }, options?: any) {
        return CompanyAGASTApiFp.companiesCompanyIdAgastsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param text Text query
     */
    createCustomAgast(params: {  "companyId": string; "body": CustomAgast; "text"?: string; }, options?: any) {
        return CompanyAGASTApiFp.createCustomAgast(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Agast Code
     */
    deleteAgast(params: {  "companyId": string; "code": string; }, options?: any) {
        return CompanyAGASTApiFp.deleteAgast(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Agast Code
     * @param body Transaction Message
     */
    updateCustomAgast(params: {  "companyId": string; "code": string; "body": CustomAgast; }, options?: any) {
        return CompanyAGASTApiFp.updateCustomAgast(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyAGASTApi - factory interface
 */
export const CompanyAGASTApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return custom agast configurations that match with parameters queries - Alannes. 
         * @param companyId Company ID
         * @param code Agast Code
         * @param parent Agast parent code, means that this agast is a specialization of parent agast 
         */
        companiesCompanyIdAgastsCodeGet(params: {  "companyId": string; "code": string; "parent"?: string; }, options?: any) {
            return CompanyAGASTApiFp.companiesCompanyIdAgastsCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param text Text query
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         * @param agast Custom Agast Code
         * @param parent Agast Code
         */
        companiesCompanyIdAgastsGet(params: {  "companyId": string; "text"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "agast"?: string; "parent"?: string; }, options?: any) {
            return CompanyAGASTApiFp.companiesCompanyIdAgastsGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param body Transaction Message
         * @param text Text query
         */
        createCustomAgast(params: {  "companyId": string; "body": CustomAgast; "text"?: string; }, options?: any) {
            return CompanyAGASTApiFp.createCustomAgast(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Agast Code
         */
        deleteAgast(params: {  "companyId": string; "code": string; }, options?: any) {
            return CompanyAGASTApiFp.deleteAgast(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param code Agast Code
         * @param body Transaction Message
         */
        updateCustomAgast(params: {  "companyId": string; "code": string; "body": CustomAgast; }, options?: any) {
            return CompanyAGASTApiFp.updateCustomAgast(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyFilesApi - fetch parameter creator
 */
export const CompanyFilesApiFetchParamCreator = {
    /** 
     * Deletes a company file store.  
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    companiesCompanyIdNfseCertificateDelete(params: {  "companyId": string; "companyId2": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdNfseCertificateDelete");
        }
        // verify required parameter "companyId2" is set
        if (params["companyId2"] == null) {
            throw new Error("Missing required parameter companyId2 when calling companiesCompanyIdNfseCertificateDelete");
        }
        const baseUrl = `/companies/{companyId}/nfse-certificate`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"companyId"}}`, `${ params["companyId2"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets an existing NFSe certificate file for this company. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param peek Use this parameter to check the existence of the file without downloading it.
     */
    companiesCompanyIdNfseCertificateGet(params: {  "companyId": string; "companyId2": string; "peek"?: number; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdNfseCertificateGet");
        }
        // verify required parameter "companyId2" is set
        if (params["companyId2"] == null) {
            throw new Error("Missing required parameter companyId2 when calling companiesCompanyIdNfseCertificateGet");
        }
        const baseUrl = `/companies/{companyId}/nfse-certificate`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"companyId"}}`, `${ params["companyId2"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "peek": params["peek"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * If it still not exists, uploads a new NFSe Certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePost(params: {  "companyId": string; "body": Body3; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdNfseCertificatePost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling companiesCompanyIdNfseCertificatePost");
        }
        const baseUrl = `/companies/{companyId}/nfse-certificate`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates an existing NFSe certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePut(params: {  "companyId": string; "companyId2": string; "body": Body2; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdNfseCertificatePut");
        }
        // verify required parameter "companyId2" is set
        if (params["companyId2"] == null) {
            throw new Error("Missing required parameter companyId2 when calling companiesCompanyIdNfseCertificatePut");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling companiesCompanyIdNfseCertificatePut");
        }
        const baseUrl = `/companies/{companyId}/nfse-certificate`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"companyId"}}`, `${ params["companyId2"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyFilesApi - functional programming interface
 */
export const CompanyFilesApiFp = {
    /** 
     * Deletes a company file store.  
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    companiesCompanyIdNfseCertificateDelete(params: { "companyId": string; "companyId2": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyFilesApiFetchParamCreator.companiesCompanyIdNfseCertificateDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets an existing NFSe certificate file for this company. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param peek Use this parameter to check the existence of the file without downloading it.
     */
    companiesCompanyIdNfseCertificateGet(params: { "companyId": string; "companyId2": string; "peek"?: number;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyFilesApiFetchParamCreator.companiesCompanyIdNfseCertificateGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * If it still not exists, uploads a new NFSe Certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePost(params: { "companyId": string; "body": Body3;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = CompanyFilesApiFetchParamCreator.companiesCompanyIdNfseCertificatePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates an existing NFSe certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePut(params: { "companyId": string; "companyId2": string; "body": Body2;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = CompanyFilesApiFetchParamCreator.companiesCompanyIdNfseCertificatePut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyFilesApi - object-oriented interface
 */
export class CompanyFilesApi extends BaseAPI {
    /** 
     * Deletes a company file store.  
     * @param companyId Company ID
     * @param companyId2 Company ID
     */
    companiesCompanyIdNfseCertificateDelete(params: {  "companyId": string; "companyId2": string; }, options?: any) {
        return CompanyFilesApiFp.companiesCompanyIdNfseCertificateDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets an existing NFSe certificate file for this company. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param peek Use this parameter to check the existence of the file without downloading it.
     */
    companiesCompanyIdNfseCertificateGet(params: {  "companyId": string; "companyId2": string; "peek"?: number; }, options?: any) {
        return CompanyFilesApiFp.companiesCompanyIdNfseCertificateGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * If it still not exists, uploads a new NFSe Certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePost(params: {  "companyId": string; "body": Body3; }, options?: any) {
        return CompanyFilesApiFp.companiesCompanyIdNfseCertificatePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates an existing NFSe certificate file for this company. Send the file as a base64 string. 
     * @param companyId Company ID
     * @param companyId2 Company ID
     * @param body Content
     */
    companiesCompanyIdNfseCertificatePut(params: {  "companyId": string; "companyId2": string; "body": Body2; }, options?: any) {
        return CompanyFilesApiFp.companiesCompanyIdNfseCertificatePut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyFilesApi - factory interface
 */
export const CompanyFilesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Deletes a company file store.  
         * @param companyId Company ID
         * @param companyId2 Company ID
         */
        companiesCompanyIdNfseCertificateDelete(params: {  "companyId": string; "companyId2": string; }, options?: any) {
            return CompanyFilesApiFp.companiesCompanyIdNfseCertificateDelete(params, options)(fetch, basePath);
        },
        /** 
         * Gets an existing NFSe certificate file for this company. 
         * @param companyId Company ID
         * @param companyId2 Company ID
         * @param peek Use this parameter to check the existence of the file without downloading it.
         */
        companiesCompanyIdNfseCertificateGet(params: {  "companyId": string; "companyId2": string; "peek"?: number; }, options?: any) {
            return CompanyFilesApiFp.companiesCompanyIdNfseCertificateGet(params, options)(fetch, basePath);
        },
        /** 
         * If it still not exists, uploads a new NFSe Certificate file for this company. Send the file as a base64 string. 
         * @param companyId Company ID
         * @param body Content
         */
        companiesCompanyIdNfseCertificatePost(params: {  "companyId": string; "body": Body3; }, options?: any) {
            return CompanyFilesApiFp.companiesCompanyIdNfseCertificatePost(params, options)(fetch, basePath);
        },
        /** 
         * Updates an existing NFSe certificate file for this company. Send the file as a base64 string. 
         * @param companyId Company ID
         * @param companyId2 Company ID
         * @param body Content
         */
        companiesCompanyIdNfseCertificatePut(params: {  "companyId": string; "companyId2": string; "body": Body2; }, options?: any) {
            return CompanyFilesApiFp.companiesCompanyIdNfseCertificatePut(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyICMSApi - fetch parameter creator
 */
export const CompanyICMSApiFetchParamCreator = {
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdIcmsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdIcmsGet");
        }
        const baseUrl = `/companies/{companyId}/icms`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    companiesCompanyIdIcmsStateGet(params: {  "companyId": string; "state": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdIcmsStateGet");
        }
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling companiesCompanyIdIcmsStateGet");
        }
        const baseUrl = `/companies/{companyId}/icms/{state}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom ICMS tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createICMS(params: {  "companyId": string; "body": CustomIcmsConfByState; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createICMS");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createICMS");
        }
        const baseUrl = `/companies/{companyId}/icms`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    deleteCustomIcmsConfByState(params: {  "companyId": string; "state": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteCustomIcmsConfByState");
        }
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling deleteCustomIcmsConfByState");
        }
        const baseUrl = `/companies/{companyId}/icms/{state}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation update a custom ICMS tax for one company 
     * @param companyId Company ID
     * @param state Brazilian State
     * @param body Transaction Message
     */
    updateCustomIcmsConfByState(params: {  "companyId": string; "state": string; "body": CustomIcmsConfByState; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateCustomIcmsConfByState");
        }
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling updateCustomIcmsConfByState");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateCustomIcmsConfByState");
        }
        const baseUrl = `/companies/{companyId}/icms/{state}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyICMSApi - functional programming interface
 */
export const CompanyICMSApiFp = {
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdIcmsGet(params: { "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<CustomIcmsConfByState>> {
        const fetchArgs = CompanyICMSApiFetchParamCreator.companiesCompanyIdIcmsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    companiesCompanyIdIcmsStateGet(params: { "companyId": string; "state": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<CustomIcmsConfByState> {
        const fetchArgs = CompanyICMSApiFetchParamCreator.companiesCompanyIdIcmsStateGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom ICMS tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createICMS(params: { "companyId": string; "body": CustomIcmsConfByState;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyICMSApiFetchParamCreator.createICMS(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    deleteCustomIcmsConfByState(params: { "companyId": string; "state": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyICMSApiFetchParamCreator.deleteCustomIcmsConfByState(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation update a custom ICMS tax for one company 
     * @param companyId Company ID
     * @param state Brazilian State
     * @param body Transaction Message
     */
    updateCustomIcmsConfByState(params: { "companyId": string; "state": string; "body": CustomIcmsConfByState;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyICMSApiFetchParamCreator.updateCustomIcmsConfByState(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyICMSApi - object-oriented interface
 */
export class CompanyICMSApi extends BaseAPI {
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdIcmsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
        return CompanyICMSApiFp.companiesCompanyIdIcmsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom ICMS configurations that match with parameters queries 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    companiesCompanyIdIcmsStateGet(params: {  "companyId": string; "state": string; }, options?: any) {
        return CompanyICMSApiFp.companiesCompanyIdIcmsStateGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom ICMS tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createICMS(params: {  "companyId": string; "body": CustomIcmsConfByState; }, options?: any) {
        return CompanyICMSApiFp.createICMS(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param state Brazilian State
     */
    deleteCustomIcmsConfByState(params: {  "companyId": string; "state": string; }, options?: any) {
        return CompanyICMSApiFp.deleteCustomIcmsConfByState(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation update a custom ICMS tax for one company 
     * @param companyId Company ID
     * @param state Brazilian State
     * @param body Transaction Message
     */
    updateCustomIcmsConfByState(params: {  "companyId": string; "state": string; "body": CustomIcmsConfByState; }, options?: any) {
        return CompanyICMSApiFp.updateCustomIcmsConfByState(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyICMSApi - factory interface
 */
export const CompanyICMSApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return custom ICMS configurations that match with parameters queries 
         * @param companyId Company ID
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         */
        companiesCompanyIdIcmsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
            return CompanyICMSApiFp.companiesCompanyIdIcmsGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom ICMS configurations that match with parameters queries 
         * @param companyId Company ID
         * @param state Brazilian State
         */
        companiesCompanyIdIcmsStateGet(params: {  "companyId": string; "state": string; }, options?: any) {
            return CompanyICMSApiFp.companiesCompanyIdIcmsStateGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom ICMS tax for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param body Transaction Message
         */
        createICMS(params: {  "companyId": string; "body": CustomIcmsConfByState; }, options?: any) {
            return CompanyICMSApiFp.createICMS(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param state Brazilian State
         */
        deleteCustomIcmsConfByState(params: {  "companyId": string; "state": string; }, options?: any) {
            return CompanyICMSApiFp.deleteCustomIcmsConfByState(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation update a custom ICMS tax for one company 
         * @param companyId Company ID
         * @param state Brazilian State
         * @param body Transaction Message
         */
        updateCustomIcmsConfByState(params: {  "companyId": string; "state": string; "body": CustomIcmsConfByState; }, options?: any) {
            return CompanyICMSApiFp.updateCustomIcmsConfByState(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyItemCPOMServiceApi - fetch parameter creator
 */
export const CompanyItemCPOMServiceApiFetchParamCreator = {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    companiesCompanyIdItemsCodeCpomCityCodeGet(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodeCpomCityCodeGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodeCpomCityCodeGet");
        }
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling companiesCompanyIdItemsCodeCpomCityCodeGet");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/cpom/{cityCode}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`)
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdItemsCodeCpomGet(params: {  "companyId": string; "code": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodeCpomGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodeCpomGet");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/cpom`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     */
    createItemCPOM(params: {  "companyId": string; "code": string; "body": ItemCpom; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createItemCPOM");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling createItemCPOM");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createItemCPOM");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/cpom`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    deleteItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteItemCPOM");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteItemCPOM");
        }
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling deleteItemCPOM");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/cpom/{cityCode}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`)
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     * @param body Transaction Message
     */
    updateItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; "body": ItemCpom; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateItemCPOM");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateItemCPOM");
        }
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling updateItemCPOM");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateItemCPOM");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/cpom/{cityCode}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`)
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyItemCPOMServiceApi - functional programming interface
 */
export const CompanyItemCPOMServiceApiFp = {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    companiesCompanyIdItemsCodeCpomCityCodeGet(params: { "companyId": string; "code": string; "cityCode": number;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ItemCpom> {
        const fetchArgs = CompanyItemCPOMServiceApiFetchParamCreator.companiesCompanyIdItemsCodeCpomCityCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdItemsCodeCpomGet(params: { "companyId": string; "code": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<ItemCpom>> {
        const fetchArgs = CompanyItemCPOMServiceApiFetchParamCreator.companiesCompanyIdItemsCodeCpomGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     */
    createItemCPOM(params: { "companyId": string; "code": string; "body": ItemCpom;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyItemCPOMServiceApiFetchParamCreator.createItemCPOM(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    deleteItemCPOM(params: { "companyId": string; "code": string; "cityCode": number;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemCPOMServiceApiFetchParamCreator.deleteItemCPOM(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     * @param body Transaction Message
     */
    updateItemCPOM(params: { "companyId": string; "code": string; "cityCode": number; "body": ItemCpom;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemCPOMServiceApiFetchParamCreator.updateItemCPOM(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyItemCPOMServiceApi - object-oriented interface
 */
export class CompanyItemCPOMServiceApi extends BaseAPI {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    companiesCompanyIdItemsCodeCpomCityCodeGet(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any) {
        return CompanyItemCPOMServiceApiFp.companiesCompanyIdItemsCodeCpomCityCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdItemsCodeCpomGet(params: {  "companyId": string; "code": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
        return CompanyItemCPOMServiceApiFp.companiesCompanyIdItemsCodeCpomGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     */
    createItemCPOM(params: {  "companyId": string; "code": string; "body": ItemCpom; }, options?: any) {
        return CompanyItemCPOMServiceApiFp.createItemCPOM(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     */
    deleteItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any) {
        return CompanyItemCPOMServiceApiFp.deleteItemCPOM(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param cityCode City Code
     * @param body Transaction Message
     */
    updateItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; "body": ItemCpom; }, options?: any) {
        return CompanyItemCPOMServiceApiFp.updateItemCPOM(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyItemCPOMServiceApi - factory interface
 */
export const CompanyItemCPOMServiceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param code Item Code
         * @param cityCode City Code
         */
        companiesCompanyIdItemsCodeCpomCityCodeGet(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any) {
            return CompanyItemCPOMServiceApiFp.companiesCompanyIdItemsCodeCpomCityCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param code Item Code
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         */
        companiesCompanyIdItemsCodeCpomGet(params: {  "companyId": string; "code": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
            return CompanyItemCPOMServiceApiFp.companiesCompanyIdItemsCodeCpomGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param code Item Code
         * @param body Transaction Message
         */
        createItemCPOM(params: {  "companyId": string; "code": string; "body": ItemCpom; }, options?: any) {
            return CompanyItemCPOMServiceApiFp.createItemCPOM(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Item Code
         * @param cityCode City Code
         */
        deleteItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; }, options?: any) {
            return CompanyItemCPOMServiceApiFp.deleteItemCPOM(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param code Item Code
         * @param cityCode City Code
         * @param body Transaction Message
         */
        updateItemCPOM(params: {  "companyId": string; "code": string; "cityCode": number; "body": ItemCpom; }, options?: any) {
            return CompanyItemCPOMServiceApiFp.updateItemCPOM(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyItemGoodsApi - fetch parameter creator
 */
export const CompanyItemGoodsApiFetchParamCreator = {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/change-code`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "goods": params["goods"],
            "service": params["service"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodegoodsGet(params: {  "companyId": string; "code": string; "avalaraProductType": string; "agast"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodegoodsGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodegoodsGet");
        }
        // verify required parameter "avalaraProductType" is set
        if (params["avalaraProductType"] == null) {
            throw new Error("Missing required parameter avalaraProductType when calling companiesCompanyIdItemsCodegoodsGet");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?goods`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "agast": params["agast"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsgoodsGet(params: {  "companyId": string; "avalaraProductType": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsgoodsGet");
        }
        // verify required parameter "avalaraProductType" is set
        if (params["avalaraProductType"] == null) {
            throw new Error("Missing required parameter avalaraProductType when calling companiesCompanyIdItemsgoodsGet");
        }
        const baseUrl = `/companies/{companyId}/items?goods`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "code": params["code"],
            "agast": params["agast"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],"X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    createItem(params: {  "companyId": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createItem");
        }
        // verify required parameter "avalaraProductType" is set
        if (params["avalaraProductType"] == null) {
            throw new Error("Missing required parameter avalaraProductType when calling createItem");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createItem");
        }
        const baseUrl = `/companies/{companyId}/items?goods`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteItem");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteItem");
        }
        // verify required parameter "avalaraProductType" is set
        if (params["avalaraProductType"] == null) {
            throw new Error("Missing required parameter avalaraProductType when calling deleteItem");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?goods`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    updateItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateItem");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateItem");
        }
        // verify required parameter "avalaraProductType" is set
        if (params["avalaraProductType"] == null) {
            throw new Error("Missing required parameter avalaraProductType when calling updateItem");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateItem");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?goods`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyItemGoodsApi - functional programming interface
 */
export const CompanyItemGoodsApiFp = {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: { "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.companiesCompanyIdItemsCodeChangeCodePut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodegoodsGet(params: { "companyId": string; "code": string; "avalaraProductType": string; "agast"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ItemGoods> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.companiesCompanyIdItemsCodegoodsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsgoodsGet(params: { "companyId": string; "avalaraProductType": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<ItemGoods>> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.companiesCompanyIdItemsgoodsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    createItem(params: { "companyId": string; "avalaraProductType": string; "body": ItemGoods;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.createItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItem(params: { "companyId": string; "code": string; "avalaraProductType": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.deleteItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    updateItem(params: { "companyId": string; "code": string; "avalaraProductType": string; "body": ItemGoods;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemGoodsApiFetchParamCreator.updateItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyItemGoodsApi - object-oriented interface
 */
export class CompanyItemGoodsApi extends BaseAPI {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any) {
        return CompanyItemGoodsApiFp.companiesCompanyIdItemsCodeChangeCodePut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodegoodsGet(params: {  "companyId": string; "code": string; "avalaraProductType": string; "agast"?: string; }, options?: any) {
        return CompanyItemGoodsApiFp.companiesCompanyIdItemsCodegoodsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsgoodsGet(params: {  "companyId": string; "avalaraProductType": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any) {
        return CompanyItemGoodsApiFp.companiesCompanyIdItemsgoodsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    createItem(params: {  "companyId": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any) {
        return CompanyItemGoodsApiFp.createItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; }, options?: any) {
        return CompanyItemGoodsApiFp.deleteItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param body Transaction Message
     */
    updateItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any) {
        return CompanyItemGoodsApiFp.updateItem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyItemGoodsApi - factory interface
 */
export const CompanyItemGoodsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Change the code of a given item. 
         * @param companyId Company ID
         * @param code Item Code
         * @param body Requisition
         * @param goods Provide to apply to goods items.
         * @param service Provide to apply to service items.
         */
        companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any) {
            return CompanyItemGoodsApiFp.companiesCompanyIdItemsCodeChangeCodePut(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param code Item Code
         * @param avalaraProductType Avalara Product Type
         * @param agast Custom Agast Code
         */
        companiesCompanyIdItemsCodegoodsGet(params: {  "companyId": string; "code": string; "avalaraProductType": string; "agast"?: string; }, options?: any) {
            return CompanyItemGoodsApiFp.companiesCompanyIdItemsCodegoodsGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param avalaraProductType Avalara Product Type
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         * @param code Item Code
         * @param agast Custom Agast Code
         */
        companiesCompanyIdItemsgoodsGet(params: {  "companyId": string; "avalaraProductType": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any) {
            return CompanyItemGoodsApiFp.companiesCompanyIdItemsgoodsGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param avalaraProductType Avalara Product Type
         * @param body Transaction Message
         */
        createItem(params: {  "companyId": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any) {
            return CompanyItemGoodsApiFp.createItem(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Item Code
         * @param avalaraProductType Avalara Product Type
         */
        deleteItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; }, options?: any) {
            return CompanyItemGoodsApiFp.deleteItem(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param code Item Code
         * @param avalaraProductType Avalara Product Type
         * @param body Transaction Message
         */
        updateItem(params: {  "companyId": string; "code": string; "avalaraProductType": string; "body": ItemGoods; }, options?: any) {
            return CompanyItemGoodsApiFp.updateItem(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyItemServiceApi - fetch parameter creator
 */
export const CompanyItemServiceApiFetchParamCreator = {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling companiesCompanyIdItemsCodeChangeCodePut");
        }
        const baseUrl = `/companies/{companyId}/items/{code}/change-code`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "goods": params["goods"],
            "service": params["service"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodeserviceGet(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; "agast"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsCodeserviceGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdItemsCodeserviceGet");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?service`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "agast": params["agast"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsserviceGet(params: {  "companyId": string; "avalaraProductType"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdItemsserviceGet");
        }
        const baseUrl = `/companies/{companyId}/items?service`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "code": params["code"],
            "agast": params["agast"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],"X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    createItemService(params: {  "companyId": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createItemService");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createItemService");
        }
        const baseUrl = `/companies/{companyId}/items?service`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItemService(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteItemService");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteItemService");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?service`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    updateItemService(params: {  "companyId": string; "code": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateItemService");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateItemService");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateItemService");
        }
        const baseUrl = `/companies/{companyId}/items/{code}?service`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Avalara-Product-Type": params["avalaraProductType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyItemServiceApi - functional programming interface
 */
export const CompanyItemServiceApiFp = {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: { "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.companiesCompanyIdItemsCodeChangeCodePut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodeserviceGet(params: { "companyId": string; "code": string; "avalaraProductType"?: string; "agast"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ItemSimple> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.companiesCompanyIdItemsCodeserviceGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsserviceGet(params: { "companyId": string; "avalaraProductType"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<ItemSimple>> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.companiesCompanyIdItemsserviceGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    createItemService(params: { "companyId": string; "body": ItemSimple; "avalaraProductType"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.createItemService(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItemService(params: { "companyId": string; "code": string; "avalaraProductType"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.deleteItemService(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    updateItemService(params: { "companyId": string; "code": string; "body": ItemSimple; "avalaraProductType"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyItemServiceApiFetchParamCreator.updateItemService(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyItemServiceApi - object-oriented interface
 */
export class CompanyItemServiceApi extends BaseAPI {
    /** 
     * Change the code of a given item. 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Requisition
     * @param goods Provide to apply to goods items.
     * @param service Provide to apply to service items.
     */
    companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.companiesCompanyIdItemsCodeChangeCodePut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsCodeserviceGet(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; "agast"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.companiesCompanyIdItemsCodeserviceGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param avalaraProductType Avalara Product Type
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     * @param code Item Code
     * @param agast Custom Agast Code
     */
    companiesCompanyIdItemsserviceGet(params: {  "companyId": string; "avalaraProductType"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.companiesCompanyIdItemsserviceGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    createItemService(params: {  "companyId": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.createItemService(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Item Code
     * @param avalaraProductType Avalara Product Type
     */
    deleteItemService(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.deleteItemService(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param code Item Code
     * @param body Transaction Message
     * @param avalaraProductType Avalara Product Type
     */
    updateItemService(params: {  "companyId": string; "code": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any) {
        return CompanyItemServiceApiFp.updateItemService(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyItemServiceApi - factory interface
 */
export const CompanyItemServiceApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Change the code of a given item. 
         * @param companyId Company ID
         * @param code Item Code
         * @param body Requisition
         * @param goods Provide to apply to goods items.
         * @param service Provide to apply to service items.
         */
        companiesCompanyIdItemsCodeChangeCodePut(params: {  "companyId": string; "code": string; "body": Body1; "goods"?: string; "service"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.companiesCompanyIdItemsCodeChangeCodePut(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param code Item Code
         * @param avalaraProductType Avalara Product Type
         * @param agast Custom Agast Code
         */
        companiesCompanyIdItemsCodeserviceGet(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; "agast"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.companiesCompanyIdItemsCodeserviceGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param avalaraProductType Avalara Product Type
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         * @param code Item Code
         * @param agast Custom Agast Code
         */
        companiesCompanyIdItemsserviceGet(params: {  "companyId": string; "avalaraProductType"?: string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; "code"?: string; "agast"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.companiesCompanyIdItemsserviceGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param body Transaction Message
         * @param avalaraProductType Avalara Product Type
         */
        createItemService(params: {  "companyId": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.createItemService(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Item Code
         * @param avalaraProductType Avalara Product Type
         */
        deleteItemService(params: {  "companyId": string; "code": string; "avalaraProductType"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.deleteItemService(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param code Item Code
         * @param body Transaction Message
         * @param avalaraProductType Avalara Product Type
         */
        updateItemService(params: {  "companyId": string; "code": string; "body": ItemSimple; "avalaraProductType"?: string; }, options?: any) {
            return CompanyItemServiceApiFp.updateItemService(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyLocationApi - fetch parameter creator
 */
export const CompanyLocationApiFetchParamCreator = {
    /** 
     * This operation return location 
     * @param companyId Company ID
     * @param code Location Code
     */
    companiesCompanyIdLocationsCodeGet(params: {  "companyId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdLocationsCodeGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdLocationsCodeGet");
        }
        const baseUrl = `/companies/{companyId}/locations/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return all locations 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdLocationsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdLocationsGet");
        }
        const baseUrl = `/companies/{companyId}/locations`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create new location for company
     * This method operation create a new location for company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createLocation(params: {  "companyId": string; "body": Location; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createLocation");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createLocation");
        }
        const baseUrl = `/companies/{companyId}/locations`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Location Code
     */
    deleteLocation(params: {  "companyId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteLocation");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteLocation");
        }
        const baseUrl = `/companies/{companyId}/locations/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update location for company
     * This method operation update a location for company 
     * @param companyId Company ID
     * @param code Location Code
     * @param body Transaction Message
     */
    updateLocation(params: {  "companyId": string; "code": string; "body": Location; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateLocation");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateLocation");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateLocation");
        }
        const baseUrl = `/companies/{companyId}/locations/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyLocationApi - functional programming interface
 */
export const CompanyLocationApiFp = {
    /** 
     * This operation return location 
     * @param companyId Company ID
     * @param code Location Code
     */
    companiesCompanyIdLocationsCodeGet(params: { "companyId": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Location> {
        const fetchArgs = CompanyLocationApiFetchParamCreator.companiesCompanyIdLocationsCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return all locations 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdLocationsGet(params: { "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<Location>> {
        const fetchArgs = CompanyLocationApiFetchParamCreator.companiesCompanyIdLocationsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create new location for company
     * This method operation create a new location for company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createLocation(params: { "companyId": string; "body": Location;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyLocationApiFetchParamCreator.createLocation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Location Code
     */
    deleteLocation(params: { "companyId": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyLocationApiFetchParamCreator.deleteLocation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update location for company
     * This method operation update a location for company 
     * @param companyId Company ID
     * @param code Location Code
     * @param body Transaction Message
     */
    updateLocation(params: { "companyId": string; "code": string; "body": Location;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyLocationApiFetchParamCreator.updateLocation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyLocationApi - object-oriented interface
 */
export class CompanyLocationApi extends BaseAPI {
    /** 
     * This operation return location 
     * @param companyId Company ID
     * @param code Location Code
     */
    companiesCompanyIdLocationsCodeGet(params: {  "companyId": string; "code": string; }, options?: any) {
        return CompanyLocationApiFp.companiesCompanyIdLocationsCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return all locations 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdLocationsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
        return CompanyLocationApiFp.companiesCompanyIdLocationsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create new location for company
     * This method operation create a new location for company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createLocation(params: {  "companyId": string; "body": Location; }, options?: any) {
        return CompanyLocationApiFp.createLocation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Location Code
     */
    deleteLocation(params: {  "companyId": string; "code": string; }, options?: any) {
        return CompanyLocationApiFp.deleteLocation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update location for company
     * This method operation update a location for company 
     * @param companyId Company ID
     * @param code Location Code
     * @param body Transaction Message
     */
    updateLocation(params: {  "companyId": string; "code": string; "body": Location; }, options?: any) {
        return CompanyLocationApiFp.updateLocation(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyLocationApi - factory interface
 */
export const CompanyLocationApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return location 
         * @param companyId Company ID
         * @param code Location Code
         */
        companiesCompanyIdLocationsCodeGet(params: {  "companyId": string; "code": string; }, options?: any) {
            return CompanyLocationApiFp.companiesCompanyIdLocationsCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return all locations 
         * @param companyId Company ID
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         */
        companiesCompanyIdLocationsGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
            return CompanyLocationApiFp.companiesCompanyIdLocationsGet(params, options)(fetch, basePath);
        },
        /** 
         * Create new location for company
         * This method operation create a new location for company 
         * @param companyId Company ID
         * @param body Transaction Message
         */
        createLocation(params: {  "companyId": string; "body": Location; }, options?: any) {
            return CompanyLocationApiFp.createLocation(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Location Code
         */
        deleteLocation(params: {  "companyId": string; "code": string; }, options?: any) {
            return CompanyLocationApiFp.deleteLocation(params, options)(fetch, basePath);
        },
        /** 
         * Update location for company
         * This method operation update a location for company 
         * @param companyId Company ID
         * @param code Location Code
         * @param body Transaction Message
         */
        updateLocation(params: {  "companyId": string; "code": string; "body": Location; }, options?: any) {
            return CompanyLocationApiFp.updateLocation(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyProcessApi - fetch parameter creator
 */
export const CompanyProcessApiFetchParamCreator = {
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Process Code
     */
    companiesCompanyIdProcessCodeGet(params: {  "companyId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdProcessCodeGet");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling companiesCompanyIdProcessCodeGet");
        }
        const baseUrl = `/companies/{companyId}/process/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdProcessGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdProcessGet");
        }
        const baseUrl = `/companies/{companyId}/process`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom process tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomProcessScenario(params: {  "companyId": string; "body": CustomProcessScenario; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createCustomProcessScenario");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createCustomProcessScenario");
        }
        const baseUrl = `/companies/{companyId}/process`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Process Code
     */
    deleteCustomProcessScenario(params: {  "companyId": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteCustomProcessScenario");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteCustomProcessScenario");
        }
        const baseUrl = `/companies/{companyId}/process/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation update a custom process for one company 
     * @param companyId Company ID
     * @param code Process Code
     * @param body Transaction Message
     */
    updateCustomProcessScenario(params: {  "companyId": string; "code": string; "body": CustomProcessScenario; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateCustomProcessScenario");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCustomProcessScenario");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateCustomProcessScenario");
        }
        const baseUrl = `/companies/{companyId}/process/{code}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyProcessApi - functional programming interface
 */
export const CompanyProcessApiFp = {
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Process Code
     */
    companiesCompanyIdProcessCodeGet(params: { "companyId": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<CustomProcessScenario> {
        const fetchArgs = CompanyProcessApiFetchParamCreator.companiesCompanyIdProcessCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdProcessGet(params: { "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<CustomProcessScenario>> {
        const fetchArgs = CompanyProcessApiFetchParamCreator.companiesCompanyIdProcessGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom process tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomProcessScenario(params: { "companyId": string; "body": CustomProcessScenario;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyProcessApiFetchParamCreator.createCustomProcessScenario(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param code Process Code
     */
    deleteCustomProcessScenario(params: { "companyId": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyProcessApiFetchParamCreator.deleteCustomProcessScenario(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation update a custom process for one company 
     * @param companyId Company ID
     * @param code Process Code
     * @param body Transaction Message
     */
    updateCustomProcessScenario(params: { "companyId": string; "code": string; "body": CustomProcessScenario;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyProcessApiFetchParamCreator.updateCustomProcessScenario(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyProcessApi - object-oriented interface
 */
export class CompanyProcessApi extends BaseAPI {
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param code Process Code
     */
    companiesCompanyIdProcessCodeGet(params: {  "companyId": string; "code": string; }, options?: any) {
        return CompanyProcessApiFp.companiesCompanyIdProcessCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom process configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdProcessGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
        return CompanyProcessApiFp.companiesCompanyIdProcessGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom process tax for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomProcessScenario(params: {  "companyId": string; "body": CustomProcessScenario; }, options?: any) {
        return CompanyProcessApiFp.createCustomProcessScenario(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param code Process Code
     */
    deleteCustomProcessScenario(params: {  "companyId": string; "code": string; }, options?: any) {
        return CompanyProcessApiFp.deleteCustomProcessScenario(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation update a custom process for one company 
     * @param companyId Company ID
     * @param code Process Code
     * @param body Transaction Message
     */
    updateCustomProcessScenario(params: {  "companyId": string; "code": string; "body": CustomProcessScenario; }, options?: any) {
        return CompanyProcessApiFp.updateCustomProcessScenario(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyProcessApi - factory interface
 */
export const CompanyProcessApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return custom process configurations that match with parameters queries 
         * @param companyId Company ID
         * @param code Process Code
         */
        companiesCompanyIdProcessCodeGet(params: {  "companyId": string; "code": string; }, options?: any) {
            return CompanyProcessApiFp.companiesCompanyIdProcessCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom process configurations that match with parameters queries 
         * @param companyId Company ID
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         */
        companiesCompanyIdProcessGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
            return CompanyProcessApiFp.companiesCompanyIdProcessGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom process tax for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param body Transaction Message
         */
        createCustomProcessScenario(params: {  "companyId": string; "body": CustomProcessScenario; }, options?: any) {
            return CompanyProcessApiFp.createCustomProcessScenario(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param code Process Code
         */
        deleteCustomProcessScenario(params: {  "companyId": string; "code": string; }, options?: any) {
            return CompanyProcessApiFp.deleteCustomProcessScenario(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation update a custom process for one company 
         * @param companyId Company ID
         * @param code Process Code
         * @param body Transaction Message
         */
        updateCustomProcessScenario(params: {  "companyId": string; "code": string; "body": CustomProcessScenario; }, options?: any) {
            return CompanyProcessApiFp.updateCustomProcessScenario(params, options)(fetch, basePath);
        },
    };
};


/**
 * CompanyTaxRatesApi - fetch parameter creator
 */
export const CompanyTaxRatesApiFetchParamCreator = {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdTaxratesGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdTaxratesGet");
        }
        const baseUrl = `/companies/{companyId}/taxrates`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "X-Pagination-Limit": params["xPaginationLimit"],"X-Pagination-Current-Page": params["xPaginationCurrentPage"],"X-Pagination-Sort": params["xPaginationSort"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    companiesCompanyIdTaxratesTaxTypeGet(params: {  "companyId": string; "taxType": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling companiesCompanyIdTaxratesTaxTypeGet");
        }
        // verify required parameter "taxType" is set
        if (params["taxType"] == null) {
            throw new Error("Missing required parameter taxType when calling companiesCompanyIdTaxratesTaxTypeGet");
        }
        const baseUrl = `/companies/{companyId}/taxrates/{taxType}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"taxType"}}`, `${ params["taxType"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomTaxes(params: {  "companyId": string; "body": CustomTaxTypeRate; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling createCustomTaxes");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createCustomTaxes");
        }
        const baseUrl = `/companies/{companyId}/taxrates`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    deleteCustomTaxes(params: {  "companyId": string; "taxType": string; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling deleteCustomTaxes");
        }
        // verify required parameter "taxType" is set
        if (params["taxType"] == null) {
            throw new Error("Missing required parameter taxType when calling deleteCustomTaxes");
        }
        const baseUrl = `/companies/{companyId}/taxrates/{taxType}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"taxType"}}`, `${ params["taxType"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param taxType Tax Type
     * @param body Transaction Message
     */
    updateCustomTaxes(params: {  "companyId": string; "taxType": string; "body": CustomTaxTypeRate; }, options?: any): FetchArgs {
        // verify required parameter "companyId" is set
        if (params["companyId"] == null) {
            throw new Error("Missing required parameter companyId when calling updateCustomTaxes");
        }
        // verify required parameter "taxType" is set
        if (params["taxType"] == null) {
            throw new Error("Missing required parameter taxType when calling updateCustomTaxes");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateCustomTaxes");
        }
        const baseUrl = `/companies/{companyId}/taxrates/{taxType}`
            .replace(`{${"companyId"}}`, `${ params["companyId"] }`)
            .replace(`{${"taxType"}}`, `${ params["taxType"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CompanyTaxRatesApi - functional programming interface
 */
export const CompanyTaxRatesApiFp = {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdTaxratesGet(params: { "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<CustomTaxTypeRate>> {
        const fetchArgs = CompanyTaxRatesApiFetchParamCreator.companiesCompanyIdTaxratesGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    companiesCompanyIdTaxratesTaxTypeGet(params: { "companyId": string; "taxType": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<CustomTaxTypeRate> {
        const fetchArgs = CompanyTaxRatesApiFetchParamCreator.companiesCompanyIdTaxratesTaxTypeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomTaxes(params: { "companyId": string; "body": CustomTaxTypeRate;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = CompanyTaxRatesApiFetchParamCreator.createCustomTaxes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    deleteCustomTaxes(params: { "companyId": string; "taxType": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyTaxRatesApiFetchParamCreator.deleteCustomTaxes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param taxType Tax Type
     * @param body Transaction Message
     */
    updateCustomTaxes(params: { "companyId": string; "taxType": string; "body": CustomTaxTypeRate;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CompanyTaxRatesApiFetchParamCreator.updateCustomTaxes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CompanyTaxRatesApi - object-oriented interface
 */
export class CompanyTaxRatesApi extends BaseAPI {
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
     * @param xPaginationCurrentPage The current page. Defaults to 1.
     * @param xPaginationSort 
     */
    companiesCompanyIdTaxratesGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
        return CompanyTaxRatesApiFp.companiesCompanyIdTaxratesGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * This operation return custom agast configurations that match with parameters queries 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    companiesCompanyIdTaxratesTaxTypeGet(params: {  "companyId": string; "taxType": string; }, options?: any) {
        return CompanyTaxRatesApiFp.companiesCompanyIdTaxratesTaxTypeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param body Transaction Message
     */
    createCustomTaxes(params: {  "companyId": string; "body": CustomTaxTypeRate; }, options?: any) {
        return CompanyTaxRatesApiFp.createCustomTaxes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param companyId Company ID
     * @param taxType Tax Type
     */
    deleteCustomTaxes(params: {  "companyId": string; "taxType": string; }, options?: any) {
        return CompanyTaxRatesApiFp.deleteCustomTaxes(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update custom agast for one company
     * This method operation create a custom agast for one company 
     * @param companyId Company ID
     * @param taxType Tax Type
     * @param body Transaction Message
     */
    updateCustomTaxes(params: {  "companyId": string; "taxType": string; "body": CustomTaxTypeRate; }, options?: any) {
        return CompanyTaxRatesApiFp.updateCustomTaxes(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CompanyTaxRatesApi - factory interface
 */
export const CompanyTaxRatesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param xPaginationLimit The per page limit. Currently set to 10 but subject to change at any time (max 100).
         * @param xPaginationCurrentPage The current page. Defaults to 1.
         * @param xPaginationSort 
         */
        companiesCompanyIdTaxratesGet(params: {  "companyId": string; "xPaginationLimit"?: number; "xPaginationCurrentPage"?: number; "xPaginationSort"?: string; }, options?: any) {
            return CompanyTaxRatesApiFp.companiesCompanyIdTaxratesGet(params, options)(fetch, basePath);
        },
        /** 
         * This operation return custom agast configurations that match with parameters queries 
         * @param companyId Company ID
         * @param taxType Tax Type
         */
        companiesCompanyIdTaxratesTaxTypeGet(params: {  "companyId": string; "taxType": string; }, options?: any) {
            return CompanyTaxRatesApiFp.companiesCompanyIdTaxratesTaxTypeGet(params, options)(fetch, basePath);
        },
        /** 
         * Create custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param body Transaction Message
         */
        createCustomTaxes(params: {  "companyId": string; "body": CustomTaxTypeRate; }, options?: any) {
            return CompanyTaxRatesApiFp.createCustomTaxes(params, options)(fetch, basePath);
        },
        /** 
         * @param companyId Company ID
         * @param taxType Tax Type
         */
        deleteCustomTaxes(params: {  "companyId": string; "taxType": string; }, options?: any) {
            return CompanyTaxRatesApiFp.deleteCustomTaxes(params, options)(fetch, basePath);
        },
        /** 
         * Update custom agast for one company
         * This method operation create a custom agast for one company 
         * @param companyId Company ID
         * @param taxType Tax Type
         * @param body Transaction Message
         */
        updateCustomTaxes(params: {  "companyId": string; "taxType": string; "body": CustomTaxTypeRate; }, options?: any) {
            return CompanyTaxRatesApiFp.updateCustomTaxes(params, options)(fetch, basePath);
        },
    };
};


/**
 * GoodsCalculationsApi - fetch parameter creator
 */
export const GoodsCalculationsApiFetchParamCreator = {
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsgoodsPurchasePost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsgoodsPurchasePost");
        }
        const baseUrl = `/calculations?goods-purchase`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsgoodsSalesPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsgoodsSalesPost");
        }
        const baseUrl = `/calculations?goods-sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GoodsCalculationsApi - functional programming interface
 */
export const GoodsCalculationsApiFp = {
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsPurchasePost(params: { "authorization": string; "body": TransactionForGoodsIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<TransactionForGoodsOut> {
        const fetchArgs = GoodsCalculationsApiFetchParamCreator.calculationsgoodsPurchasePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsSalesPost(params: { "authorization": string; "body": TransactionForGoodsIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<TransactionForGoodsOut> {
        const fetchArgs = GoodsCalculationsApiFetchParamCreator.calculationsgoodsSalesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GoodsCalculationsApi - object-oriented interface
 */
export class GoodsCalculationsApi extends BaseAPI {
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
        return GoodsCalculationsApiFp.calculationsgoodsPurchasePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
        return GoodsCalculationsApiFp.calculationsgoodsSalesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GoodsCalculationsApi - factory interface
 */
export const GoodsCalculationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Calculation Method
         * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
            return GoodsCalculationsApiFp.calculationsgoodsPurchasePost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * This method has more the one operation model, (a) simple calculation, this mode has a minimal validation and mandatory field, only enough for calc; (b) full calculation, simulation, this mode the system will check all atributes and calc all taxes for that transaction; (c) full calculation, starting process to transform this this request into transaction (for NFe, NFCe, CT-e need government authorization); (d) ASIS, the sistem receive the message, store and try get authorization, model valid only form NFe, NFCe and CT-e. 
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
            return GoodsCalculationsApiFp.calculationsgoodsSalesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * GoodsTransactionsApi - fetch parameter creator
 */
export const GoodsTransactionsApiFetchParamCreator = {
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsgoodsPurchasePost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsgoodsPurchasePost");
        }
        const baseUrl = `/transactions?goods-purchase`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fields, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates the taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsgoodsSalesPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsgoodsSalesPost");
        }
        const baseUrl = `/transactions?goods-sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GoodsTransactionsApi - functional programming interface
 */
export const GoodsTransactionsApiFp = {
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsPurchasePost(params: { "authorization": string; "body": TransactionForGoodsIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<TransactionForGoodsOut> {
        const fetchArgs = GoodsTransactionsApiFetchParamCreator.transactionsgoodsPurchasePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fields, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates the taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsSalesPost(params: { "authorization": string; "body": TransactionForGoodsIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<TransactionForGoodsOut> {
        const fetchArgs = GoodsTransactionsApiFetchParamCreator.transactionsgoodsSalesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GoodsTransactionsApi - object-oriented interface
 */
export class GoodsTransactionsApi extends BaseAPI {
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
        return GoodsTransactionsApiFp.transactionsgoodsPurchasePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Transaction Method
     * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fields, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates the taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
        return GoodsTransactionsApiFp.transactionsgoodsSalesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GoodsTransactionsApi - factory interface
 */
export const GoodsTransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Transaction Method
         * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fileds, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsgoodsPurchasePost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
            return GoodsTransactionsApiFp.transactionsgoodsPurchasePost(params, options)(fetch, basePath);
        },
        /** 
         * Transaction Method
         * This method has more then one operation model, (a) AS IS, the system only stores the transaction; (b) Full Calculation, the system calculates taxes, validates fields, stores with transaction state, but doesn&#39;t try get government authorization; (c) Full Sync, the system calculates the taxes, validates fileds, gets government authorization, stores with transaction state when authorized, used for NFCe. 
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsgoodsSalesPost(params: {  "authorization": string; "body": TransactionForGoodsIn; }, options?: any) {
            return GoodsTransactionsApiFp.transactionsgoodsSalesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceContingencyApi - fetch parameter creator
 */
export const InvoiceContingencyApiFetchParamCreator = {
    /** 
     * Invoice Drop Contingency per State
     * Drop State in Contingency
     * @param state Brazilian State
     */
    invoiceDropContingency(params: {  "state": string; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling invoiceDropContingency");
        }
        const baseUrl = `/invoices/contingency/{state}`
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Invoice Set Contingency per State
     * Set State in Contingency
     * @param state Brazilian State
     * @param body Set Contingency
     */
    invoiceSetContingency(params: {  "state": string; "body": Body4; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling invoiceSetContingency");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling invoiceSetContingency");
        }
        const baseUrl = `/invoices/contingency/{state}`
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Invoice Verify Contingency per State
     * Check if State was in Contingency
     * @param state Brazilian State
     */
    invoiceVerifyContingency(params: {  "state": string; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling invoiceVerifyContingency");
        }
        const baseUrl = `/invoices/contingency/{state}`
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceContingencyApi - functional programming interface
 */
export const InvoiceContingencyApiFp = {
    /** 
     * Invoice Drop Contingency per State
     * Drop State in Contingency
     * @param state Brazilian State
     */
    invoiceDropContingency(params: { "state": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoiceContingencyApiFetchParamCreator.invoiceDropContingency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Invoice Set Contingency per State
     * Set State in Contingency
     * @param state Brazilian State
     * @param body Set Contingency
     */
    invoiceSetContingency(params: { "state": string; "body": Body4;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoiceContingencyApiFetchParamCreator.invoiceSetContingency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Invoice Verify Contingency per State
     * Check if State was in Contingency
     * @param state Brazilian State
     */
    invoiceVerifyContingency(params: { "state": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = InvoiceContingencyApiFetchParamCreator.invoiceVerifyContingency(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceContingencyApi - object-oriented interface
 */
export class InvoiceContingencyApi extends BaseAPI {
    /** 
     * Invoice Drop Contingency per State
     * Drop State in Contingency
     * @param state Brazilian State
     */
    invoiceDropContingency(params: {  "state": string; }, options?: any) {
        return InvoiceContingencyApiFp.invoiceDropContingency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Invoice Set Contingency per State
     * Set State in Contingency
     * @param state Brazilian State
     * @param body Set Contingency
     */
    invoiceSetContingency(params: {  "state": string; "body": Body4; }, options?: any) {
        return InvoiceContingencyApiFp.invoiceSetContingency(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Invoice Verify Contingency per State
     * Check if State was in Contingency
     * @param state Brazilian State
     */
    invoiceVerifyContingency(params: {  "state": string; }, options?: any) {
        return InvoiceContingencyApiFp.invoiceVerifyContingency(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceContingencyApi - factory interface
 */
export const InvoiceContingencyApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Invoice Drop Contingency per State
         * Drop State in Contingency
         * @param state Brazilian State
         */
        invoiceDropContingency(params: {  "state": string; }, options?: any) {
            return InvoiceContingencyApiFp.invoiceDropContingency(params, options)(fetch, basePath);
        },
        /** 
         * Invoice Set Contingency per State
         * Set State in Contingency
         * @param state Brazilian State
         * @param body Set Contingency
         */
        invoiceSetContingency(params: {  "state": string; "body": Body4; }, options?: any) {
            return InvoiceContingencyApiFp.invoiceSetContingency(params, options)(fetch, basePath);
        },
        /** 
         * Invoice Verify Contingency per State
         * Check if State was in Contingency
         * @param state Brazilian State
         */
        invoiceVerifyContingency(params: {  "state": string; }, options?: any) {
            return InvoiceContingencyApiFp.invoiceVerifyContingency(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceNFCeDANFEApi - fetch parameter creator
 */
export const InvoiceNFCeDANFEApiFetchParamCreator = {
    /** 
     * NFCe Danfe Print
     * Retrieve the Danfe in NFCe format. 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesNfceKeyGet(params: {  "authorization": string; "key": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesNfceKeyGet");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling invoicesNfceKeyGet");
        }
        const baseUrl = `/invoices/nfce/{key}`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceNFCeDANFEApi - functional programming interface
 */
export const InvoiceNFCeDANFEApiFp = {
    /** 
     * NFCe Danfe Print
     * Retrieve the Danfe in NFCe format. 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesNfceKeyGet(params: { "authorization": string; "key": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoiceNFCeDANFEApiFetchParamCreator.invoicesNfceKeyGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceNFCeDANFEApi - object-oriented interface
 */
export class InvoiceNFCeDANFEApi extends BaseAPI {
    /** 
     * NFCe Danfe Print
     * Retrieve the Danfe in NFCe format. 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesNfceKeyGet(params: {  "authorization": string; "key": string; }, options?: any) {
        return InvoiceNFCeDANFEApiFp.invoicesNfceKeyGet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceNFCeDANFEApi - factory interface
 */
export const InvoiceNFCeDANFEApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * NFCe Danfe Print
         * Retrieve the Danfe in NFCe format. 
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         */
        invoicesNfceKeyGet(params: {  "authorization": string; "key": string; }, options?: any) {
            return InvoiceNFCeDANFEApiFp.invoicesNfceKeyGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceNFeDANFEApi - fetch parameter creator
 */
export const InvoiceNFeDANFEApiFetchParamCreator = {
    /** 
     * Retrieve Danfe
     * Retrieve the Danfe 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    nfePrint(params: {  "authorization": string; "key": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling nfePrint");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling nfePrint");
        }
        const baseUrl = `/invoices/nfe/{key}`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceNFeDANFEApi - functional programming interface
 */
export const InvoiceNFeDANFEApiFp = {
    /** 
     * Retrieve Danfe
     * Retrieve the Danfe 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    nfePrint(params: { "authorization": string; "key": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InvoiceNFeDANFEApiFetchParamCreator.nfePrint(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceNFeDANFEApi - object-oriented interface
 */
export class InvoiceNFeDANFEApi extends BaseAPI {
    /** 
     * Retrieve Danfe
     * Retrieve the Danfe 
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    nfePrint(params: {  "authorization": string; "key": string; }, options?: any) {
        return InvoiceNFeDANFEApiFp.nfePrint(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceNFeDANFEApi - factory interface
 */
export const InvoiceNFeDANFEApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve Danfe
         * Retrieve the Danfe 
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         */
        nfePrint(params: {  "authorization": string; "key": string; }, options?: any) {
            return InvoiceNFeDANFEApiFp.nfePrint(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceSEFAZApi - fetch parameter creator
 */
export const InvoiceSEFAZApiFetchParamCreator = {
    /** 
     * Disable Range e-Invoice
     * Send disable range of NFes to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Disable Range e-Invoice
     */
    invoicesSefazDelete(params: {  "authorization": string; "body": SefazDisableRangeIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazDelete");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling invoicesSefazDelete");
        }
        const baseUrl = `/invoices/sefaz`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Cancel invoice
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    invoicesSefazKeyDelete(params: {  "authorization": string; "key": string; "body": SefazItDeleteIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazKeyDelete");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling invoicesSefazKeyDelete");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling invoicesSefazKeyDelete");
        }
        const baseUrl = `/invoices/sefaz/{key}`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyGet(params: {  "authorization": string; "key": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazKeyGet");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling invoicesSefazKeyGet");
        }
        const baseUrl = `/invoices/sefaz/{key}`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyLookupGet(params: {  "authorization": string; "key": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazKeyLookupGet");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling invoicesSefazKeyLookupGet");
        }
        const baseUrl = `/invoices/sefaz/{key}/lookup`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Fix Letter
     * Fix Letter
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Fix Message
     */
    invoicesSefazKeyPut(params: {  "authorization": string; "key": string; "body": SefazItPutIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazKeyPut");
        }
        // verify required parameter "key" is set
        if (params["key"] == null) {
            throw new Error("Missing required parameter key when calling invoicesSefazKeyPut");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling invoicesSefazKeyPut");
        }
        const baseUrl = `/invoices/sefaz/{key}`
            .replace(`{${"key"}}`, `${ params["key"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Send an e-Invoice
     * Send a invoice to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    invoicesSefazPost(params: {  "authorization": string; "body": Array<TransactionForSefazGoods>; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling invoicesSefazPost");
        }
        const baseUrl = `/invoices/sefaz`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve Status of SEFAZ Server
     * Retrieve Status of SEFAZ Server
     * @param authorization Bearer {auth}
     */
    invoicesSefazStatusGet(params: {  "authorization": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling invoicesSefazStatusGet");
        }
        const baseUrl = `/invoices/sefaz/status`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceSEFAZApi - functional programming interface
 */
export const InvoiceSEFAZApiFp = {
    /** 
     * Disable Range e-Invoice
     * Send disable range of NFes to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Disable Range e-Invoice
     */
    invoicesSefazDelete(params: { "authorization": string; "body": SefazDisableRangeIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SefazInvoiceBasicStatus> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Cancel invoice
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    invoicesSefazKeyDelete(params: { "authorization": string; "key": string; "body": SefazItDeleteIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SefazInvoiceBasicStatus> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazKeyDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyGet(params: { "authorization": string; "key": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SefazItGetOut> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazKeyGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyLookupGet(params: { "authorization": string; "key": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<TransactionForSefazGoodsList> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazKeyLookupGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Fix Letter
     * Fix Letter
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Fix Message
     */
    invoicesSefazKeyPut(params: { "authorization": string; "key": string; "body": SefazItPutIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SefazInvoiceBasicStatus> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazKeyPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Send an e-Invoice
     * Send a invoice to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    invoicesSefazPost(params: { "authorization": string; "body": Array<TransactionForSefazGoods>;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SefazPostOut> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve Status of SEFAZ Server
     * Retrieve Status of SEFAZ Server
     * @param authorization Bearer {auth}
     */
    invoicesSefazStatusGet(params: { "authorization": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = InvoiceSEFAZApiFetchParamCreator.invoicesSefazStatusGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceSEFAZApi - object-oriented interface
 */
export class InvoiceSEFAZApi extends BaseAPI {
    /** 
     * Disable Range e-Invoice
     * Send disable range of NFes to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Disable Range e-Invoice
     */
    invoicesSefazDelete(params: {  "authorization": string; "body": SefazDisableRangeIn; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Cancel invoice
     * Cancel the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Cancel Message
     */
    invoicesSefazKeyDelete(params: {  "authorization": string; "key": string; "body": SefazItDeleteIn; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazKeyDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyGet(params: {  "authorization": string; "key": string; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazKeyGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve invoice
     * Retrieve the invoice
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     */
    invoicesSefazKeyLookupGet(params: {  "authorization": string; "key": string; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazKeyLookupGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Fix Letter
     * Fix Letter
     * @param authorization Bearer {auth}
     * @param key Invoice Key
     * @param body Fix Message
     */
    invoicesSefazKeyPut(params: {  "authorization": string; "key": string; "body": SefazItPutIn; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazKeyPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Send an e-Invoice
     * Send a invoice to SEFAZ 
     * @param authorization Bearer {auth}
     * @param body Invoices
     */
    invoicesSefazPost(params: {  "authorization": string; "body": Array<TransactionForSefazGoods>; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve Status of SEFAZ Server
     * Retrieve Status of SEFAZ Server
     * @param authorization Bearer {auth}
     */
    invoicesSefazStatusGet(params: {  "authorization": string; }, options?: any) {
        return InvoiceSEFAZApiFp.invoicesSefazStatusGet(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceSEFAZApi - factory interface
 */
export const InvoiceSEFAZApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Disable Range e-Invoice
         * Send disable range of NFes to SEFAZ 
         * @param authorization Bearer {auth}
         * @param body Disable Range e-Invoice
         */
        invoicesSefazDelete(params: {  "authorization": string; "body": SefazDisableRangeIn; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazDelete(params, options)(fetch, basePath);
        },
        /** 
         * Cancel invoice
         * Cancel the invoice
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         * @param body Cancel Message
         */
        invoicesSefazKeyDelete(params: {  "authorization": string; "key": string; "body": SefazItDeleteIn; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazKeyDelete(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve invoice
         * Retrieve the invoice
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         */
        invoicesSefazKeyGet(params: {  "authorization": string; "key": string; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazKeyGet(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve invoice
         * Retrieve the invoice
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         */
        invoicesSefazKeyLookupGet(params: {  "authorization": string; "key": string; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazKeyLookupGet(params, options)(fetch, basePath);
        },
        /** 
         * Fix Letter
         * Fix Letter
         * @param authorization Bearer {auth}
         * @param key Invoice Key
         * @param body Fix Message
         */
        invoicesSefazKeyPut(params: {  "authorization": string; "key": string; "body": SefazItPutIn; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazKeyPut(params, options)(fetch, basePath);
        },
        /** 
         * Send an e-Invoice
         * Send a invoice to SEFAZ 
         * @param authorization Bearer {auth}
         * @param body Invoices
         */
        invoicesSefazPost(params: {  "authorization": string; "body": Array<TransactionForSefazGoods>; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazPost(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve Status of SEFAZ Server
         * Retrieve Status of SEFAZ Server
         * @param authorization Bearer {auth}
         */
        invoicesSefazStatusGet(params: {  "authorization": string; }, options?: any) {
            return InvoiceSEFAZApiFp.invoicesSefazStatusGet(params, options)(fetch, basePath);
        },
    };
};


/**
 * InvoiceSettingsApi - fetch parameter creator
 */
export const InvoiceSettingsApiFetchParamCreator = {
    /** 
     * Invoice Settigns
     * Get Enviroment Settigns
     */
    invoiceSettings(options?: any): FetchArgs {
        const baseUrl = `/invoices/settings`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InvoiceSettingsApi - functional programming interface
 */
export const InvoiceSettingsApiFp = {
    /** 
     * Invoice Settigns
     * Get Enviroment Settigns
     */
    invoiceSettings(options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = InvoiceSettingsApiFetchParamCreator.invoiceSettings(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InvoiceSettingsApi - object-oriented interface
 */
export class InvoiceSettingsApi extends BaseAPI {
    /** 
     * Invoice Settigns
     * Get Enviroment Settigns
     */
    invoiceSettings(options?: any) {
        return InvoiceSettingsApiFp.invoiceSettings(options)(this.fetch, this.basePath);
    }
};

/**
 * InvoiceSettingsApi - factory interface
 */
export const InvoiceSettingsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Invoice Settigns
         * Get Enviroment Settigns
         */
        invoiceSettings(options?: any) {
            return InvoiceSettingsApiFp.invoiceSettings(options)(fetch, basePath);
        },
    };
};


/**
 * LegalReasonApi - fetch parameter creator
 */
export const LegalReasonApiFetchParamCreator = {
    /** 
     * Create Legal Reason.
     * @param body 
     */
    createReason_(params: {  "body": LegalReason; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createReason_");
        }
        const baseUrl = `/taxconf/legal-reason`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a Legal Reason entry.
     * @param uuid 
     */
    deleteReason_(params: {  "uuid": string; }, options?: any): FetchArgs {
        // verify required parameter "uuid" is set
        if (params["uuid"] == null) {
            throw new Error("Missing required parameter uuid when calling deleteReason_");
        }
        const baseUrl = `/taxconf/legal-reason/{uuid}`
            .replace(`{${"uuid"}}`, `${ params["uuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get single Legal Reason.
     * @param uuid 
     */
    getReason_(params: {  "uuid": string; }, options?: any): FetchArgs {
        // verify required parameter "uuid" is set
        if (params["uuid"] == null) {
            throw new Error("Missing required parameter uuid when calling getReason_");
        }
        const baseUrl = `/taxconf/legal-reason/{uuid}`
            .replace(`{${"uuid"}}`, `${ params["uuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * List Legal Reasons.
     * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
     */
    listReason(params: {  "companyId"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/taxconf/legal-reason`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "companyId": params["companyId"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update Legal Reason.
     * @param body 
     */
    updateReason_(params: {  "body": LegalReason; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateReason_");
        }
        const baseUrl = `/taxconf/legal-reason`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LegalReasonApi - functional programming interface
 */
export const LegalReasonApiFp = {
    /** 
     * Create Legal Reason.
     * @param body 
     */
    createReason_(params: { "body": LegalReason;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = LegalReasonApiFetchParamCreator.createReason_(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a Legal Reason entry.
     * @param uuid 
     */
    deleteReason_(params: { "uuid": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LegalReasonApiFetchParamCreator.deleteReason_(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get single Legal Reason.
     * @param uuid 
     */
    getReason_(params: { "uuid": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ProcessScenario> {
        const fetchArgs = LegalReasonApiFetchParamCreator.getReason_(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * List Legal Reasons.
     * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
     */
    listReason(params: { "companyId"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<LegalReason>> {
        const fetchArgs = LegalReasonApiFetchParamCreator.listReason(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update Legal Reason.
     * @param body 
     */
    updateReason_(params: { "body": LegalReason;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = LegalReasonApiFetchParamCreator.updateReason_(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LegalReasonApi - object-oriented interface
 */
export class LegalReasonApi extends BaseAPI {
    /** 
     * Create Legal Reason.
     * @param body 
     */
    createReason_(params: {  "body": LegalReason; }, options?: any) {
        return LegalReasonApiFp.createReason_(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a Legal Reason entry.
     * @param uuid 
     */
    deleteReason_(params: {  "uuid": string; }, options?: any) {
        return LegalReasonApiFp.deleteReason_(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get single Legal Reason.
     * @param uuid 
     */
    getReason_(params: {  "uuid": string; }, options?: any) {
        return LegalReasonApiFp.getReason_(params, options)(this.fetch, this.basePath);
    }
    /** 
     * List Legal Reasons.
     * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
     */
    listReason(params: {  "companyId"?: string; }, options?: any) {
        return LegalReasonApiFp.listReason(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update Legal Reason.
     * @param body 
     */
    updateReason_(params: {  "body": LegalReason; }, options?: any) {
        return LegalReasonApiFp.updateReason_(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LegalReasonApi - factory interface
 */
export const LegalReasonApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Create Legal Reason.
         * @param body 
         */
        createReason_(params: {  "body": LegalReason; }, options?: any) {
            return LegalReasonApiFp.createReason_(params, options)(fetch, basePath);
        },
        /** 
         * Delete a Legal Reason entry.
         * @param uuid 
         */
        deleteReason_(params: {  "uuid": string; }, options?: any) {
            return LegalReasonApiFp.deleteReason_(params, options)(fetch, basePath);
        },
        /** 
         * Get single Legal Reason.
         * @param uuid 
         */
        getReason_(params: {  "uuid": string; }, options?: any) {
            return LegalReasonApiFp.getReason_(params, options)(fetch, basePath);
        },
        /** 
         * List Legal Reasons.
         * @param companyId Filters by company domain entries. Provide \&quot;global\&quot; to retrive only \&quot;global\&quot; entries. CompanyId searches also match global entries. 
         */
        listReason(params: {  "companyId"?: string; }, options?: any) {
            return LegalReasonApiFp.listReason(params, options)(fetch, basePath);
        },
        /** 
         * Update Legal Reason.
         * @param body 
         */
        updateReason_(params: {  "body": LegalReason; }, options?: any) {
            return LegalReasonApiFp.updateReason_(params, options)(fetch, basePath);
        },
    };
};


/**
 * ServiceCalculationsApi - fetch parameter creator
 */
export const ServiceCalculationsApiFetchParamCreator = {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "documentCode" is set
        if (params["documentCode"] == null) {
            throw new Error("Missing required parameter documentCode when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        const baseUrl = `/calculations/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`)
            .replace(`{${"documentCode"}}`, `${ params["documentCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Promote a calculation to transaction
     * Promote a calculation to transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost");
        }
        // verify required parameter "documentCode" is set
        if (params["documentCode"] == null) {
            throw new Error("Missing required parameter documentCode when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost");
        }
        const baseUrl = `/calculations/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}/transactions`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`)
            .replace(`{${"documentCode"}}`, `${ params["documentCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        const baseUrl = `/calculations/account/{accountId}/company/{companyCode}/{transactionType}`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsservicePaymentPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsservicePaymentPost");
        }
        const baseUrl = `/calculations?service-payment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsservicePurchasePost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsservicePurchasePost");
        }
        const baseUrl = `/calculations?service-purchase`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsserviceReceiptPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsserviceReceiptPost");
        }
        const baseUrl = `/calculations?service-receipt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling calculationsserviceSalesPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling calculationsserviceSalesPost");
        }
        const baseUrl = `/calculations?service-sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ServiceCalculationsApi - functional programming interface
 */
export const ServiceCalculationsApiFp = {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Promote a calculation to transaction
     * Promote a calculation to transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePaymentPost(params: { "authorization": string; "body": PaymentTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<PaymentTransactionOut> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsservicePaymentPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePurchasePost(params: { "authorization": string; "body": PurchaseTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<PurchaseTransactionOut> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsservicePurchasePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceReceiptPost(params: { "authorization": string; "body": ReceiptTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ReceiptTransactionOut> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsserviceReceiptPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceSalesPost(params: { "authorization": string; "body": SalesTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SalesTransactionOut> {
        const fetchArgs = ServiceCalculationsApiFetchParamCreator.calculationsserviceSalesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ServiceCalculationsApi - object-oriented interface
 */
export class ServiceCalculationsApi extends BaseAPI {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Promote a calculation to transaction
     * Promote a calculation to transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsservicePaymentPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsservicePurchasePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsserviceReceiptPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    calculationsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any) {
        return ServiceCalculationsApiFp.calculationsserviceSalesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ServiceCalculationsApi - factory interface
 */
export const ServiceCalculationsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve transactions
         * Retrieve a single transaction
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         * @param documentCode Document Code
         */
        calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * Promote a calculation to transaction
         * Promote a calculation to transaction
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         * @param documentCode Document Code
         */
        calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeTransactionsPost(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve transactions
         * Retrieve a list of transactions
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         */
        calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsservicePaymentPost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsservicePurchasePost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsserviceReceiptPost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned. Accept all transactions type (Sale, Purchase, Payment and Receipt), the format and message type are desbribed above in each &#39;calculations-&lt;type&gt;&#39;.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        calculationsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any) {
            return ServiceCalculationsApiFp.calculationsserviceSalesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * ServiceTransactionsApi - fetch parameter creator
 */
export const ServiceTransactionsApiFetchParamCreator = {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        // verify required parameter "documentCode" is set
        if (params["documentCode"] == null) {
            throw new Error("Missing required parameter documentCode when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet");
        }
        const baseUrl = `/transactions/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`)
            .replace(`{${"documentCode"}}`, `${ params["documentCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Transaction State Transition
     * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     * @param body Transaction Message
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; "body": StateTransition; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        // verify required parameter "documentCode" is set
        if (params["documentCode"] == null) {
            throw new Error("Missing required parameter documentCode when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost");
        }
        const baseUrl = `/transactions/account/{accountId}/company/{companyCode}/{transactionType}/{documentCode}/stateTransitions`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`)
            .replace(`{${"documentCode"}}`, `${ params["documentCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "accountId" is set
        if (params["accountId"] == null) {
            throw new Error("Missing required parameter accountId when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "companyCode" is set
        if (params["companyCode"] == null) {
            throw new Error("Missing required parameter companyCode when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        // verify required parameter "transactionType" is set
        if (params["transactionType"] == null) {
            throw new Error("Missing required parameter transactionType when calling transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet");
        }
        const baseUrl = `/transactions/account/{accountId}/company/{companyCode}/{transactionType}`
            .replace(`{${"accountId"}}`, `${ params["accountId"] }`)
            .replace(`{${"companyCode"}}`, `${ params["companyCode"] }`)
            .replace(`{${"transactionType"}}`, `${ params["transactionType"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsservicePaymentPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsservicePaymentPost");
        }
        const baseUrl = `/transactions?service-payment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsservicePurchasePost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsservicePurchasePost");
        }
        const baseUrl = `/transactions?service-purchase`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsserviceReceiptPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsserviceReceiptPost");
        }
        const baseUrl = `/transactions?service-receipt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any): FetchArgs {
        // verify required parameter "authorization" is set
        if (params["authorization"] == null) {
            throw new Error("Missing required parameter authorization when calling transactionsserviceSalesPost");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling transactionsserviceSalesPost");
        }
        const baseUrl = `/transactions?service-sales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Authorization": params["authorization"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ServiceTransactionsApi - functional programming interface
 */
export const ServiceTransactionsApiFp = {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Transaction State Transition
     * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     * @param body Transaction Message
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; "body": StateTransition;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: { "authorization": string; "accountId": string; "companyCode": string; "transactionType": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePaymentPost(params: { "authorization": string; "body": PaymentTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<PaymentTransactionOut> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsservicePaymentPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePurchasePost(params: { "authorization": string; "body": PurchaseTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<PurchaseTransactionOut> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsservicePurchasePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceReceiptPost(params: { "authorization": string; "body": ReceiptTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ReceiptTransactionOut> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsserviceReceiptPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceSalesPost(params: { "authorization": string; "body": SalesTransactionIn;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<SalesTransactionOut> {
        const fetchArgs = ServiceTransactionsApiFetchParamCreator.transactionsserviceSalesPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ServiceTransactionsApi - object-oriented interface
 */
export class ServiceTransactionsApi extends BaseAPI {
    /** 
     * Retrieve transactions
     * Retrieve a single transaction
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Transaction State Transition
     * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     * @param documentCode Document Code
     * @param body Transaction Message
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; "body": StateTransition; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve transactions
     * Retrieve a list of transactions
     * @param authorization Bearer {auth}
     * @param accountId Account ID
     * @param companyCode Company Code
     * @param transactionType Transaction Type (sale, purchase, receipts or payment)
     */
    transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsservicePaymentPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsservicePurchasePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsserviceReceiptPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Calculation Method
     * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
     * @param authorization Bearer {auth}
     * @param body Transaction Message
     */
    transactionsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any) {
        return ServiceTransactionsApiFp.transactionsserviceSalesPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ServiceTransactionsApi - factory interface
 */
export const ServiceTransactionsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve transactions
         * Retrieve a single transaction
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         * @param documentCode Document Code
         */
        transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * Transaction State Transition
         * Transaction State Transition Voided  Send this event to a Recorded tax transaction record to mark it as voided.  Recorded -&gt; Voided UnVoided  Send this event to a Voided tax transaction record to mark it as recorded.  Voided -&gt; Recorded Reconciled  Send this event to a Recorded tax transaction record to indicate that it has been reconciled with client systems and to prevent it from being edited prior to filing. This is useful when a transaction will be filed and you do not want it to change again to facilitate auditing and reconciliation. Recorded -&gt; Reconciled UnReconciled  Send this event to a Reconciled tax transaction record to indicate that it has not been reconciled and may need to be edited. This is useful when a Tax transaction was erroniously put into the reconciled state.  Reconciled -&gt; Recorded Filed Send this event to a Reconciled transaction to indicate that it has been part of a tax filing by the client system. Reconciled -&gt; Filed UnFiled Send this event to a Filed transaction to indicate that it has NOT been part of a tax filing by the client system.  Filed -&gt; Reconciled FiledByAvalara  This event can only be sent by Avalara Systems. Reconciled -&gt; FiledByAvalara 
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         * @param documentCode Document Code
         * @param body Transaction Message
         */
        transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; "documentCode": string; "body": StateTransition; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeDocumentCodeStateTransitionsPost(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve transactions
         * Retrieve a list of transactions
         * @param authorization Bearer {auth}
         * @param accountId Account ID
         * @param companyCode Company Code
         * @param transactionType Transaction Type (sale, purchase, receipts or payment)
         */
        transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params: {  "authorization": string; "accountId": string; "companyCode": string; "transactionType": string; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsAccountAccountIdCompanyCompanyCodeTransactionTypeGet(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsservicePaymentPost(params: {  "authorization": string; "body": PaymentTransactionIn; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsservicePaymentPost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsservicePurchasePost(params: {  "authorization": string; "body": PurchaseTransactionIn; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsservicePurchasePost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsserviceReceiptPost(params: {  "authorization": string; "body": ReceiptTransactionIn; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsserviceReceiptPost(params, options)(fetch, basePath);
        },
        /** 
         * Calculation Method
         * Refer to the business rules below, for an outline view of Tax Determination Process as a whole, showing a beginning-to-end process making use of the specific UseCases and discriminating all required attributes and data to be returned.
         * @param authorization Bearer {auth}
         * @param body Transaction Message
         */
        transactionsserviceSalesPost(params: {  "authorization": string; "body": SalesTransactionIn; }, options?: any) {
            return ServiceTransactionsApiFp.transactionsserviceSalesPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxConfCFOPApi - fetch parameter creator
 */
export const TaxConfCFOPApiFetchParamCreator = {
    /** 
     * create a new CFOP configuration
     * @param body The pet JSON you want to post
     */
    createCfop(params: {  "body": CfopConf; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createCfop");
        }
        const baseUrl = `/taxconf/cfop`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * disable a CFOP.
     * @param code CFOP Code
     */
    deleteCfop(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteCfop");
        }
        const baseUrl = `/taxconf/cfop/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get CFOP information.
     * This operation return CFOP configuration 
     * @param code CFOP Code
     */
    getCfop(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getCfop");
        }
        const baseUrl = `/taxconf/cfop/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of CFOP.
     * This operation return CFOP configurations that match with parameters queries 
     * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getCfopList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/taxconf/cfop`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "suffixcode": params["suffixcode"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * update a CFOP configuration
     * @param code CFOP Code
     * @param taxconfcfop The pet JSON you want to post
     */
    updateCfop(params: {  "code": string; "taxconfcfop": CfopConf; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateCfop");
        }
        // verify required parameter "taxconfcfop" is set
        if (params["taxconfcfop"] == null) {
            throw new Error("Missing required parameter taxconfcfop when calling updateCfop");
        }
        const baseUrl = `/taxconf/cfop/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxconfcfop"]) {
            fetchOptions.body = JSON.stringify(params["taxconfcfop"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxConfCFOPApi - functional programming interface
 */
export const TaxConfCFOPApiFp = {
    /** 
     * create a new CFOP configuration
     * @param body The pet JSON you want to post
     */
    createCfop(params: { "body": CfopConf;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = TaxConfCFOPApiFetchParamCreator.createCfop(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * disable a CFOP.
     * @param code CFOP Code
     */
    deleteCfop(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfCFOPApiFetchParamCreator.deleteCfop(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get CFOP information.
     * This operation return CFOP configuration 
     * @param code CFOP Code
     */
    getCfop(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<CfopConf> {
        const fetchArgs = TaxConfCFOPApiFetchParamCreator.getCfop(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of CFOP.
     * This operation return CFOP configurations that match with parameters queries 
     * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getCfopList(params: { "suffixcode"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<CfopConf>> {
        const fetchArgs = TaxConfCFOPApiFetchParamCreator.getCfopList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * update a CFOP configuration
     * @param code CFOP Code
     * @param taxconfcfop The pet JSON you want to post
     */
    updateCfop(params: { "code": string; "taxconfcfop": CfopConf;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfCFOPApiFetchParamCreator.updateCfop(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxConfCFOPApi - object-oriented interface
 */
export class TaxConfCFOPApi extends BaseAPI {
    /** 
     * create a new CFOP configuration
     * @param body The pet JSON you want to post
     */
    createCfop(params: {  "body": CfopConf; }, options?: any) {
        return TaxConfCFOPApiFp.createCfop(params, options)(this.fetch, this.basePath);
    }
    /** 
     * disable a CFOP.
     * @param code CFOP Code
     */
    deleteCfop(params: {  "code": string; }, options?: any) {
        return TaxConfCFOPApiFp.deleteCfop(params, options)(this.fetch, this.basePath);
    }
    /** 
     * get CFOP information.
     * This operation return CFOP configuration 
     * @param code CFOP Code
     */
    getCfop(params: {  "code": string; }, options?: any) {
        return TaxConfCFOPApiFp.getCfop(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of CFOP.
     * This operation return CFOP configurations that match with parameters queries 
     * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getCfopList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfCFOPApiFp.getCfopList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * update a CFOP configuration
     * @param code CFOP Code
     * @param taxconfcfop The pet JSON you want to post
     */
    updateCfop(params: {  "code": string; "taxconfcfop": CfopConf; }, options?: any) {
        return TaxConfCFOPApiFp.updateCfop(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxConfCFOPApi - factory interface
 */
export const TaxConfCFOPApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * create a new CFOP configuration
         * @param body The pet JSON you want to post
         */
        createCfop(params: {  "body": CfopConf; }, options?: any) {
            return TaxConfCFOPApiFp.createCfop(params, options)(fetch, basePath);
        },
        /** 
         * disable a CFOP.
         * @param code CFOP Code
         */
        deleteCfop(params: {  "code": string; }, options?: any) {
            return TaxConfCFOPApiFp.deleteCfop(params, options)(fetch, basePath);
        },
        /** 
         * get CFOP information.
         * This operation return CFOP configuration 
         * @param code CFOP Code
         */
        getCfop(params: {  "code": string; }, options?: any) {
            return TaxConfCFOPApiFp.getCfop(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of CFOP.
         * This operation return CFOP configurations that match with parameters queries 
         * @param suffixcode Identify this CFOP, the CFOP Code has two parts N.XXX where N the prefix is the operation scope type if IN or OUT and if is in state, other state, other country and suffix XXX is the operation type 
         * @param date When informed return valid version configuration for this date 
         * @param inactive return the inactive versions too 
         */
        getCfopList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfCFOPApiFp.getCfopList(params, options)(fetch, basePath);
        },
        /** 
         * update a CFOP configuration
         * @param code CFOP Code
         * @param taxconfcfop The pet JSON you want to post
         */
        updateCfop(params: {  "code": string; "taxconfcfop": CfopConf; }, options?: any) {
            return TaxConfCFOPApiFp.updateCfop(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxConfIBPTApi - fetch parameter creator
 */
export const TaxConfIBPTApiFetchParamCreator = {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createIbptConf(params: {  "taxconfprocess": IbptConf; }, options?: any): FetchArgs {
        // verify required parameter "taxconfprocess" is set
        if (params["taxconfprocess"] == null) {
            throw new Error("Missing required parameter taxconfprocess when calling createIbptConf");
        }
        const baseUrl = `/taxconf/ibpt`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxconfprocess"]) {
            fetchOptions.body = JSON.stringify(params["taxconfprocess"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * disable a IBPT.
     * @param code IBPT Code
     */
    deleteIbptConf(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteIbptConf");
        }
        const baseUrl = `/taxconf/ibpt/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get IBPT information.
     * This operation return Process Type configuration 
     * @param code IBPT Code
     */
    getIbptConf(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getIbptConf");
        }
        const baseUrl = `/taxconf/ibpt/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of IBPT.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIbptConfList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/taxconf/ibpt`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "accountId": params["accountId"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * update a Process Type configuration
     * @param code IBPT Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateIbptConf(params: {  "code": string; "taxconfprocess": IbptConf; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateIbptConf");
        }
        // verify required parameter "taxconfprocess" is set
        if (params["taxconfprocess"] == null) {
            throw new Error("Missing required parameter taxconfprocess when calling updateIbptConf");
        }
        const baseUrl = `/taxconf/ibpt/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxconfprocess"]) {
            fetchOptions.body = JSON.stringify(params["taxconfprocess"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxConfIBPTApi - functional programming interface
 */
export const TaxConfIBPTApiFp = {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createIbptConf(params: { "taxconfprocess": IbptConf;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = TaxConfIBPTApiFetchParamCreator.createIbptConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * disable a IBPT.
     * @param code IBPT Code
     */
    deleteIbptConf(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfIBPTApiFetchParamCreator.deleteIbptConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get IBPT information.
     * This operation return Process Type configuration 
     * @param code IBPT Code
     */
    getIbptConf(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<IbptConf> {
        const fetchArgs = TaxConfIBPTApiFetchParamCreator.getIbptConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of IBPT.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIbptConfList(params: { "accountId"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IbptConf>> {
        const fetchArgs = TaxConfIBPTApiFetchParamCreator.getIbptConfList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * update a Process Type configuration
     * @param code IBPT Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateIbptConf(params: { "code": string; "taxconfprocess": IbptConf;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfIBPTApiFetchParamCreator.updateIbptConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxConfIBPTApi - object-oriented interface
 */
export class TaxConfIBPTApi extends BaseAPI {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createIbptConf(params: {  "taxconfprocess": IbptConf; }, options?: any) {
        return TaxConfIBPTApiFp.createIbptConf(params, options)(this.fetch, this.basePath);
    }
    /** 
     * disable a IBPT.
     * @param code IBPT Code
     */
    deleteIbptConf(params: {  "code": string; }, options?: any) {
        return TaxConfIBPTApiFp.deleteIbptConf(params, options)(this.fetch, this.basePath);
    }
    /** 
     * get IBPT information.
     * This operation return Process Type configuration 
     * @param code IBPT Code
     */
    getIbptConf(params: {  "code": string; }, options?: any) {
        return TaxConfIBPTApiFp.getIbptConf(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of IBPT.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIbptConfList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfIBPTApiFp.getIbptConfList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * update a Process Type configuration
     * @param code IBPT Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateIbptConf(params: {  "code": string; "taxconfprocess": IbptConf; }, options?: any) {
        return TaxConfIBPTApiFp.updateIbptConf(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxConfIBPTApi - factory interface
 */
export const TaxConfIBPTApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * create a new Process Type configuration
         * @param taxconfprocess The pet JSON you want to post
         */
        createIbptConf(params: {  "taxconfprocess": IbptConf; }, options?: any) {
            return TaxConfIBPTApiFp.createIbptConf(params, options)(fetch, basePath);
        },
        /** 
         * disable a IBPT.
         * @param code IBPT Code
         */
        deleteIbptConf(params: {  "code": string; }, options?: any) {
            return TaxConfIBPTApiFp.deleteIbptConf(params, options)(fetch, basePath);
        },
        /** 
         * get IBPT information.
         * This operation return Process Type configuration 
         * @param code IBPT Code
         */
        getIbptConf(params: {  "code": string; }, options?: any) {
            return TaxConfIBPTApiFp.getIbptConf(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of IBPT.
         * This operation return Process Type configurations that match with parameters queries 
         * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
         * @param date When informed return valid version configuration for this date 
         * @param inactive return the inactive versions too 
         */
        getIbptConfList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfIBPTApiFp.getIbptConfList(params, options)(fetch, basePath);
        },
        /** 
         * update a Process Type configuration
         * @param code IBPT Code
         * @param taxconfprocess The pet JSON you want to post
         */
        updateIbptConf(params: {  "code": string; "taxconfprocess": IbptConf; }, options?: any) {
            return TaxConfIBPTApiFp.updateIbptConf(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxConfICMSApi - fetch parameter creator
 */
export const TaxConfICMSApiFetchParamCreator = {
    /** 
     * create a new ICMS Configuration
     * @param state Brazilian State
     * @param icmsConfState The pet JSON you want to post
     */
    createIcmsconfstate(params: {  "state": string; "icmsConfState": IcmsConfByState; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling createIcmsconfstate");
        }
        // verify required parameter "icmsConfState" is set
        if (params["icmsConfState"] == null) {
            throw new Error("Missing required parameter icmsConfState when calling createIcmsconfstate");
        }
        const baseUrl = `/taxconf/icms/{state}`
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["icmsConfState"]) {
            fetchOptions.body = JSON.stringify(params["icmsConfState"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * disable a ICMS by State.
     * @param state Brazilian State
     * @param code ICMS Code
     */
    deleteIcmsConf(params: {  "state": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling deleteIcmsConf");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteIcmsConf");
        }
        const baseUrl = `/taxconf/icms/{state}/{code}`
            .replace(`{${"state"}}`, `${ params["state"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get ICMS information by State.
     * This operation return configurations of icms that match with parameters queries 
     * @param state Brazilian State
     * @param code ICMS Code
     */
    getIcmsConfByState(params: {  "state": string; "code": string; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling getIcmsConfByState");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getIcmsConfByState");
        }
        const baseUrl = `/taxconf/icms/{state}/{code}`
            .replace(`{${"state"}}`, `${ params["state"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param state Brazilian State
     * @param suffixcode Identify this ICMS
     * @param date When informed return valid version configuration for this date
     * @param inactive return the inactive versions too
     */
    getIcmsList(params: {  "state": string; "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling getIcmsList");
        }
        const baseUrl = `/taxconf/icms/{state}`
            .replace(`{${"state"}}`, `${ params["state"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "suffixcode": params["suffixcode"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param text Search for codes
     * @param state Filter for states
     */
    getIcmsList_1(params: {  "text": string; "state"?: string; }, options?: any): FetchArgs {
        // verify required parameter "text" is set
        if (params["text"] == null) {
            throw new Error("Missing required parameter text when calling getIcmsList_1");
        }
        const baseUrl = `/taxconf/icms-search/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "text": params["text"],
            "state": params["state"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * update a IcmsConf State,
     * @param state Brazilian State
     * @param code ICMS Code
     * @param icmsConfState The pet JSON you want to post
     */
    updateIcmsconfstate(params: {  "state": string; "code": string; "icmsConfState": IcmsConfByState; }, options?: any): FetchArgs {
        // verify required parameter "state" is set
        if (params["state"] == null) {
            throw new Error("Missing required parameter state when calling updateIcmsconfstate");
        }
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateIcmsconfstate");
        }
        // verify required parameter "icmsConfState" is set
        if (params["icmsConfState"] == null) {
            throw new Error("Missing required parameter icmsConfState when calling updateIcmsconfstate");
        }
        const baseUrl = `/taxconf/icms/{state}/{code}`
            .replace(`{${"state"}}`, `${ params["state"] }`)
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["icmsConfState"]) {
            fetchOptions.body = JSON.stringify(params["icmsConfState"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxConfICMSApi - functional programming interface
 */
export const TaxConfICMSApiFp = {
    /** 
     * create a new ICMS Configuration
     * @param state Brazilian State
     * @param icmsConfState The pet JSON you want to post
     */
    createIcmsconfstate(params: { "state": string; "icmsConfState": IcmsConfByState;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.createIcmsconfstate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * disable a ICMS by State.
     * @param state Brazilian State
     * @param code ICMS Code
     */
    deleteIcmsConf(params: { "state": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.deleteIcmsConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get ICMS information by State.
     * This operation return configurations of icms that match with parameters queries 
     * @param state Brazilian State
     * @param code ICMS Code
     */
    getIcmsConfByState(params: { "state": string; "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IcmsConfByState>> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.getIcmsConfByState(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param state Brazilian State
     * @param suffixcode Identify this ICMS
     * @param date When informed return valid version configuration for this date
     * @param inactive return the inactive versions too
     */
    getIcmsList(params: { "state": string; "suffixcode"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IcmsConfByState>> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.getIcmsList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param text Search for codes
     * @param state Filter for states
     */
    getIcmsList_1(params: { "text": string; "state"?: string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IcmsConfByState>> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.getIcmsList_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * update a IcmsConf State,
     * @param state Brazilian State
     * @param code ICMS Code
     * @param icmsConfState The pet JSON you want to post
     */
    updateIcmsconfstate(params: { "state": string; "code": string; "icmsConfState": IcmsConfByState;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfICMSApiFetchParamCreator.updateIcmsconfstate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxConfICMSApi - object-oriented interface
 */
export class TaxConfICMSApi extends BaseAPI {
    /** 
     * create a new ICMS Configuration
     * @param state Brazilian State
     * @param icmsConfState The pet JSON you want to post
     */
    createIcmsconfstate(params: {  "state": string; "icmsConfState": IcmsConfByState; }, options?: any) {
        return TaxConfICMSApiFp.createIcmsconfstate(params, options)(this.fetch, this.basePath);
    }
    /** 
     * disable a ICMS by State.
     * @param state Brazilian State
     * @param code ICMS Code
     */
    deleteIcmsConf(params: {  "state": string; "code": string; }, options?: any) {
        return TaxConfICMSApiFp.deleteIcmsConf(params, options)(this.fetch, this.basePath);
    }
    /** 
     * get ICMS information by State.
     * This operation return configurations of icms that match with parameters queries 
     * @param state Brazilian State
     * @param code ICMS Code
     */
    getIcmsConfByState(params: {  "state": string; "code": string; }, options?: any) {
        return TaxConfICMSApiFp.getIcmsConfByState(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param state Brazilian State
     * @param suffixcode Identify this ICMS
     * @param date When informed return valid version configuration for this date
     * @param inactive return the inactive versions too
     */
    getIcmsList(params: {  "state": string; "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfICMSApiFp.getIcmsList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of ICMS.
     * This operation return ICMS configurations that match with parameters queries 
     * @param text Search for codes
     * @param state Filter for states
     */
    getIcmsList_1(params: {  "text": string; "state"?: string; }, options?: any) {
        return TaxConfICMSApiFp.getIcmsList_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * update a IcmsConf State,
     * @param state Brazilian State
     * @param code ICMS Code
     * @param icmsConfState The pet JSON you want to post
     */
    updateIcmsconfstate(params: {  "state": string; "code": string; "icmsConfState": IcmsConfByState; }, options?: any) {
        return TaxConfICMSApiFp.updateIcmsconfstate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxConfICMSApi - factory interface
 */
export const TaxConfICMSApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * create a new ICMS Configuration
         * @param state Brazilian State
         * @param icmsConfState The pet JSON you want to post
         */
        createIcmsconfstate(params: {  "state": string; "icmsConfState": IcmsConfByState; }, options?: any) {
            return TaxConfICMSApiFp.createIcmsconfstate(params, options)(fetch, basePath);
        },
        /** 
         * disable a ICMS by State.
         * @param state Brazilian State
         * @param code ICMS Code
         */
        deleteIcmsConf(params: {  "state": string; "code": string; }, options?: any) {
            return TaxConfICMSApiFp.deleteIcmsConf(params, options)(fetch, basePath);
        },
        /** 
         * get ICMS information by State.
         * This operation return configurations of icms that match with parameters queries 
         * @param state Brazilian State
         * @param code ICMS Code
         */
        getIcmsConfByState(params: {  "state": string; "code": string; }, options?: any) {
            return TaxConfICMSApiFp.getIcmsConfByState(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of ICMS.
         * This operation return ICMS configurations that match with parameters queries 
         * @param state Brazilian State
         * @param suffixcode Identify this ICMS
         * @param date When informed return valid version configuration for this date
         * @param inactive return the inactive versions too
         */
        getIcmsList(params: {  "state": string; "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfICMSApiFp.getIcmsList(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of ICMS.
         * This operation return ICMS configurations that match with parameters queries 
         * @param text Search for codes
         * @param state Filter for states
         */
        getIcmsList_1(params: {  "text": string; "state"?: string; }, options?: any) {
            return TaxConfICMSApiFp.getIcmsList_1(params, options)(fetch, basePath);
        },
        /** 
         * update a IcmsConf State,
         * @param state Brazilian State
         * @param code ICMS Code
         * @param icmsConfState The pet JSON you want to post
         */
        updateIcmsconfstate(params: {  "state": string; "code": string; "icmsConfState": IcmsConfByState; }, options?: any) {
            return TaxConfICMSApiFp.updateIcmsconfstate(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxConfISSApi - fetch parameter creator
 */
export const TaxConfISSApiFetchParamCreator = {
    /** 
     * create a new ISS Configuration
     * @param issConfByCity The pet JSON you want to post
     */
    createIssConfByCity(params: {  "issConfByCity": IssConfByCity; }, options?: any): FetchArgs {
        // verify required parameter "issConfByCity" is set
        if (params["issConfByCity"] == null) {
            throw new Error("Missing required parameter issConfByCity when calling createIssConfByCity");
        }
        const baseUrl = `/taxconf/iss`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["issConfByCity"]) {
            fetchOptions.body = JSON.stringify(params["issConfByCity"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * disable a ISS by City Code.
     * @param cityCode City Code
     */
    deleteIssConf(params: {  "cityCode": number; }, options?: any): FetchArgs {
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling deleteIssConf");
        }
        const baseUrl = `/taxconf/iss/{cityCode}`
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get ISS information by City Code.
     * This operation return configurations of ISS that match with parameters queries 
     * @param cityCode City Code
     * @param code Identificator of this configuration, it is unique for account or standard namedspace 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inctives versions too 
     */
    getIssConfByCity(params: {  "cityCode": number; "code"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling getIssConfByCity");
        }
        const baseUrl = `/taxconf/iss/{cityCode}`
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "code": params["code"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of ISS
     * This operation return ISS configurations that match with parameters queries 
     * @param suffixcode Identify this ISS 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIssList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/taxconf/iss`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "suffixcode": params["suffixcode"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * update a ISS by City Code.
     * @param cityCode City Code
     * @param issConfByCity The pet JSON you want to post
     */
    updateIssConfByCity(params: {  "cityCode": number; "issConfByCity": IssConfByCity; }, options?: any): FetchArgs {
        // verify required parameter "cityCode" is set
        if (params["cityCode"] == null) {
            throw new Error("Missing required parameter cityCode when calling updateIssConfByCity");
        }
        // verify required parameter "issConfByCity" is set
        if (params["issConfByCity"] == null) {
            throw new Error("Missing required parameter issConfByCity when calling updateIssConfByCity");
        }
        const baseUrl = `/taxconf/iss/{cityCode}`
            .replace(`{${"cityCode"}}`, `${ params["cityCode"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["issConfByCity"]) {
            fetchOptions.body = JSON.stringify(params["issConfByCity"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxConfISSApi - functional programming interface
 */
export const TaxConfISSApiFp = {
    /** 
     * create a new ISS Configuration
     * @param issConfByCity The pet JSON you want to post
     */
    createIssConfByCity(params: { "issConfByCity": IssConfByCity;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = TaxConfISSApiFetchParamCreator.createIssConfByCity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * disable a ISS by City Code.
     * @param cityCode City Code
     */
    deleteIssConf(params: { "cityCode": number;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfISSApiFetchParamCreator.deleteIssConf(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get ISS information by City Code.
     * This operation return configurations of ISS that match with parameters queries 
     * @param cityCode City Code
     * @param code Identificator of this configuration, it is unique for account or standard namedspace 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inctives versions too 
     */
    getIssConfByCity(params: { "cityCode": number; "code"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IssConfByCity>> {
        const fetchArgs = TaxConfISSApiFetchParamCreator.getIssConfByCity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of ISS
     * This operation return ISS configurations that match with parameters queries 
     * @param suffixcode Identify this ISS 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIssList(params: { "suffixcode"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<IssConfByCity>> {
        const fetchArgs = TaxConfISSApiFetchParamCreator.getIssList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * update a ISS by City Code.
     * @param cityCode City Code
     * @param issConfByCity The pet JSON you want to post
     */
    updateIssConfByCity(params: { "cityCode": number; "issConfByCity": IssConfByCity;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfISSApiFetchParamCreator.updateIssConfByCity(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxConfISSApi - object-oriented interface
 */
export class TaxConfISSApi extends BaseAPI {
    /** 
     * create a new ISS Configuration
     * @param issConfByCity The pet JSON you want to post
     */
    createIssConfByCity(params: {  "issConfByCity": IssConfByCity; }, options?: any) {
        return TaxConfISSApiFp.createIssConfByCity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * disable a ISS by City Code.
     * @param cityCode City Code
     */
    deleteIssConf(params: {  "cityCode": number; }, options?: any) {
        return TaxConfISSApiFp.deleteIssConf(params, options)(this.fetch, this.basePath);
    }
    /** 
     * get ISS information by City Code.
     * This operation return configurations of ISS that match with parameters queries 
     * @param cityCode City Code
     * @param code Identificator of this configuration, it is unique for account or standard namedspace 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inctives versions too 
     */
    getIssConfByCity(params: {  "cityCode": number; "code"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfISSApiFp.getIssConfByCity(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of ISS
     * This operation return ISS configurations that match with parameters queries 
     * @param suffixcode Identify this ISS 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getIssList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfISSApiFp.getIssList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * update a ISS by City Code.
     * @param cityCode City Code
     * @param issConfByCity The pet JSON you want to post
     */
    updateIssConfByCity(params: {  "cityCode": number; "issConfByCity": IssConfByCity; }, options?: any) {
        return TaxConfISSApiFp.updateIssConfByCity(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxConfISSApi - factory interface
 */
export const TaxConfISSApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * create a new ISS Configuration
         * @param issConfByCity The pet JSON you want to post
         */
        createIssConfByCity(params: {  "issConfByCity": IssConfByCity; }, options?: any) {
            return TaxConfISSApiFp.createIssConfByCity(params, options)(fetch, basePath);
        },
        /** 
         * disable a ISS by City Code.
         * @param cityCode City Code
         */
        deleteIssConf(params: {  "cityCode": number; }, options?: any) {
            return TaxConfISSApiFp.deleteIssConf(params, options)(fetch, basePath);
        },
        /** 
         * get ISS information by City Code.
         * This operation return configurations of ISS that match with parameters queries 
         * @param cityCode City Code
         * @param code Identificator of this configuration, it is unique for account or standard namedspace 
         * @param date When informed return valid version configuration for this date 
         * @param inactive return the inctives versions too 
         */
        getIssConfByCity(params: {  "cityCode": number; "code"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfISSApiFp.getIssConfByCity(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of ISS
         * This operation return ISS configurations that match with parameters queries 
         * @param suffixcode Identify this ISS 
         * @param date When informed return valid version configuration for this date 
         * @param inactive return the inactive versions too 
         */
        getIssList(params: {  "suffixcode"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfISSApiFp.getIssList(params, options)(fetch, basePath);
        },
        /** 
         * update a ISS by City Code.
         * @param cityCode City Code
         * @param issConfByCity The pet JSON you want to post
         */
        updateIssConfByCity(params: {  "cityCode": number; "issConfByCity": IssConfByCity; }, options?: any) {
            return TaxConfISSApiFp.updateIssConfByCity(params, options)(fetch, basePath);
        },
    };
};


/**
 * TaxConfProcessApi - fetch parameter creator
 */
export const TaxConfProcessApiFetchParamCreator = {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createProcess(params: {  "taxconfprocess": ProcessScenario; }, options?: any): FetchArgs {
        // verify required parameter "taxconfprocess" is set
        if (params["taxconfprocess"] == null) {
            throw new Error("Missing required parameter taxconfprocess when calling createProcess");
        }
        const baseUrl = `/taxconf/process`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxconfprocess"]) {
            fetchOptions.body = JSON.stringify(params["taxconfprocess"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * disable a Process.
     * @param code Process Code
     */
    deleteProcess(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling deleteProcess");
        }
        const baseUrl = `/taxconf/process/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * get Process information.
     * This operation return Process Type configuration 
     * @param code Process Code
     */
    getProcess(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling getProcess");
        }
        const baseUrl = `/taxconf/process/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * retrive list of Process.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getProcessList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/taxconf/process`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "accountId": params["accountId"],
            "date": params["date"],
            "inactive": params["inactive"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * update a Process Type configuration
     * @param code Process Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateProcess(params: {  "code": string; "taxconfprocess": ProcessScenario; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling updateProcess");
        }
        // verify required parameter "taxconfprocess" is set
        if (params["taxconfprocess"] == null) {
            throw new Error("Missing required parameter taxconfprocess when calling updateProcess");
        }
        const baseUrl = `/taxconf/process/{code}`
            .replace(`{${"code"}}`, `${ params["code"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["taxconfprocess"]) {
            fetchOptions.body = JSON.stringify(params["taxconfprocess"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TaxConfProcessApi - functional programming interface
 */
export const TaxConfProcessApiFp = {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createProcess(params: { "taxconfprocess": ProcessScenario;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
        const fetchArgs = TaxConfProcessApiFetchParamCreator.createProcess(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * disable a Process.
     * @param code Process Code
     */
    deleteProcess(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfProcessApiFetchParamCreator.deleteProcess(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * get Process information.
     * This operation return Process Type configuration 
     * @param code Process Code
     */
    getProcess(params: { "code": string;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<ProcessScenario> {
        const fetchArgs = TaxConfProcessApiFetchParamCreator.getProcess(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * retrive list of Process.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getProcessList(params: { "accountId"?: string; "date"?: Date; "inactive"?: boolean;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<Array<ProcessScenario>> {
        const fetchArgs = TaxConfProcessApiFetchParamCreator.getProcessList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * update a Process Type configuration
     * @param code Process Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateProcess(params: { "code": string; "taxconfprocess": ProcessScenario;  }, options?: any): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TaxConfProcessApiFetchParamCreator.updateProcess(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TaxConfProcessApi - object-oriented interface
 */
export class TaxConfProcessApi extends BaseAPI {
    /** 
     * create a new Process Type configuration
     * @param taxconfprocess The pet JSON you want to post
     */
    createProcess(params: {  "taxconfprocess": ProcessScenario; }, options?: any) {
        return TaxConfProcessApiFp.createProcess(params, options)(this.fetch, this.basePath);
    }
    /** 
     * disable a Process.
     * @param code Process Code
     */
    deleteProcess(params: {  "code": string; }, options?: any) {
        return TaxConfProcessApiFp.deleteProcess(params, options)(this.fetch, this.basePath);
    }
    /** 
     * get Process information.
     * This operation return Process Type configuration 
     * @param code Process Code
     */
    getProcess(params: {  "code": string; }, options?: any) {
        return TaxConfProcessApiFp.getProcess(params, options)(this.fetch, this.basePath);
    }
    /** 
     * retrive list of Process.
     * This operation return Process Type configurations that match with parameters queries 
     * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
     * @param date When informed return valid version configuration for this date 
     * @param inactive return the inactive versions too 
     */
    getProcessList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
        return TaxConfProcessApiFp.getProcessList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * update a Process Type configuration
     * @param code Process Code
     * @param taxconfprocess The pet JSON you want to post
     */
    updateProcess(params: {  "code": string; "taxconfprocess": ProcessScenario; }, options?: any) {
        return TaxConfProcessApiFp.updateProcess(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TaxConfProcessApi - factory interface
 */
export const TaxConfProcessApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * create a new Process Type configuration
         * @param taxconfprocess The pet JSON you want to post
         */
        createProcess(params: {  "taxconfprocess": ProcessScenario; }, options?: any) {
            return TaxConfProcessApiFp.createProcess(params, options)(fetch, basePath);
        },
        /** 
         * disable a Process.
         * @param code Process Code
         */
        deleteProcess(params: {  "code": string; }, options?: any) {
            return TaxConfProcessApiFp.deleteProcess(params, options)(fetch, basePath);
        },
        /** 
         * get Process information.
         * This operation return Process Type configuration 
         * @param code Process Code
         */
        getProcess(params: {  "code": string; }, options?: any) {
            return TaxConfProcessApiFp.getProcess(params, options)(fetch, basePath);
        },
        /** 
         * retrive list of Process.
         * This operation return Process Type configurations that match with parameters queries 
         * @param accountId filter the configuration by accountID, if not informed, only the standard configuration will be returned 
         * @param date When informed return valid version configuration for this date 
         * @param inactive return the inactive versions too 
         */
        getProcessList(params: {  "accountId"?: string; "date"?: Date; "inactive"?: boolean; }, options?: any) {
            return TaxConfProcessApiFp.getProcessList(params, options)(fetch, basePath);
        },
        /** 
         * update a Process Type configuration
         * @param code Process Code
         * @param taxconfprocess The pet JSON you want to post
         */
        updateProcess(params: {  "code": string; "taxconfprocess": ProcessScenario; }, options?: any) {
            return TaxConfProcessApiFp.updateProcess(params, options)(fetch, basePath);
        },
    };
};

