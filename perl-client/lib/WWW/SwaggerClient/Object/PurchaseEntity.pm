=begin comment

BR16 - API

This documentation is about service accessories that will compose the product BR16, this services are essencial to maintenance and configuration of accounts

OpenAPI spec version: 1.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package WWW::SwaggerClient::Object::PurchaseEntity;

require 5.6.0;
use strict;
use warnings;
use utf8;
use JSON qw(decode_json);
use Data::Dumper;
use Module::Runtime qw(use_module);
use Log::Any qw($log);
use Date::Parse;
use DateTime;

use base ("Class::Accessor", "Class::Data::Inheritable");


#
#
#
# NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
# REF: https://github.com/swagger-api/swagger-codegen
#

=begin comment

BR16 - API

This documentation is about service accessories that will compose the product BR16, this services are essencial to maintenance and configuration of accounts

OpenAPI spec version: 1.0

Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
__PACKAGE__->mk_classdata('attribute_map' => {});
__PACKAGE__->mk_classdata('swagger_types' => {});
__PACKAGE__->mk_classdata('method_documentation' => {}); 
__PACKAGE__->mk_classdata('class_documentation' => {});

# new object
sub new { 
    my ($class, %args) = @_; 

	my $self = bless {}, $class;
	
	foreach my $attribute (keys %{$class->attribute_map}) {
		my $args_key = $class->attribute_map->{$attribute};
		$self->$attribute( $args{ $args_key } );
	}
	
	return $self;
}  

# return perl hash
sub to_hash {
    return decode_json(JSON->new->convert_blessed->encode( shift ));
}

# used by JSON for serialization
sub TO_JSON { 
    my $self = shift;
    my $_data = {};
    foreach my $_key (keys %{$self->attribute_map}) {
        if (defined $self->{$_key}) {
            $_data->{$self->attribute_map->{$_key}} = $self->{$_key};
        }
    }
    return $_data;
}

# from Perl hashref
sub from_hash {
    my ($self, $hash) = @_;

    # loop through attributes and use swagger_types to deserialize the data
    while ( my ($_key, $_type) = each %{$self->swagger_types} ) {
    	my $_json_attribute = $self->attribute_map->{$_key}; 
        if ($_type =~ /^array\[/i) { # array
            my $_subclass = substr($_type, 6, -1);
            my @_array = ();
            foreach my $_element (@{$hash->{$_json_attribute}}) {
                push @_array, $self->_deserialize($_subclass, $_element);
            }
            $self->{$_key} = \@_array;
        } elsif (exists $hash->{$_json_attribute}) { #hash(model), primitive, datetime
            $self->{$_key} = $self->_deserialize($_type, $hash->{$_json_attribute});
        } else {
        	$log->debugf("Warning: %s (%s) does not exist in input hash\n", $_key, $_json_attribute);
        }
    }
  
    return $self;
}

# deserialize non-array data
sub _deserialize {
    my ($self, $type, $data) = @_;
    $log->debugf("deserializing %s with %s",Dumper($data), $type);
        
    if ($type eq 'DateTime') {
        return DateTime->from_epoch(epoch => str2time($data));
    } elsif ( grep( /^$type$/, ('int', 'double', 'string', 'boolean'))) {
        return $data;
    } else { # hash(model)
        my $_instance = eval "WWW::SwaggerClient::Object::$type->new()";
        return $_instance->from_hash($data);
    }
}



__PACKAGE__->class_documentation({description => '',
                                  class => 'PurchaseEntity',
                                  required => [], # TODO
}                                 );

__PACKAGE__->method_documentation({
    'name' => {
    	datatype => 'string',
    	base_name => 'name',
    	description => 'Legal Name of Service buyer.',
    	format => '',
    	read_only => '',
    		},
    'type' => {
    	datatype => 'EntityType',
    	base_name => 'type',
    	description => '',
    	format => '',
    	read_only => '',
    		},
    'email' => {
    	datatype => 'string',
    	base_name => 'email',
    	description => 'Entity Email',
    	format => '',
    	read_only => '',
    		},
    'cnpjcpf' => {
    	datatype => 'string',
    	base_name => 'cnpjcpf',
    	description => 'CNPJ/CPF of Sales Buyer. If CPF, pattern is &#39;[0-9]{11}&#39; if CNPJ, pattern is &#39;[0-9]{14}&#39;',
    	format => '',
    	read_only => '',
    		},
    'city_tax_id' => {
    	datatype => 'string',
    	base_name => 'cityTaxId',
    	description => 'City Tax ID',
    	format => '',
    	read_only => '',
    		},
    'state_tax_id' => {
    	datatype => 'string',
    	base_name => 'stateTaxId',
    	description => 'State Tax ID',
    	format => '',
    	read_only => '',
    		},
    'suframa' => {
    	datatype => 'string',
    	base_name => 'suframa',
    	description => 'Suframa ID',
    	format => '',
    	read_only => '',
    		},
    'phone' => {
    	datatype => 'string',
    	base_name => 'phone',
    	description => 'Entity Phone',
    	format => '',
    	read_only => '',
    		},
    'tax_regime' => {
    	datatype => 'FederalTaxRegime',
    	base_name => 'taxRegime',
    	description => '',
    	format => '',
    	read_only => '',
    		},
    'has_cpom' => {
    	datatype => 'boolean',
    	base_name => 'hasCpom',
    	description => 'Some cities require PURCHASE.Buyers to withhold ISS (City Tax) from PURCHASE.Sellers stablished in different cities. In case the PURCHASE.Seller has acquired a Tax Registration in this destination city, by providing this information in the service invoice, this withholding obligation is lifted.',
    	format => '',
    	read_only => '',
    		},
    'subject_withholding_irrf' => {
    	datatype => 'boolean',
    	base_name => 'subjectWithholdingIrrf',
    	description => 'These are the federal taxes attributes that determine whether withholding of taxes should take place. In special cases where the PURCHASE.Seller is exempt of one or more of these taxes the withholding follows the same rules. The Business type may also dictate these rules as well.',
    	format => '',
    	read_only => '',
    		},
    'inss_previous_contrib' => {
    	datatype => 'double',
    	base_name => 'inssPreviousContrib',
    	description => 'The INSS contribution is capped at a maximum limit (amount of actual retired payment available in the country).  Individuals sellers subject to INSS withholding can provide the amount already tax by other transactions (with the same buyer or different ones) to deduct to the tax basis. This amount is to be provided to the Seller in a form of a signed document.',
    	format => '',
    	read_only => '',
    		},
    'inss_basis_discount' => {
    	datatype => 'double',
    	base_name => 'inssBasisDiscount',
    	description => 'The INSS contribution is applicable only to the labor amount in a service contract.  There are several items that may be deducted from the service invoice total to arrive at the INSS taxable amount. This amount is to be provided to the Seller in the body of the Invoice or calculated during the transaction input.',
    	format => '',
    	read_only => '',
    		},
    'iss_rf_rate' => {
    	datatype => 'double',
    	base_name => 'issRfRate',
    	description => 'When Seller is Simples regime, the seller needs send RF rate.',
    	format => '',
    	read_only => '',
    		},
});

__PACKAGE__->swagger_types( {
    'name' => 'string',
    'type' => 'EntityType',
    'email' => 'string',
    'cnpjcpf' => 'string',
    'city_tax_id' => 'string',
    'state_tax_id' => 'string',
    'suframa' => 'string',
    'phone' => 'string',
    'tax_regime' => 'FederalTaxRegime',
    'has_cpom' => 'boolean',
    'subject_withholding_irrf' => 'boolean',
    'inss_previous_contrib' => 'double',
    'inss_basis_discount' => 'double',
    'iss_rf_rate' => 'double'
} );

__PACKAGE__->attribute_map( {
    'name' => 'name',
    'type' => 'type',
    'email' => 'email',
    'cnpjcpf' => 'cnpjcpf',
    'city_tax_id' => 'cityTaxId',
    'state_tax_id' => 'stateTaxId',
    'suframa' => 'suframa',
    'phone' => 'phone',
    'tax_regime' => 'taxRegime',
    'has_cpom' => 'hasCpom',
    'subject_withholding_irrf' => 'subjectWithholdingIrrf',
    'inss_previous_contrib' => 'inssPreviousContrib',
    'inss_basis_discount' => 'inssBasisDiscount',
    'iss_rf_rate' => 'issRfRate'
} );

__PACKAGE__->mk_accessors(keys %{__PACKAGE__->attribute_map});


1;
